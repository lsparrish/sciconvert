<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>main.html</title>

    <!-- Libraries -->
    <!-- PDF.js for rendering the scanned document -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
    </script>

    <!-- Marked for Markdown parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <!-- KaTeX for Math rendering -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js"></script>

    <!-- Tailwind for layout (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- html2canvas for DOM screenshots -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- REMOVED: gif.js library -->

    <style>
      /* Custom Scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      ::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #e5e7eb;
        height: 100vh;
        overflow: hidden;
      }

      /* Custom Tab Styles */
      .tab-button {
        padding: 0.75rem 1.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        color: #4b5563;
        border-bottom: 2px solid transparent;
        cursor: pointer;
        transition: all 0.1s ease-in-out;
      }
      .tab-button:hover {
        color: #1f2937;
        border-bottom-color: #e5e7eb;
      }
      .tab-button.active {
        color: #2563eb;
        border-bottom-color: #2563eb;
        background-color: #fff;
      }

      /* PDF Canvas Styles */
      #pdf-render-container {
        /* Fixed an invalid box-shadow string that was causing a SyntaxError */
        box-shadow:
          0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        background-color: #525659;
        overflow: auto;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 20px;
      }

      canvas {
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        max-width: none;
      }

      /* Editor Styles */
      .editor-textarea {
        font-family: "Consolas", "Monaco", "Courier New", monospace;
        line-height: 1.6;
        resize: none;
      }

      /* Preview Styles */
      .preview-content {
        line-height: 1.6;
        text-align: justify;
      }

      /* Font Classes */
      .font-serif {
        font-family: "Times New Roman", Times, serif;
      }
      .font-sans {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }
      .font-mono {
        font-family: "Courier New", Courier, monospace;
      }

      .two-columns {
        column-count: 2;
        column-gap: 2rem;
      }

      /* Loader */
      .loader {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Selection Box Styles */
      #selection-box {
        border: 2px dashed #2563eb;
        background-color: rgba(37, 99, 235, 0.1);
        position: absolute;
        pointer-events: none; /* Let events pass through to layer */
        display: none;
        z-index: 50;
      }

      /* Orange outline for Editing Mode */
      #selection-box.edit-mode {
        border-color: #f97316; /* Orange-500 */
        background-color: rgba(249, 115, 22, 0.1);
      }

      /* OVERLAY HEURISTIC RESET: Ensure AI/HTML content has no default margins */
      #overlay-html-layer * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        /* STRICT RESET: 1.0 line height matches print closer than 1.15 */
        line-height: 1;
      }
      #overlay-html-layer div {
        /* Ensure the containers themselves don't collapse */
        box-sizing: border-box;
      }

      /* Debug View Overlay (Modal, now only used for capturing the data) */
      #debug-vision-overlay {
        /* We are repurposing this ID for the content of the new tab */
        display: none; /* Keep hidden, content moved to editor-container-debug */
      }

      /* New Debug Tab Content Styling */
      #editor-container-debug {
        /* This is the new container for the side-by-side view */
        background: #2d3748; /* dark grey matching header */
      }
      #debug-vision-content-tab {
        /* Styles for the inner content of the debug tab */
        display: flex;
        gap: 20px;
        width: 100%;
        padding: 20px 20px 0 20px; /* Adjust padding to separate images from textarea */
        justify-content: space-evenly;
        align-items: flex-start;
      }
      .debug-pane-tab {
        flex-shrink: 0;
        width: 45%; /* Keep side-by-side on large screens */
        max-width: 600px;
        min-width: 300px;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #333;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }
      .debug-pane-tab img {
        max-width: 100%;
        height: auto;
        object-fit: contain;
        border: 1px solid #555;
      }

      /* History Strip Styling */
      #debug-history-strip {
        padding: 10px 20px;
      }
      #history-images-container {
        display: flex;
        gap: 0.75rem;
        height: 6rem; /* fixed height for history strip */
        align-items: center;
        overflow-x: auto;
      }
      #history-images-container img {
        height: 100%;
        width: auto;
        flex-shrink: 0;
      }

      /* --- Context Menu Styles (Simplified/Stripped) --- */
      #context-menu {
        /* Hiding context menu logic since we are transitioning to action bar */
        display: none !important;
      }

      /* --- Action Bar Styles (Selection) --- */
      #selection-action-bar {
        position: fixed;
        z-index: 10000;
        display: none;
        transform-origin: top center;
        animation: fadeIn 0.1s ease-out;
      }

      /* --- Action Bar Styles (Edit) --- */
      #edit-action-bar {
        z-index: 0;
        /* Position and width managed by Tailwind classes in HTML: w-full shrink-0 */
      }

      .disabled-bar {
        opacity: 0.5;
        pointer-events: none;
        transition: opacity 0.2s ease-in-out;
      }

      .action-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 0.5rem;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.15s;
        color: #4b5563;
        background: #f9fafb;
        border: 1px solid #f3f4f6;
      }

      .action-btn:hover {
        background-color: #f3f4f6;
        color: #1f2937;
        transform: translateY(-1px);
      }

      .action-btn svg {
        width: 1.25rem;
        height: 1.25rem;
        margin-bottom: 0.1rem;
      }

      .action-btn span {
        font-size: 0.65rem;
        font-weight: 600;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.95) translateY(-5px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
    </style>
  </head>
  <body class="flex flex-col h-screen">
    <!-- Header / Toolbar -->
    <header
      class="bg-gray-800 text-white p-3 flex justify-between items-center shadow-md z-10 shrink-0"
    >
      <div class="flex items-center gap-4">
        <h1 class="text-xl font-bold tracking-wider mr-4">
          SciText <span class="text-blue-400">Digitizer</span>
        </h1>
        <h1>
          <a href="https://github.com/lsparrish/sciconvert">GH</a>
        </h1>

        <div class="relative">
          <input
            type="file"
            id="pdf-upload"
            accept="application/pdf"
            class="hidden"
          />
          <label
            for="pdf-upload"
            class="cursor-pointer bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          >
            <svg
              class="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
              ></path>
            </svg>
            Load PDF
          </label>
        </div>

        <div
          class="flex items-center bg-gray-700 rounded px-2 py-1 gap-2"
          id="pdf-nav-controls"
          style="display: none"
        >
          <button
            id="prev-page"
            class="hover:text-blue-300 p-1 disabled:opacity-50"
            title="Previous Page"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M15 19l-7-7 7-7"
              ></path>
            </svg>
          </button>
          <span class="text-sm font-mono"
            >Page <span id="page-num">0</span> /
            <span id="page-count">0</span></span
          >
          <button
            id="next-page"
            class="hover:text-blue-300 p-1 disabled:opacity-50"
            title="Next Page"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M9 5l7 7-7 7"
              ></path>
            </svg>
          </button>
        </div>

        <div
          class="flex items-center bg-gray-700 rounded px-2 py-1 gap-2"
          id="pdf-zoom-controls"
          style="display: none"
        >
          <button
            id="zoom-out"
            class="hover:text-blue-300 p-1"
            title="Zoom Out"
          >
            -
          </button>
          <span id="zoom-level" class="text-xs font-mono w-12 text-center"
            >100%</span
          >
          <button id="zoom-in" class="hover:text-blue-300 p-1" title="Zoom In">
            +
          </button>
        </div>
      </div>

      <div class="flex items-center gap-4">
        <span
          id="restore-badge"
          class="hidden bg-amber-100 text-amber-800 text-xs font-medium px-2.5 py-0.5 rounded border border-amber-400"
        >
          Restored: <span id="restored-filename" class="font-bold"></span>
        </span>

        <button
          id="export-md"
          class="bg-green-600 hover:bg-green-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          title="Download Transcription"
        >
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
            ></path>
          </svg>
          Export
        </button>

        <button
          id="fullscreen-toggle"
          class="bg-purple-600 hover:bg-purple-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          title="Toggle Fullscreen Mode"
        >
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 8V4m0 0h4M4 4l5 5m11-5v4m0 0h-4m4 0l-5-5M4 16v4m0 0h4M4 20l5-5m11 5v-4m0 0h-4m4 0l-5 5"
            ></path>
          </svg>
          Full
        </button>
      </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 flex flex-col overflow-hidden relative">
      <!-- Tab Bar -->
      <div
        id="main-tab-bar"
        class="flex bg-gray-50 border-b border-gray-200 shadow-inner shrink-0"
      >
        <button id="tab-overlay" class="tab-button active">
          Overlay Editor
        </button>
        <button
          id="tab-prompts"
          class="tab-button text-red-600 hover:text-red-800"
        >
          Prompts
        </button>
        <button
          id="tab-debug"
          class="tab-button text-purple-600 hover:text-purple-800"
        >
          Debug (Images)
        </button>
      </div>

      <div
        id="empty-state"
        class="absolute inset-0 flex flex-col items-center justify-center bg-gray-100 z-50 text-gray-500"
      >
        <svg
          class="w-24 h-24 mb-4 text-gray-300"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="1.5"
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          ></path>
        </svg>
        <h2 class="text-2xl font-bold mb-2">No Document Loaded</h2>
        <p class="mb-6">Upload a PDF to begin digitizing.</p>
      </div>

      <div id="workspace" class="flex-1 overflow-hidden relative bg-white">
        <!-- 1. Source (PDF) Container: KEPT as it contains the canvas -->
        <div
          id="source-container"
          class="absolute inset-0 flex flex-col hidden"
        >
          <div id="pdf-render-container" class="w-full h-full">
            <canvas id="the-canvas"></canvas>
          </div>
          <div
            id="pdf-loader"
            class="absolute inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center hidden"
          >
            <div class="loader mb-2"></div>
            <span class="text-white text-sm font-semibold"
              >Rendering Page...</span
            >
          </div>
        </div>

        <!-- 2. Overlay Split View Container -->
        <div id="overlay-container" class="absolute inset-0 flex hidden">
          <!-- Left: Editor -->
          <div
            class="w-1/3 h-full flex flex-col border-r border-gray-300 z-20 bg-white shadow-xl"
          >
            <div
              class="bg-gray-100 px-4 py-2 text-xs font-bold text-gray-500 border-b flex justify-between"
            >
              <span id="editor-title">OVERLAY HTML</span>
              <div class="flex items-center gap-4">
                <span id="ai-status" class="text-blue-600 hidden"
                  >AI Processing...</span
                >
                <span
                  id="show-ai-log"
                  class="text-gray-500 hover:text-gray-900 cursor-pointer font-semibold hidden"
                  onclick="toggleAiLog()"
                >
                  [AI Log]
                </span>
              </div>
            </div>
            <textarea
              id="overlay-html-input"
              class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-gray-800 bg-gray-50 text-xs"
              placeholder="<!-- Select a region on the right to digitize -->"
            ></textarea>

            <!-- Action Bar for Editing a selected DIV (Always Visible, toggled enabled/disabled) -->
            <div
              id="edit-action-bar"
              class="w-full shrink-0 flex border-t border-gray-200 bg-gray-50 p-2 overflow-x-auto disabled-bar"
            >
              <!-- Smart Style (AI) Group -->
              <button
                id="btn-ai-replica-edit"
                class="action-btn text-blue-600 hover:text-blue-700"
                onclick="runAiReplica()"
                title="AI Replica Style Match (Single Step)"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                  ></path>
                </svg>
                <span>AI Style (1x)</span>
              </button>
              
              <!-- NEW BUTTON FOR LOOPING -->
              <button
                id="btn-ai-loop-edit"
                class="action-btn text-indigo-600 hover:text-indigo-700"
                onclick="runAiReplicaLoop(5)"
                title="Automatically run AI Replica 5 times to refine alignment"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11.816 6H15m4.418-9a8 8 0 10-15.356 2m15.356-2H15"
                  ></path>
                </svg>
                <span>Run 5x</span>
              </button>
              
              <button
                id="btn-ai-font-edit"
                class="action-btn text-purple-600 hover:text-purple-700"
                onclick="runAiFont()"
                title="AI Match Font Only"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                  ></path>
                </svg>
                <span>AI Font</span>
              </button>
              <button
                id="btn-ai-text-edit"
                class="action-btn text-green-600 hover:text-green-700"
                onclick="runAiText()"
                title="AI Transcribe Text Only"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 6h16M4 12h16M4 18h7"
                  ></path>
                </svg>
                <span>AI Text</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <!-- Typography Group -->
              <button
                class="action-btn font-serif text-sm h-auto w-10 text-gray-700 hover:text-black"
                onclick="updateStyle('font-family', 'Times New Roman, serif')"
                title="Serif"
              >
                T
              </button>
              <button
                class="action-btn font-sans text-sm h-auto w-10 text-gray-700 hover:text-black"
                onclick="updateStyle('font-family', 'Arial, sans-serif')"
                title="Sans"
              >
                S
              </button>
              <button
                class="action-btn text-gray-700 hover:text-black"
                onclick="updateStyle('text-align', 'justify')"
                title="Justify Text"
              >
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M3 6h18M3 12h18M3 18h18" />
                </svg>
                <span>Justify</span>
              </button>
              <button
                class="action-btn text-gray-700 hover:text-black"
                onclick="updateStyle('font-weight', 'bold')"
                title="Bold"
              >
                <span class="text-sm font-bold">B</span>
                <span>Bold</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <!-- Actions Group -->
              <button
                id="btn-clear-styles-edit"
                class="action-btn text-amber-600 hover:text-amber-700"
                onclick="clearStyles()"
                title="Remove all styling"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"
                  ></path>
                </svg>
                <span>Clear CSS</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <button
                id="btn-delete-div-edit"
                class="action-btn text-red-600 hover:text-red-700"
                onclick="deleteDiv()"
                title="Delete Selection"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                  ></path>
                </svg>
                <span>Delete</span>
              </button>
            </div>
          </div>

          <!-- Right: Preview (Superimposed) -->
          <div class="w-2/3 h-full flex flex-col relative bg-gray-500">
            <!-- Overlay Toolbar -->
            <div
              class="bg-gray-200 p-2 flex gap-4 border-b border-gray-400 shrink-0 z-30 justify-center text-sm text-gray-700 shadow-sm"
            >
              <label
                class="flex items-center gap-2 cursor-pointer font-semibold hover:text-black"
              >
                <input
                  type="checkbox"
                  id="chk-show-source"
                  checked
                  class="rounded text-blue-600 focus:ring-blue-500"
                />
                Show Source PDF
              </label>
              <div class="w-px h-4 bg-gray-400 my-auto"></div>
              <label
                class="flex items-center gap-2 cursor-pointer font-semibold hover:text-black"
              >
                <input
                  type="checkbox"
                  id="chk-show-overlay"
                  checked
                  class="rounded text-blue-600 focus:ring-blue-500"
                />
                Show HTML Overlay
              </label>
            </div>

            <!-- Scroller -->
            <div
              id="overlay-scroller"
              class="flex-1 overflow-auto flex justify-center p-8 select-none relative"
            >
              <!-- Wrapper matches Canvas Size -->
              <div
                id="overlay-wrapper"
                class="relative shadow-2xl origin-top bg-white"
              >
                <!-- Mount point for Canvas when in this view -->
                <div
                  id="overlay-canvas-mount"
                  class="transition-opacity duration-200"
                ></div>

                <!-- HTML Layer (Rendered Content) -->
                <div
                  id="overlay-html-layer"
                  class="absolute inset-0 overflow-hidden pointer-events-none z-10 transition-opacity duration-200"
                ></div>

                <!-- Selection Layer (Interactive) -->
                <div
                  id="selection-layer"
                  class="absolute inset-0 z-20 cursor-crosshair"
                ></div>

                <!-- Visual Selection Box -->
                <div id="selection-box"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- 3. Editor Container (Markdown/Write - Removed from nav, kept for export) -->
        <div
          id="editor-container-md"
          class="absolute inset-0 flex flex-col hidden"
        >
          <textarea
            id="markdown-input"
            class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-gray-800 bg-gray-50 text-sm"
            placeholder="# Transcription Area"
          ></textarea>
        </div>

        <!-- 4. Preview Container (Render - Removed from nav) -->
        <div
          id="preview-container"
          class="absolute inset-0 overflow-y-auto p-8 hidden bg-white"
        >
          <div
            id="preview-output"
            class="preview-content font-serif text-gray-900 max-w-none"
          ></div>
        </div>

        <!-- 5. Prompts Container (Debug Tab) -->
        <div
          id="editor-container-prompts"
          class="absolute inset-0 flex flex-col hidden"
        >
          <textarea
            id="prompt-input"
            class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-xs"
            placeholder="Loading AI prompts..."
          ></textarea>
        </div>

        <!-- 6. Debug Images Container (NEW TAB CONTENT) -->
        <div
          id="editor-container-debug"
          class="absolute inset-0 hidden flex flex-col p-4 bg-gray-800 overflow-y-auto"
        >
          <!-- Image Comparison Row (Source vs. Current) -->
          <div
            id="debug-vision-content-tab"
            class="flex-shrink-0 flex justify-space-evenly gap-4"
          >
            <div class="debug-pane-tab">
              <span
                id="debug-source-label"
                class="text-sm font-bold text-yellow-300 mb-2"
              >
                TARGET (Source Scan)
              </span>
              <img id="debug-source-img" alt="Target Image Snippet" />
            </div>
            <div class="debug-pane-tab">
              <span
                id="debug-render-label"
                class="text-sm font-bold text-blue-300 mb-2"
              >
                CURRENT RENDER (HTML Output)
              </span>
              <img id="debug-render-img" alt="Current HTML Render" />
            </div>
          </div>

          <!-- NEW: History Strip -->
          <div
            id="debug-history-strip"
            class="flex-shrink-0 mt-4 p-2 bg-gray-900 rounded-lg shadow-inner overflow-x-auto whitespace-nowrap"
          >
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs font-semibold text-gray-400 align-middle"
                    >Past Attempts (Max 4):</span
                >
                <button 
                    id="btn-toggle-playback" 
                    class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 text-xs rounded font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed"
                    onclick="toggleHistoryPlayback()"
                    disabled
                >
                    <span id="playback-text">Play History</span>
                </button>
            </div>
            <div
              id="history-images-container"
              class="inline-flex gap-3 h-24"
            ></div>
          </div>

          <!-- HTML Content Area -->
          <div class="flex-1 flex flex-col pt-4 overflow-hidden">
            <span class="text-xs font-bold text-gray-400 mb-1 pl-4"
              >HTML Content Sent to AI</span
            >
            <textarea
              id="debug-html-content"
              class="editor-textarea flex-1 w-full p-4 outline-none text-gray-200 bg-gray-900 text-xs border border-gray-700 resize-none"
              readonly
            ></textarea>
          </div>
        </div>
      </div>
    </main>

    <!-- Action Bar (For new selections) -->
    <div
      id="selection-action-bar"
      class="bg-gray-800 text-white rounded-lg shadow-2xl flex items-center p-1.5 gap-2 border border-gray-700"
    >
      <button id="btn-digitize" class="action-btn" title="Digitize Text (AI)">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          ></path>
        </svg>
        <span>Digitize</span>
      </button>
      <button id="btn-copy-image" class="action-btn" title="Extract Image">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
          ></path>
        </svg>
        <span>Image</span>
      </button>
      <button id="btn-create-div" class="action-btn" title="Empty Box">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z"
          ></path>
        </svg>
        <span>Empty</span>
      </button>

      <div class="w-px h-8 bg-gray-600 mx-0.5"></div>

      <button
        id="btn-close-action"
        class="action-btn text-gray-400 hover:text-red-400"
        title="Close"
        onclick="closeSelection()"
      >
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"
          ></path>
        </svg>
        <span>Cancel</span>
      </button>
    </div>

    <!-- Context Menu (hidden) -->
    <div
      id="context-menu"
      class="flex flex-col bg-white border border-gray-300 shadow-lg"
      style="
        position: fixed;
        z-index: 9999;
        display: none;
        min-width: 230px;
        border-radius: 4px;
        overflow: hidden;
      "
    >
      <!-- Content removed, using edit-action-bar instead -->
    </div>

    <!-- Debug Vision Overlay Mount (REMOVED/REPURPOSED) -->
    <div id="debug-vision-overlay" style="display: none">
      <!-- Content moved to #editor-container-debug -->
    </div>

    <script type="module">
      const apiKey = ""; // Runtime key
      const STORAGE_KEY = "scitext_transcriptions";
      const STORAGE_KEY_LAST_PAGE = "scitext_last_page_num";
      const STORAGE_KEY_FILENAME = "scitext_last_filename";
      const STORAGE_KEY_PROMPTS = "scitext_ai_prompts"; // Key for prompts

      // NEW: Default image URL for testing
      const DEFAULT_IMAGE_URL =
        "https://lsparrish.github.io/sciconvert/sample.png";

      let transcriptionData = {};
      let aiQueryLog = []; // Global storage for AI request/response logs

      // --- State ---
      const state = {
        pdfDoc: null,
        pageNum: 1,
        pageRendering: false,
        pageNumPending: null,
        scale: 1.2,
        canvas: document.getElementById("the-canvas"),
        ctx: document.getElementById("the-canvas").getContext("2d"),
        activeTab: "overlay",
        fontClass: "font-serif",
        isAuthReady: false,
        saveTimeout: null,

        // Selection State
        isSelecting: false,
        selectionStart: { x: 0, y: 0 },
        selectionEnd: { x: 0, y: 0 },
        selectionRect: null,

        // Interaction Target
        targetDivId: null,
        
        // Playback State
        isPlaybackActive: false,
        playbackInterval: null,
        playbackFrames: [],
        originalRenderSource: null,
        
        // Loop State
        isLoopRunning: false, // NEW: Prevent parallel AI calls

        isLogActive: false, // New state variable
        // REMOVED: isEditorFocused: false, // NEW: Track editor focus state

        // AI Prompts (Editable content stored here)
        prompts: {
          DIGITIZE_TEXT:
            "Transcribe the text in this image. Return ONLY the raw text, preserving line breaks. Do not include markdown blocks or commentary. If it is a mathematical formula, return the KaTeX equivalent enclosed in dollar signs ($...$ or $$...$$).",
          REPLICA_STYLE: `You are a Visual CSS Alignment Engine dedicated to achieving maximum visual fidelity to the source document.
I am providing a sequence of images and the corresponding HTML content to help you make pixel-perfect corrections.

Image 1: The "TARGET IMAGE" (Source scanned image). This is the final goal.
Image 2: The "CURRENT RENDER" (Browser rendering of the provided HTML). This is the state to be corrected.
Images 3 to {{imageCount}}: These are "PAST ATTEMPTS" (Historical Renders from newest to oldest). Use these to analyze the effect of recent changes and understand the correction trajectory.

CHALLENGE: Make the alignment and typography in the CURRENT RENDER as close as possible in appearance to the TARGET IMAGE.

CRITICAL CONSTRAINTS:
1. You MUST use inline styling on <span> or other appropriate structural HTML elements (like <p> or <h1>).
2. The (Bounding Box) is for informational purposes only. It shows the width and height. Do not add a enclosing div with these properties.
3. Use the properties **position, top, left, font-size, text-align, font-family, font-weight, and font-style** applied to the internal elements (<span>, <p>, etc.) to correct each element. Use 'position: relative;' along with 'top' and 'left' (using 'em' units) to achieve precise vertical or horizontal placement. Do NOT use these: line-height, margin, padding.
4. Changes to the style values must be in a direction that improves upon the current parameters shown in the CURRENT RENDER.
5. Study the PASE ATTEMPTS to avoid repeating prior ineffective corrections.

--- CURRENT STATE FOR TEST RENDER ---
(Image Count): {{imageCount}}
(Bounding Box): {{promptDimensions}}
(Content HTML): {{content}}
------------------------------------

Respond ONLY with the corrected inner HTML, no commentary or markdown apart from HTML comments.`,
          FONT_STYLE: `Analyze the typography in this image snippet. 
Return a JSON object (and nothing else) containing the following CSS properties that best approximate the text style found in the image:
{
   "fontFamily": "string (standard web-safe stack)",
   "fontWeight": "string or number",
   "fontStyle": "string (normal/italic)",
   "textAlign": "string (left/center/justify/right)",
   "fontSize": "string (e.g. '14px')"
}
Do NOT include markdown formatting. Just the raw JSON string.`,

          TEXT_ONLY: `Transcribe the text in this image. 
- Return ONLY the raw text. 
- Use HTML <p> tags for paragraphs. 
- Do not add any inline styles. 
- Do not include markdown blocks.`,
        },
      };

      // --- IndexedDB Utils ---
      const DB_NAME = "SciTextDB";
      const DB_VERSION = 1;
      const STORE_NAME = "files";

      function openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME);
            }
          };
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function savePDFToDB(blob) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(blob, "currentPdf"); // Store with fixed key
          request.onsuccess = () => resolve();
          request.onerror = (e) => reject(e);
        });
      }

      async function getPDFFromDB() {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get("currentPdf");
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (e) => reject(e);
        });
      }
      
      /**
       * Helper to clone the element and strip non-internal CSS properties
       * before sending the HTML string to the AI.
       */
      var getDivData = function (divElement) {
        const style = divElement.getAttribute("style") || "";

        // Extract percentage values for positioning and sizing
        const leftMatch = style.match(/left:\s*([^;]+)/i);
        const topMatch = style.match(/top:\s*([^;]+)/i);
        const widthMatch = style.match(/width:\s*([^;]+)/i);
        const heightMatch = style.match(/height:\s*([^;]+)/i);

        const left = leftMatch ? leftMatch[1].trim() : "0%";
        const top = topMatch ? topMatch[1].trim() : "0%";
        const width = widthMatch ? widthMatch[1].trim() : "auto";
        const height = heightMatch ? heightMatch[1].trim() : "auto";

        return {
          id: divElement.id,
          content: divElement.innerHTML,
          left: left,
          top: top,
          width: width,
          height: height,
        };
      };
      
      /**
       * Extracts a base64 string from a given div's coordinates on the PDF canvas,
       * using the specified scale for high-resolution output.
       */
      function getSnippetFromDiv(divId, imageScale = 1.0) {
        const div = document.getElementById(divId);
        if (!div) return null;

        const cw = els.theCanvas.width;
        const ch = els.theCanvas.height;
        const pixelRect = {
          x: (parseFloat(div.style.left) / 100) * cw,
          y: (parseFloat(div.style.top) / 100) * ch,
          width: (parseFloat(div.style.width) / 100) * cw,
          height: (parseFloat(div.style.height) / 100) * ch,
        };
        return extractImageSnippet(pixelRect, imageScale); // Pass the scale
      }


      // --- DOM Elements ---
      const els = {
        upload: document.getElementById("pdf-upload"),
        emptyState: document.getElementById("empty-state"),
        pdfLoader: document.getElementById("pdf-loader"),
        navControls: document.getElementById("pdf-nav-controls"),
        zoomControls: document.getElementById("pdf-zoom-controls"),
        prevBtn: document.getElementById("prev-page"),
        nextBtn: document.getElementById("next-page"),
        pageNumSpan: document.getElementById("page-num"),
        pageCountSpan: document.getElementById("page-count"),
        zoomInBtn: document.getElementById("zoom-in"),
        zoomOutBtn: document.getElementById("zoom-out"),
        zoomLevelSpan: document.getElementById("zoom-level"),

        // Removed elements from DOM: previewOutput, previewContainer, editorContainerMd
        // Retain only necessary DOM elements
        // sourceContainer is kept as it holds the canvas when not in overlay view
        sourceContainer: document.getElementById("source-container"),
        overlayContainer: document.getElementById("overlay-container"),

        overlayScroller: document.getElementById("overlay-scroller"),

        pdfRenderContainer: document.getElementById("pdf-render-container"),
        overlayCanvasMount: document.getElementById("overlay-canvas-mount"),
        overlayWrapper: document.getElementById("overlay-wrapper"),
        overlayHtmlLayer: document.getElementById("overlay-html-layer"),
        selectionLayer: document.getElementById("selection-layer"),
        selectionBox: document.getElementById("selection-box"),
        contextMenu: document.getElementById("context-menu"),
        actionBar: document.getElementById("selection-action-bar"),
        editActionBar: document.getElementById("edit-action-bar"),
        theCanvas: document.getElementById("the-canvas"),

        // Removed element from DOM: markdownInput
        // markdownInput is technically still in the DOM for 'export', but not mapped to an active tab. Lets keep it here for export to work.
        markdownInput: document.getElementById("markdown-input"),
        overlayHtmlInput: document.getElementById("overlay-html-input"),

        // Removed tabs: tabSource, tabWrite, tabPreview
        tabOverlay: document.getElementById("tab-overlay"),
        tabDebug: document.getElementById("tab-debug"), // New element

        fontSelect: document.getElementById("font-select"),
        exportBtn: document.getElementById("export-md"),
        fullscreenBtn: document.getElementById("fullscreen-toggle"),

        btnDigitize: document.getElementById("btn-digitize"),
        btnCopyImage: document.getElementById("btn-copy-image"),
        btnCreateDiv: document.getElementById("btn-create-div"),
        aiStatus: document.getElementById("ai-status"),

        chkShowSource: document.getElementById("chk-show-source"),
        chkShowOverlay: document.getElementById("chk-show-overlay"),
        restoreBadge: document.getElementById("restore-badge"),
        restoredFilename: document.getElementById("restored-filename"),

        menuGroupDiv: document.getElementById("menu-group-div"),

        // Debug (Update mapping for new elements)
        // Note: The original #debug-vision-overlay is hidden via style
        debugSourceImg: document.getElementById("debug-source-img"), // New
        debugRenderImg: document.getElementById("debug-render-img"), // New
        closeDebugVision: document.getElementById("close-debug-vision"), // Not used in tab view
        historyImagesContainer: document.getElementById(
          "history-images-container",
        ), // NEW: History container
        
        // NEW Playback elements
        btnTogglePlayback: document.getElementById("btn-toggle-playback"),
        playbackText: document.getElementById("playback-text"),

        // New Debug Tab Container
        editorContainerDebug: document.getElementById("editor-container-debug"),
        // NEW: Textarea for HTML content
        debugHtmlContent: document.getElementById("debug-html-content"),

        // New AI Log Elements
        editorTitle: document.getElementById("editor-title"),
        showAiLog: document.getElementById("show-ai-log"),

        // New Prompt Elements
        tabPrompts: document.getElementById("tab-prompts"),
        promptInput: document.getElementById("prompt-input"),

        // Need to explicitly map the hidden containers, as they are still referenced in switchMainView for display logic
        editorContainerPrompts: document.getElementById(
          "editor-container-prompts",
        ),
        editorContainerMd: document.getElementById("editor-container-md"),
        previewContainer: document.getElementById("preview-container"),
      };

      // --- AI Log Logic (Placed high for visibility) ---
      function updateLogVisibility() {
        if (aiQueryLog.length > 0) {
          els.showAiLog.classList.remove("hidden");
        }
      }

      function renderAiLog() {
        let logContent = `// === AI Query Log (${aiQueryLog.length} entries - Latest First) ===\n\n`;

        // Note: Log entries are added to the start of the array (unshift), so map in order.
        aiQueryLog.forEach((entry, index) => {
          const status = entry.success ? "SUCCESS" : "ERROR";
          logContent += `// [${index + 1}] ${entry.timestamp} - Status: ${status}\n`;
          logContent += `// PROMPT:\n${entry.prompt}\n\n`;
          logContent += `// RESPONSE:\n${entry.response}\n\n`;
          logContent += "-------------------------------------------------\n\n";
        });

        return logContent;
      }
      // ---------------------------------------------------
      
      /**
       * Extracts a base64 string from a given rect on the current canvas, applying an optional scale.
       */
      function extractImageSnippet(pixelRect, outputScale = 1.0) {
        const tempCanvas = document.createElement("canvas");
        // Scale the output canvas dimensions
        tempCanvas.width = pixelRect.width * outputScale;
        tempCanvas.height = pixelRect.height * outputScale;
        const tempCtx = tempCanvas.getContext("2d");
        // Draw the source snippet to the new scaled dimensions
        tempCtx.drawImage(
          state.canvas,
          pixelRect.x,
          pixelRect.y,
          pixelRect.width,
          pixelRect.height,
          0,
          0,
          tempCanvas.width, // Scaled Target Width
          tempCanvas.height, // Scaled Target Height
        );
        return tempCanvas.toDataURL("image/png").split(",")[1];
      }
      
      function parseAIJson(text) {
        try {
          // Try to find a JSON block first
          const jsonMatch = text.match(/\{[\s\S]*\}/);
          if (jsonMatch) return JSON.parse(jsonMatch[0]);
          return JSON.parse(text);
        } catch (e) {
          return null;
        }
      }
      
      /**
       * Helper: Get Div ID from Editor Cursor
       * Returns the ID of the outer-most, currently selected div, or null if outside a div.
       */
      function getTargetDivIdFromCursor() {
        const cursor = els.overlayHtmlInput.selectionStart;
        const text = els.overlayHtmlInput.value;
        let openIndex = -1;
        let balance = 0;

        for (let i = cursor - 1; i >= 0; i--) {
          if (text.substring(i, i + 4) === "<div") {
            if (balance === 0) {
              openIndex = i;
              break;
            }
            balance--;
          } else if (text.substring(i, i + 5) === "/div>") {
            balance++;
          }
        }

        if (openIndex !== -1) {
          const tagEnd = text.indexOf(">", openIndex);
          if (tagEnd !== -1) {
            const tagContent = text.substring(openIndex, tagEnd);
            const match = tagContent.match(/id=["']([^"']+)["']/);
            return match ? match[1] : null;
          }
        }
        return null;
      }
      
      // Playback Control Functions
      function stopPlayback() {
          if (!state.isPlaybackActive) return;

          state.isPlaybackActive = false;
          clearTimeout(state.playbackInterval);
          // Set button text to the default
          els.playbackText.textContent = "Play History"; 
          
          // Restore the final frame (Current Render)
          if (state.originalRenderSource) {
              els.debugRenderImg.src = state.originalRenderSource;
          }
          
          // Clear all thumbnail highlights
          const thumbnails = els.historyImagesContainer.children;
          for (let i = 0; i < thumbnails.length; i++) {
              thumbnails[i].style.border = 'none';
          }
          
          // Re-enable edit action bar based on selection
          updateEditBarState();
      }
      
      function startPlayback() {
          // Check: We need at least one history frame (total frames >= 2, one history + current render)
          if (state.isPlaybackActive || state.playbackFrames.length < 2) return;

          // 1. Store the original state before starting playback
          state.originalRenderSource = els.debugRenderImg.src;
          state.isPlaybackActive = true;
          // Set button text for playing
          els.playbackText.textContent = "Stop Playback";
          
          // Disable edit action bar to prevent changes during playback visualization
          els.editActionBar.classList.add("disabled-bar"); 

          // 2. Start the cycle from the first frame (index 0)
          cycleHistoryFrame(state.playbackFrames, 0);
      }
      
      /**
       * Cycles through the historical frames in the debug panel.
       */
      function cycleHistoryFrame(frames, currentFrameIndex) {
          if (!state.isPlaybackActive) return;

          const frame = frames[currentFrameIndex];
          if (frame) {
              // Display the frame in the main render pane
              els.debugRenderImg.src = `data:image/png;base64,${frame}`;
              
              // Clear all thumbnail highlights
              const thumbnails = els.historyImagesContainer.children;
              for (let i = 0; i < thumbnails.length; i++) {
                  thumbnails[i].style.border = 'none';
              }
              
              // Highlight the corresponding thumbnail in the strip (History frames only)
              // The frames array is [History 1, ..., History N, Current Render]
              const historyFramesCount = frames.length - 1;
              if (currentFrameIndex < historyFramesCount) {
                  const thumbnailIndex = currentFrameIndex;
                  if (thumbnailIndex >= 0 && thumbnailIndex < thumbnails.length) {
                    thumbnails[thumbnailIndex].style.border = '2px solid #6366f1'; // Indigo-500
                  }
              }

              // Move to the next frame
              let nextIndex = currentFrameIndex + 1;
              if (nextIndex >= frames.length) {
                  // Loop back to the start
                  nextIndex = 0;
              }
              
              // Set next frame in the interval
              state.playbackInterval = setTimeout(() => {
                  cycleHistoryFrame(frames, nextIndex);
              }, 600); // 600ms delay per frame
          } else {
              // Something went wrong, stop playback
              stopPlayback();
          }
      }
      
      window.toggleHistoryPlayback = function() {
          if (state.isPlaybackActive) {
              stopPlayback();
          } else {
              startPlayback();
          }
      }

      /**
       * NEW: Function to manage the state of the edit bar and target DIV.
       * Enables the bar if we are NOT looping or logging, restoring general editing capability.
       */
      function updateEditBarState() {
        // Stop playback if user interacts
        if(state.isPlaybackActive) {
            stopPlayback(); 
        }

        const divId = getTargetDivIdFromCursor();
        state.targetDivId = divId; // Always set targetDivId based on cursor position

        // 1. Manage Global Disabled State (Loop/Log)
        if (state.isLogActive || state.isLoopRunning) {
          els.editActionBar.classList.add("disabled-bar");
        } else {
          // FIX: Enable the bar if we are NOT looping or logging. 
          // This is the core fix for enabling the bar when cursor is between divs.
          els.editActionBar.classList.remove("disabled-bar"); 
        }
        
        // 2. Manage Visual Box State (Only draw box if a DIV is targeted)
        if (divId) {
          const divElement = document.getElementById(divId);
          if (divElement) {
            // Draw the box around the targeted DIV for visual feedback
            const cw = els.theCanvas.width;
            const ch = els.theCanvas.height;
            const l = (parseFloat(divElement.style.left) / 100) * cw;
            const t = (parseFloat(divElement.style.top) / 100) * ch;
            const w = (parseFloat(divElement.style.width) / 100) * cw;
            const h = (parseFloat(divElement.style.height) / 100) * ch;

            els.selectionBox.style.left = l + "px";
            els.selectionBox.style.top = t + "px";
            els.selectionBox.style.width = w + "px";
            els.selectionBox.style.height = h + "px";
            els.selectionBox.style.display = "block";
            els.selectionBox.classList.add("edit-mode");
          }
        } else {
          // If no DIV is targeted, hide the box.
          els.selectionBox.style.display = "none";
          els.selectionBox.classList.remove("edit-mode");
        }
      }
      
      /**
       * Generic Gemini API Call Wrapper
       * UPDATED: Robust Array Handling for Images and Logging
       */
      async function queryGemini(prompt, images) {
        // NOTE: Status update relies on the caller to set "AI Processing (1x)..." or "AI Processing Step X..."
        
        let resultText = "";

        // 1. Prepare Log Entry (strictly append-only)
        const logEntry = {
          timestamp: new Date().toLocaleTimeString(),
          prompt: prompt,
          response: "Awaiting response...",
          success: false,
        };
        aiQueryLog.unshift(logEntry); // Add to start of log
        updateLogVisibility(); // Ensure log button is visible
        if (state.isLogActive) toggleAiLog(); // Refresh log view if active


        try {
          // Construct the prompt parts
          const parts = [{ text: prompt }];

          if (Array.isArray(images)) {
            // Multiple images
            images.forEach((img) => {
              parts.push({ inlineData: { mimeType: "image/png", data: img } });
            });
          } else if (images) {
            // Single image
            parts.push({ inlineData: { mimeType: "image/png", data: images } });
          }

          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                contents: [
                  {
                    role: "user",
                    parts: parts,
                  },
                ],
              }),
            },
          );

          if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(
              `API request failed with status: ${response.status}. Body: ${errorBody}`,
            );
          }
          const data = await response.json();

          resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;

          // 2. Update Log on Success
          logEntry.response = resultText || "No text response received.";
          logEntry.success = true;
          if (state.isLogActive) toggleAiLog();

          return resultText;
        } catch (error) {
          console.error("AI Error:", error);
          
          // 2. Update Log on Error
          logEntry.response = `Error: ${error.message}`;
          logEntry.success = false;
          if (state.isLogActive) toggleAiLog();

          // NOTE: DO NOT SET STATUS HERE. Let caller handle visual status update and hiding.

          throw error;
        }
      }

      // --- Persistence ---
      function initPersistence() {
        try {
          const storedData = localStorage.getItem(STORAGE_KEY);
          if (storedData) transcriptionData = JSON.parse(storedData);

          const storedPrompts = localStorage.getItem(STORAGE_KEY_PROMPTS);
          if (storedPrompts) {
            // Load stored prompts into the editor and state
            // The editor input value is set when switching to the tab, but we need to parse it now.
            parsePrompts(storedPrompts);
          }
          // Set initial value in promptInput regardless of persistence load, using state.prompts
          els.promptInput.value = formatPromptsForEditor(state.prompts);
        } catch (error) {
          console.error("Error loading persistence data:", error);
        }

        state.isAuthReady = true;
        restoreSessionFromDB();

        // Initial bar state check
        updateEditBarState();
        
        // REMOVED: Focus/blur handlers for isEditorFocused as it's no longer used for bar state
      }

      // NEW: Function to format state.prompts back into the editor's markdown format
      function formatPromptsForEditor(prompts) {
        let output = `# AI Prompts Configuration\n\nThis document contains the core system instructions and user queries for the AI model's operations. Edit these templates to refine the model's behavior.\n\n---\n`;
        for (const key in prompts) {
          output += `\n## ${key}\n\n\`\`\`\n${prompts[key]}\n\`\`\`\n\n---\n`;
        }
        return output.trim();
      }

      // NEW: Function to parse markdown prompt blocks into state.prompts
      function parsePrompts(markdownText) {
        const blocks = {};

        const regex = /##\s*(\w+)\s*\n+\s*```\s*([\s\S]*?)\s*```/g;
        let match;

        while ((match = regex.exec(markdownText)) !== null) {
          const key = match[1].trim();
          const content = match[2].trim();
          blocks[key] = content;
        }

        // Overwrite state prompts only if block exists
        const requiredKeys = Object.keys(state.prompts);
        let updatedCount = 0;
        requiredKeys.forEach((key) => {
          if (blocks[key]) {
            state.prompts[key] = blocks[key];
            updatedCount++;
          }
        });
        if (updatedCount > 0) {
          console.log(
            `Successfully updated ${updatedCount} prompts from editor.`,
          );
        }
      }

      // NEW: Function to save prompts
      function savePrompts() {
        // This function is now responsible for saving and parsing the prompts when the user types.
        const currentPromptText = els.promptInput.value;

        // 1. Save the raw text to localStorage for persistence
        localStorage.setItem(STORAGE_KEY_PROMPTS, currentPromptText);

        // 2. Reparse the content for immediate use in state.prompts
        parsePrompts(currentPromptText);
      }

      async function restoreSessionFromDB() {
        try {
          const pdfBlob = await getPDFFromDB();
          if (pdfBlob) {
            const lastPageNum = localStorage.getItem(STORAGE_KEY_LAST_PAGE);
            const lastFilename = localStorage.getItem(STORAGE_KEY_FILENAME);
            if (lastFilename) {
              els.restoredFilename.textContent = lastFilename;
              els.restoreBadge.classList.remove("hidden");
            }
            const arrayBuffer = await pdfBlob.arrayBuffer();
            loadPDF(arrayBuffer, lastPageNum ? parseInt(lastPageNum) : 1);
          } else {
            // NEW: Load default image if no PDF is stored
            loadDefaultImage();
          }
        } catch (error) {
          console.log("No previous session found or error loading DB:", error);
          // Fallback to loading default image if DB load fails
          loadDefaultImage();
        }
      }

      // NEW: Function to load the default image
      function loadDefaultImage() {
        // Check if a PDF is already loaded or in pending state
        if (
          (state.pdfDoc && !state.pdfDoc.isStaticImage) ||
          state.pageRendering
        )
          return;

        els.pdfLoader.classList.remove("hidden");
        els.pdfLoader.children[1].textContent = "Loading Sample Image...";

        const img = new Image();
        // Setting crossOrigin is essential for toDataURL on the canvas later
        img.crossOrigin = "anonymous";

        img.onload = function () {
          // 1. Set canvas dimensions
          state.canvas.width = img.width;
          state.canvas.height = img.height;

          // 2. Draw image
          state.ctx.drawImage(img, 0, 0);

          // 3. Mock PDF State for compatibility
          state.pdfDoc = { numPages: 1, isStaticImage: true };
          state.pageNum = 1;

          // 4. Update UI
          els.pdfLoader.classList.add("hidden");
          els.emptyState.classList.add("hidden");
          els.pageCountSpan.textContent = 1;
          els.pageNumSpan.textContent = 1;
          els.navControls.style.display = "flex";
          els.zoomControls.style.display = "none"; // Disable zoom for static image

          // Disable navigation buttons as it's a single static image
          els.prevBtn.disabled = true;
          els.nextBtn.disabled = true;

          // 5. Finalize setup
          updateOverlayWrapperSize();
          loadContentForCurrentPage(true); // Load content from storage for page 1
          els.pdfLoader.children[1].textContent = "Rendering Page..."; // Reset loader text
        };

        img.onerror = function () {
          console.error(
            "Failed to load default image from URL:",
            DEFAULT_IMAGE_URL,
          );
          els.pdfLoader.classList.add("hidden");
          els.emptyState.classList.remove("hidden"); // Show empty state if loading fails
          els.pdfLoader.children[1].textContent = "Rendering Page..."; // Reset loader text
        };

        img.src = DEFAULT_IMAGE_URL;
      }

      function loadPDF(data, pageNum = 1) {
        if (state.pdfDoc && state.pdfDoc.isStaticImage) {
          // Clear static image mock if a new PDF is being loaded
          state.pdfDoc = null;
        }

        pdfjsLib
          .getDocument(data)
          .promise.then(function (pdfDoc_) {
            state.pdfDoc = pdfDoc_;
            state.pageNum = pageNum;
            els.pageCountSpan.textContent = state.pdfDoc.numPages;
            els.emptyState.classList.add("hidden");
            els.navControls.style.display = "flex";
            els.zoomControls.style.display = "flex";
            renderPage(state.pageNum);
          })
          .catch((e) => {
            console.error("Error loading PDF data:", e);
          });
      }

      function updateOverlayWrapperSize() {
        if (els.theCanvas) {
          els.overlayWrapper.style.width = els.theCanvas.width + "px";
          els.overlayWrapper.style.height = els.theCanvas.height + "px";
        }
      }

      function queueRenderPage(num) {
        // Prevent PDF rendering if in static image mode
        if (state.pdfDoc && state.pdfDoc.isStaticImage) {
          return;
        }

        state.pageRendering ? (state.pageNumPending = num) : renderPage(num);
      }

      function loadContentForCurrentPage(forcePreviewUpdate = false) {
        const pageNum = state.pageNum;
        const overlayKey = `overlay_page_${pageNum}`;

        // Markdown logic retained in the data structure for potential future use (Export),
        // but removed from direct UI interaction logic.

        if (
          els.overlayHtmlInput.value !== (transcriptionData[overlayKey] || "")
        ) {
          els.overlayHtmlInput.value = transcriptionData[overlayKey] || "";
        }
        if (forcePreviewUpdate) {
          updateOverlayPreview();
        }
        // Ensure the correct content is shown if log is not active
        if (!state.isLogActive) {
          els.overlayHtmlInput.value = transcriptionData[overlayKey] || "";
        }
      }

      function saveContent() {
        if (!state.isAuthReady) return;
        if (state.isLogActive) return; // Do not save log content

        clearTimeout(state.saveTimeout);
        state.saveTimeout = setTimeout(() => {
          // Save Markdown data if it was somehow modified (e.g., via future feature)
          if (els.markdownInput) {
            transcriptionData[`md_page_${state.pageNum}`] =
              els.markdownInput.value;
          }

          transcriptionData[`overlay_page_${state.pageNum}`] =
            els.overlayHtmlInput.value;
          localStorage.setItem(STORAGE_KEY, JSON.stringify(transcriptionData));
          localStorage.setItem(STORAGE_KEY_LAST_PAGE, state.pageNum);

          // We assume prompt input changes are handled by its direct listener
        }, 1000);
      }

      function renderPage(num) {
        state.pageRendering = true;
        els.pdfLoader.classList.remove("hidden");
        saveContent();

        state.pdfDoc.getPage(num).then(function (page) {
          var viewport = page.getViewport({ scale: state.scale });
          state.canvas.height = viewport.height;
          state.canvas.width = viewport.width;

          var renderTask = page.render({
            canvasContext: state.ctx,
            viewport: viewport,
          });

          renderTask.promise.then(function () {
            state.pageRendering = false;
            els.pdfLoader.classList.add("hidden");
            updateOverlayWrapperSize();
            loadContentForCurrentPage(true);
            if (state.pageNumPending !== null) {
              renderPage(state.pageNumPending);
              state.pageNumPending = null;
            }
          });
        });

        els.pageNumSpan.textContent = num;
        els.prevBtn.disabled = num <= 1;
        els.nextBtn.disabled = num >= state.pdfDoc.numPages;
      }

      // --- DOM Modification Helpers (Non-AI) ---

      // 1. Unified Parser for DOM Updates (Robust)
      function updateDOMWithCallback(callback) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(
          `<body>${els.overlayHtmlInput.value}</body>`,
          "text/html",
        );

        if (callback(doc)) {
          // If modification happened
          els.overlayHtmlInput.value = doc.body.innerHTML;
          updateOverlayPreview();
          saveContent();
          return true;
        }
        return false;
      }

      // --- Public Event Handlers (Relies on functions defined above) ---

      window.updateStyle = function (property, value) {
        if (!state.targetDivId) return;

        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            
            if (property === 'font-weight') {
                // Precision: Toggle bold/normal based on current value
                const currentWeight = target.style.fontWeight || 'normal';
                if (currentWeight === 'bold' || currentWeight === '700') {
                    target.style.fontWeight = 'normal';
                } else {
                    target.style.fontWeight = 'bold';
                }
            } else {
                // For font-family, text-align, etc., just set the value
                target.style[property] = value;
            }
            
            return true;
          }
          return false;
        });
      };

      window.deleteDiv = function () {
        if (!state.targetDivId) return;
        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            // NEW: Clean up history entry for the deleted div
            const divHistoryKey = `history_div_${state.targetDivId}`;
            delete transcriptionData[divHistoryKey];

            target.remove();
            state.targetDivId = null;
            window.closeSelection(); // Hide the box and disable edit bar
            return true;
          }
          return false;
        });
      };

      window.clearStyles = function () {
        if (!state.targetDivId) return;
        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            // Keep positioning, clear typography
            const left = target.style.left;
            const top = target.style.top;
            const width = target.style.width;
            const height = target.style.height;

            target.removeAttribute("style");

            // Restore Layout
            target.style.position = "absolute";
            target.style.left = left;
            target.style.top = top;
            target.style.width = width;
            target.style.height = height;
            target.style.background = "rgba(255,255,255,0.7)"; // Consistent background color
            target.style.padding = "0px";
            target.style.margin = "0px";
            target.style.overflowWrap = "break-word";
            target.style.overflow = "hidden";
            target.style.lineHeight = "1.0";
            return true;
          }
          return false;
        });
      };

      window.snapLayout = function (type) {
        if (!state.targetDivId) return;

        if (type === "page-width") {
          window.updateStyle("left", "0%");
          window.updateStyle("width", "100%");
        } else if (type === "margin-standard") {
          // Simulate ~1 inch margins (approx 10%)
          window.updateStyle("left", "10%");
          window.updateStyle("width", "80%");
        } else if (type === "center") {
          window.updateStyle("left", "15%");
          window.updateStyle("width", "70%");
        }
      };

      window.toggleAiLog = function () {
        state.isLogActive = !state.isLogActive;

        if (state.isLogActive) {
          // Show Log
          els.overlayHtmlInput.value = renderAiLog();
          els.overlayHtmlInput.readOnly = true;
          els.editorTitle.textContent = "AI LOG";
          els.showAiLog.textContent = "[Show HTML]";
          els.editActionBar.classList.add("disabled-bar"); // Always disable bar when in log view
        } else {
          // Show HTML
          loadContentForCurrentPage(false); // Reload current page HTML content
          els.overlayHtmlInput.readOnly = false;
          els.editorTitle.textContent = "OVERLAY HTML";
          els.showAiLog.textContent = "[AI Log]";
          updateEditBarState(); // Re-evaluate bar state based on cursor
        }
      };
      
      /**
       * Core logic for AI Replica run. Separated for looping.
       */
      async function runReplicaCore() {
          const divId = state.targetDivId;
          if (!divId) throw new Error("No target DIV.");
          if (typeof html2canvas === "undefined") throw new Error("html2canvas not loaded.");

          const AI_IMAGE_SCALE = 2.0;
          const divEl = document.getElementById(divId);
          if (!divEl) throw new Error("DIV element missing.");
          
          // 1. Capture Source and Current Render
          const base64Source = getSnippetFromDiv(divId, AI_IMAGE_SCALE);

          const canvas = await html2canvas(divEl, {
              backgroundColor: "#ffffff",
              scale: AI_IMAGE_SCALE,
              logging: false,
              useCORS: true,
              allowTaint: true,
          });
          const base64Render = canvas.toDataURL("image/png").split(",")[1];

          // 2. Get State & History
          const internalState = getDivData(divEl);
          const promptDimensions = `
Bounding Box (Container Constraints, relative to page): W:${internalState.width}, H:${internalState.height}.
Internal Alignment Context: The origin (0,0) of the cropped image is the top-left corner of the Bounding Box. The task is to align content within these boundaries.
`;
          const divHistoryKey = `history_div_${divId}`;
          let history = JSON.parse(transcriptionData[divHistoryKey] || "[]");

          const imagesForAI = [base64Source, base64Render, ...history];
          const imageCount = imagesForAI.length;

          // 3. Prepare Prompt
          let prompt = state.prompts.REPLICA_STYLE;
          prompt = prompt.replace("{{imageCount}}", imageCount.toString());
          prompt = prompt.replace("{{promptDimensions}}", promptDimensions);
          prompt = prompt.replace("{{content}}", internalState.content);

          // 4. Query AI
          // NOTE: queryGemini handles the AI Processing message internally, but the caller handles the immediate start message.
          const resultHtml = await queryGemini(prompt, imagesForAI);

          // 5. Validation and History Update
          const cleanedHtml = resultHtml
              .replace(/```html/g, "")
              .replace(/```/g, "")
              .trim();

          // Check for empty or near-empty content (Humility)
          if (!cleanedHtml || cleanedHtml.length < 5) {
             throw new Error("AI returned empty or insufficient HTML content.");
          }


          // The current render becomes the newest history entry (it was the input)
          history.unshift(base64Render); 
          if (history.length > 4) {
              history = history.slice(0, 4);
          }
          transcriptionData[divHistoryKey] = JSON.stringify(history);

          // 6. Apply new content
          updateDivContent(divId, cleanedHtml);
      }

      // 1. Replica: VISUAL COMPARISON (Single run)
      window.runAiReplica = async function () {
          if (!state.targetDivId) {
              els.aiStatus.style.display = "inline";
              els.aiStatus.textContent = "Error: Select DIV first";
              setTimeout(() => els.aiStatus.style.display = "none", 3000);
              return;
          }
          
          // FIX: Show immediate processing status before starting core logic
          els.aiStatus.style.display = "inline";
          els.aiStatus.textContent = "AI Processing (1x)..."; 
          
          // Disable controls for single run
          els.editActionBar.classList.add("disabled-bar");
          
          try {
              await runReplicaCore();
              els.aiStatus.textContent = "Done!";
          } catch (e) {
              // FIX: Explicitly report error status to the user
              console.error("AI Replica run failed:", e);
              els.aiStatus.textContent = "Error! Check Log.";
          } finally {
              setTimeout(() => els.aiStatus.style.display = "none", 2000);
              // Re-enable controls, relying on updateEditBarState to check selection
              updateEditBarState();
              showDebugView(); // Always refresh to show the final result and updated history
          }
      };


      // 2. NEW: Looping function
      window.runAiReplicaLoop = async function(count) {
          if (!state.targetDivId) {
              els.aiStatus.style.display = "inline";
              els.aiStatus.textContent = "Error: Select DIV first";
              setTimeout(() => els.aiStatus.style.display = "none", 3000);
              return;
          }
          if (state.isLoopRunning) return;
          
          // 1. Setup Loop State
          state.isLoopRunning = true;
          els.aiStatus.style.display = "inline";
          els.editActionBar.classList.add("disabled-bar"); // Disable all controls
          els.btnTogglePlayback.disabled = true;
          els.playbackText.textContent = "Loop Running...";
          
          let successfulSteps = 0; // NEW: Track successful steps for precise error reporting

          try {
              for (let i = 1; i <= count; i++) {
                  els.aiStatus.textContent = `AI Processing Step ${i} of ${count}...`;
                  
                  // Run the core logic
                  await runReplicaCore(); 
                  
                  successfulSteps = i; // Increment successful steps count
                  
                  // Pause briefly to ensure DOM renders and user sees progress
                  await new Promise(resolve => setTimeout(resolve, 100)); 
              }
              els.aiStatus.textContent = "Loop Finished!";

          } catch (e) {
              // FIX: Report loop error visually. Use the successfully completed step count.
              console.error("AI Loop terminated early:", e);
              els.aiStatus.textContent = `Loop Error after Step ${successfulSteps}! Check Log.`;
          } finally {
              // 2. Cleanup Loop State
              state.isLoopRunning = false;
              setTimeout(() => els.aiStatus.style.display = "none", 2000);
              // Re-enable controls, relying on updateEditBarState to check selection
              updateEditBarState(); 
              showDebugView(); // Final refresh to show the result and playable history
          }
      }


      // 3. Match Font: Style Heuristics only (CSS on Container)
      window.runAiFont = async function () {
        const divId = state.targetDivId;
        if (!divId) {
            els.aiStatus.style.display = "inline";
            els.aiStatus.textContent = "Error: Select DIV first";
            setTimeout(() => els.aiStatus.style.display = "none", 3000);
            return;
        }
        if (state.isLoopRunning) return; // Prevent run during loop
        
        // FIX: Show immediate processing status before starting core logic
        els.aiStatus.style.display = "inline";
        els.aiStatus.textContent = "AI Processing (Font)...";
        
        els.editActionBar.classList.add("disabled-bar");

        const base64 = getSnippetFromDiv(divId);

        // Use the editable prompt
        const prompt = state.prompts.FONT_STYLE;

        try {
          const resultText = await queryGemini(prompt, base64);
          if (!resultText) {
            console.error("AI Font failed: received null/undefined result.");
            throw new Error("AI returned empty result for font style.");
          }

          const styles = parseAIJson(resultText);

          if (styles) {
            updateDOMWithCallback((doc) => {
              const target = doc.getElementById(divId);
              if (target) {
                if (styles.fontFamily)
                  target.style.fontFamily = styles.fontFamily;
                if (styles.fontWeight)
                  target.style.fontWeight = styles.fontWeight;
                if (styles.fontStyle) target.style.fontStyle = styles.fontStyle;
                if (styles.textAlign) target.style.textAlign = styles.textAlign;
                if (styles.fontSize) target.style.fontSize = styles.fontSize;
                return true;
              }
              return false;
            });
          }
          els.aiStatus.textContent = "Done!";
          setTimeout(() => els.aiStatus.style.display = "none", 2000);
          els.editActionBar.classList.remove("disabled-bar");
        } catch (e) {
          console.error("AI Font failed:", e);
          els.aiStatus.textContent = "Error! Check Log.";
          setTimeout(() => els.aiStatus.style.display = "none", 2000);
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // 4. Flow: Text Only (Clean Transcription)
      window.runAiText = async function () {
        const divId = state.targetDivId;
        if (!divId) {
            els.aiStatus.style.display = "inline";
            els.aiStatus.textContent = "Error: Select DIV first";
            setTimeout(() => els.aiStatus.style.display = "none", 3000);
            return;
        }
        if (state.isLoopRunning) return; // Prevent run during loop
        
        // FIX: Show immediate processing status before starting core logic
        els.aiStatus.style.display = "inline";
        els.aiStatus.textContent = "AI Processing (Text)...";
        
        els.editActionBar.classList.add("disabled-bar");

        const base64 = getSnippetFromDiv(divId);

        // Use the editable prompt
        const prompt = state.prompts.TEXT_ONLY;

        try {
          const resultHtml = await queryGemini(prompt, base64);

          const cleanedHtml = resultHtml
              .replace(/```html/g, "")
              .replace(/```/g, "")
              .trim();
              
          if (!cleanedHtml) {
            throw new Error("AI returned empty result for text transcription.");
          }

          updateDivContent(divId, cleanedHtml);
          els.aiStatus.textContent = "Done!";
          setTimeout(() => els.aiStatus.style.display = "none", 2000);
          els.editActionBar.classList.remove("disabled-bar");
        } catch (e) {
          console.error("AI Text failed:", e);
          els.aiStatus.textContent = "Error! Check Log.";
          setTimeout(() => els.aiStatus.style.display = "none", 2000);
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // Helpers
      window.closeSelection = function () {
        els.selectionBox.style.display = "none";
        els.selectionBox.classList.remove("edit-mode");
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";
        els.editActionBar.classList.add("disabled-bar"); // Disable edit bar
        state.targetDivId = null;
      };

      function insertDiv(content, styles = {}) {
        const rect = state.selectionRect;
        const l = rect.left.toFixed(2);
        const t = rect.top.toFixed(2);
        const w = rect.width.toFixed(2);
        const h = rect.height.toFixed(2);
        const id = `div-${Date.now()}`;

        // BUG FIX: Removed HTML entity escaping (e.g., < to &lt;) to prevent breaking KaTeX
        // and structural HTML returned by the AI. Only convert newlines to <br>.
        const cleanContent = content.replace(/\n/g, "<br>");

        // HEURISTIC UPDATE:
        // 1. Padding: 0px (User Request)
        // 2. Margin: 0px (User Request)
        // 3. Line-height: 1.0 (Strict print alignment)
        // 4. Font-size: 14px (Starting point)

        let styleStr = `position: absolute; left: ${l}%; top: ${t}%; width: ${w}%; height: ${h}%; background: rgba(255,255,255,0.7); padding: 0px; margin: 0px; overflow-wrap: break-word; overflow: hidden;`;
        
        appendHtml(`<div id="${id}" style="${styleStr}">${cleanContent}</div>`);

        // Trigger Smart Fit Heuristic after DOM update
      }

      function insertImage(dataUrl) {
        const l = state.selectionRect.left.toFixed(2);
        const t = state.selectionRect.top.toFixed(2);
        const w = state.selectionRect.width.toFixed(2);
        const h = state.selectionRect.height.toFixed(2);
        appendHtml(
          `<img src="${dataUrl}" style="position: absolute; left: ${l}%; top: ${t}%; width: ${w}%; height: ${h}%; object-fit: contain;" />`,
        );
      }

      function appendHtml(str) {
        const input = els.overlayHtmlInput;
        input.value = input.value + str;
        updateOverlayPreview();
        saveContent();
      }

      function updateDivContent(divId, newContent) {
        // FIX: Add robust check for null/undefined content immediately.
        if (!newContent) {
          console.error(
            `AI response returned empty content (undefined or null) for div ${divId}. Skipping update.`,
          );
          els.aiStatus.textContent = "AI Error (Empty Response)";
          setTimeout(() => (els.aiStatus.style.display = "none"), 2000);
          els.editActionBar.classList.remove("disabled-bar");
          return;
        }

        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(divId);
          if (target) {
            // Apply new inner HTML
            target.innerHTML = newContent;
            return true;
          }
          return false;
        });
        // Re-run fitting if content changed (may be needed if content structure changes height)
        els.editActionBar.classList.remove("disabled-bar");
      }

      
      /**
       * Shows the captured images and HTML in the Debug tab.
       */
      function showAiVisionDebug(
        sourceB64,
        renderB64,
        promptDimensions,
        htmlContent,
        history, // NEW
      ) {
        // Stop any active playback before rendering new data
        stopPlayback();
        
        // 1. Update content
        els.debugSourceImg.src = `data:image/png;base64,${sourceB64}`;
        els.debugRenderImg.src = `data:image/png;base64,${renderB64}`;
        // Store current render source for restoration after playback
        state.originalRenderSource = `data:image/png;base64,${renderB64}`;
        
        // FIX: Set the value of the debug HTML content textarea
        els.debugHtmlContent.value = htmlContent;

        // 2. Setup Playback Frames
        // Frames are ordered: [History 1, ..., History N, Current Render]
        const historyOldestFirst = [...history].reverse(); 
        const playbackFrames = [
            ...historyOldestFirst.map(b64 => b64), // History frames
            renderB64 // Current render (final frame)
        ];
        state.playbackFrames = playbackFrames;
        
        // 3. Render History Images (Thumbnails)
        els.historyImagesContainer.innerHTML = ""; // Clear previous
        
        if (historyOldestFirst.length > 0) {
            historyOldestFirst.forEach((b64, index) => {
                const imgContainer = document.createElement("div");
                imgContainer.className =
                    "inline-block relative h-full bg-gray-800 rounded-md shadow-md";
                imgContainer.style.width = "auto";
                imgContainer.style.aspectRatio = "1 / 1";
                imgContainer.title = `Attempt #${index + 1}`; 

                const img = document.createElement("img");
                img.src = `data:image/png;base64,${b64}`;
                img.className =
                    "h-full w-auto object-contain rounded-md border border-gray-700 transition-all";

                imgContainer.appendChild(img);
                els.historyImagesContainer.appendChild(imgContainer);
            });
            // FIX: Ensure play button text is set correctly when history exists
            els.playbackText.textContent = "Play History"; 
            // Enable playback if there is at least one history frame
            els.btnTogglePlayback.disabled = false;
        } else {
            // Disable playback if no history
            els.btnTogglePlayback.disabled = true;
        }


        // 4. Switch to the debug tab
        switchMainView("debug");
        console.log("Debug Images Context:", promptDimensions);
      }

      window.showDebugView = function () {
        // ... (function body remains the same, but relies on the updated showAiVisionDebug)
        if (!state.targetDivId) {
          console.warn("No active DIV selected for debug view.");
          return;
        }
        const divEl = document.getElementById(state.targetDivId);
        if (!divEl) return;

        // Use the logic from runAiReplica to get the images and dimensions
        const AI_IMAGE_SCALE = 2.0;
        const base64Source = getSnippetFromDiv(
          state.targetDivId,
          AI_IMAGE_SCALE,
        );

        html2canvas(divEl, {
          backgroundColor: "#ffffff",
          scale: AI_IMAGE_SCALE,
          logging: false,
          useCORS: true,
          allowTaint: true,
        })
          .then((canvas) => {
            const base64Render = canvas.toDataURL("image/png").split(",")[1];

            const scaledPixelWidth = divEl.clientWidth;
            const scaledPixelHeight = divEl.clientHeight;
            const currentScale =
              state.pdfDoc && state.pdfDoc.isStaticImage ? 1.0 : state.scale;
            const nativePixelWidth = Math.round(
              scaledPixelWidth / currentScale,
            );
            const nativePixelHeight = Math.round(
              scaledPixelHeight / currentScale,
            );

            const dimensions = {
              scaled: `W:${scaledPixelWidth}px, H:${scaledPixelHeight}px (Scale: ${currentScale})`,
              native: `W:${nativePixelWidth}px, H:${nativePixelHeight}px (Original)`,
            };

            // 1. Get current state to send to AI
            const internalState = getDivData(divEl);
            const promptDimensions = `
Bounding Box (Container Constraints, relative to page): W:${internalState.width}, H:${internalState.height}.
Internal Alignment Context: The origin (0,0) of the cropped image is the top-left corner of the Bounding Box. The task is to align content within these boundaries.
`;
            // Load history from persistence for the current div
            const divHistoryKey = `history_div_${state.targetDivId}`;
            const history = JSON.parse(
              transcriptionData[divHistoryKey] || "[]",
            );

            showAiVisionDebug(
              base64Source,
              base64Render,
              promptDimensions,
              internalState.content,
              history, // Pass history
            );
          })
          .catch((e) => {
            console.error("Debug capture failed", e);
          });
      };

      // --- Core Application Logic ---
      els.upload.addEventListener("change", function (e) {
        var file = e.target.files[0];
        if (file.type !== "application/pdf") return;
        state.pageNum = 1;
        localStorage.setItem(STORAGE_KEY_FILENAME, file.name);
        els.restoredFilename.textContent = file.name;
        els.restoreBadge.classList.add("hidden");
        savePDFToDB(file).catch((err) =>
          console.error("Error saving PDF to DB:", err),
        );
        var fileReader = new FileReader();
        fileReader.onload = function () {
          var typedarray = new Uint8Array(this.result);
          loadPDF(typedarray, 1);
        };
        fileReader.readAsArrayBuffer(file);
      });

      // window.updatePreview is now unused

      function updateOverlayPreview() {
        els.overlayHtmlLayer.innerHTML = els.overlayHtmlInput.value;
        renderMathInElement(els.overlayHtmlLayer, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false },
          ],
          throwOnError: false,
        });
      }

      function switchMainView(viewId) {
        saveContent();
        state.activeTab = viewId;
        
        // Ensure playback is stopped when switching tabs
        stopPlayback();

        const containers = {
          source: els.sourceContainer, // Kept hidden/background container
          overlay: els.overlayContainer,
          write: els.editorContainerMd, // Kept hidden/background container
          preview: els.previewContainer, // Kept hidden/background container
          prompts: els.editorContainerPrompts,
          debug: els.editorContainerDebug, // New debug container
        };
        const buttons = {
          overlay: els.tabOverlay,
          prompts: els.tabPrompts,
          debug: els.tabDebug, // New debug button
        };

        // Always revert from log view when switching tabs
        if (state.isLogActive) {
          state.isLogActive = false;
        }

        // Handle content initialization based on viewId
        if (viewId === "overlay") {
          // The canvas is mounted to overlayCanvasMount in the Overlay tab
          if (!els.overlayCanvasMount.contains(els.theCanvas))
            els.overlayCanvasMount.appendChild(els.theCanvas);
          updateOverlayPreview();
        } else if (viewId === "prompts") {
          // Ensure the editor reflects the current in-memory state when loading the tab
          els.promptInput.value = formatPromptsForEditor(state.prompts);
        }
        // Note: The Debug tab content is set inside runAiReplica or showDebugView

        // FIX: Add null check for containers and buttons before accessing classList
        Object.values(containers).forEach((c) => {
          if (c) c.classList.add("hidden");
        });
        Object.values(buttons).forEach((b) => {
          if (b) b.classList.remove("active");
        });

        if (containers[viewId]) containers[viewId].classList.remove("hidden");
        if (buttons[viewId]) buttons[viewId].classList.add("active");
      }

      els.overlayHtmlInput.addEventListener("input", () => {
        if (!state.isLogActive) {
          updateOverlayPreview();
          saveContent();
        }
      });
      
      // 2. Editor Interaction (Listeners)
      els.overlayHtmlInput.addEventListener("input", updateEditBarState);
      els.overlayHtmlInput.addEventListener("click", updateEditBarState);
      els.overlayHtmlInput.addEventListener("keyup", updateEditBarState); 

      // Listener for the prompt input: saves and parses the text immediately upon input change
      els.promptInput.addEventListener("input", savePrompts);
      // Also save/parse on blur/change for reliable update if a paste occurs
      els.promptInput.addEventListener("blur", savePrompts);
      
      // 3. Mouse Interaction (Canvas)
      function getPointerPos(e) {
        const rect = els.selectionLayer.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      els.selectionLayer.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;

        // Hide non-editing bars
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";
        els.editActionBar.classList.add("disabled-bar"); // Disable edit bar during potential selection

        state.isSelecting = true;
        state.selectionStart = getPointerPos(e);
        els.selectionBox.style.display = "block";
        els.selectionBox.style.width = "0px";
        els.selectionBox.style.height = "0px";
        els.selectionBox.classList.remove("edit-mode"); // Always start as new selection mode
      });

      els.selectionLayer.addEventListener("mousemove", (e) => {
        if (!state.isSelecting) return;
        const currentPos = getPointerPos(e);
        const x = Math.min(state.selectionStart.x, currentPos.x);
        const y = Math.min(state.selectionStart.y, currentPos.y);
        const width = Math.abs(currentPos.x - state.selectionStart.x);
        const height = Math.abs(currentPos.y - state.selectionStart.y);

        els.selectionBox.style.left = x + "px";
        els.selectionBox.style.top = y + "px";
        els.selectionBox.style.width = width + "px";
        els.selectionBox.style.height = height + "px";
      });

      function activateDivEditMode(divElement, clickEvent = null) {
        if (!divElement) return;
        state.targetDivId = divElement.id;

        // Hide non-editing bars
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";

        // Enable the Edit Action Bar (which is always visible)
        els.editActionBar.classList.remove("disabled-bar");

        // Calculate Position
        const cw = els.theCanvas.width;
        const ch = els.theCanvas.height;
        const l = (parseFloat(divElement.style.left) / 100) * cw;
        const t = (parseFloat(divElement.style.top) / 100) * ch;
        const w = (parseFloat(divElement.style.width) / 100) * cw;
        const h = (parseFloat(divElement.style.height) / 100) * ch;

        // Draw Box
        els.selectionBox.style.left = l + "px";
        els.selectionBox.style.top = t + "px";
        els.selectionBox.style.width = w + "px";
        els.selectionBox.style.height = h + "px";
        els.selectionBox.style.display = "block";
        els.selectionBox.classList.add("edit-mode");
      }

      els.selectionLayer.addEventListener("mouseup", (e) => {
        if (!state.isSelecting) return;
        state.isSelecting = false;

        const currentPos = getPointerPos(e);
        const width = Math.abs(currentPos.x - state.selectionStart.x);
        const height = Math.abs(currentPos.y - state.selectionStart.y);

        // 1. CHECK FOR CLICK ON EXISTING DIV (UNIFIED LEFT-CLICK ACTIVATION)
        const elements = document.elementsFromPoint(e.clientX, e.clientY);
        const clickedDiv = elements.find(
          (el) =>
            el.parentElement &&
            el.parentElement.id === "overlay-html-layer" &&
            el.id &&
            el.id.startsWith("div-"),
        );

        if (clickedDiv) {
          // Clicked on an existing div. Activate edit mode for it.
          activateDivEditMode(clickedDiv, e);
          els.actionBar.style.display = "none"; // Ensure new selection bar is hidden
          
          // FIX: Force focus on the editor to ensure state.targetDivId is picked up 
          // by the editor's event listeners, making the AI buttons functional.
          els.overlayHtmlInput.focus();
          
          return;
        }

        // 2. CHECK FOR INVALID DRAG (Too small)
        if (width < 10 || height < 10) {
          // If it was a small movement (a failed click or small drag) and no DIV was hit, hide box and stop.
          els.selectionBox.style.display = "none";
          els.editActionBar.classList.add("disabled-bar"); // Ensure edit bar is disabled if no div was selected
          return;
        }

        // 3. NEW SELECTION LOGIC (Drag occurred)

        const canvasW = els.theCanvas.width;
        const canvasH = els.theCanvas.height;
        const x = Math.min(state.selectionStart.x, currentPos.x);
        const y = Math.min(state.selectionStart.y, currentPos.y);

        state.selectionRect = {
          left: (x / canvasW) * 100,
          top: (y / canvasH) * 100,
          width: (width / canvasW) * 100,
          height: (height / canvasH) * 100,
          pixelX: x,
          pixelY: y,
          pixelW: width,
          pixelH: height,
        };

        // --- Show Action Bar for NEW selection ---
        // Calculate absolute position on screen
        const rect = els.selectionLayer.getBoundingClientRect();
        const absX = rect.left + x;
        const absY = rect.top + y + height;

        const barWidth = 180;
        let barLeft = absX + width / 2 - barWidth / 2;
        let barTop = absY + 10;

        // Boundary checks
        if (barLeft < 10) barLeft = 10;
        if (barLeft + barWidth > window.innerWidth)
          barLeft = window.innerWidth - barWidth - 10;
        if (barTop + 50 > window.innerHeight) {
          barTop = rect.top + y - 60;
        }

        els.actionBar.style.left = barLeft + "px";
        els.actionBar.style.top = barTop + "px";
        els.actionBar.style.display = "flex";
      });
      
      document.addEventListener("click", (e) => {
        // If we click outside the whole editor pane (including the action bar)
        if (e.target.closest("#overlay-container") === null) {
          window.closeSelection();
        }
      });


      els.tabOverlay.addEventListener("click", () => switchMainView("overlay"));
      els.tabPrompts.addEventListener("click", () => switchMainView("prompts"));
      els.tabDebug.addEventListener("click", () => { 
        if(state.targetDivId) {
            showDebugView();
        } else {
            switchMainView("debug");
        }
      });

      els.prevBtn.addEventListener("click", () => {
        if (state.pdfDoc && !state.pdfDoc.isStaticImage && state.pageNum > 1) {
          state.pageNum--;
          queueRenderPage(state.pageNum);
        }
      });
      els.nextBtn.addEventListener("click", () => {
        if (
          state.pdfDoc &&
          !state.pdfDoc.isStaticImage &&
          state.pageNum < state.pdfDoc.numPages
        ) {
          state.pageNum++;
          queueRenderPage(state.pageNum);
        }
      });
      els.zoomInBtn.addEventListener("click", () => {
        if (state.pdfDoc && state.pdfDoc.isStaticImage) return; // Ignore if static image
        state.scale += 0.2;
        els.zoomLevelSpan.innerText = Math.round(state.scale * 100) + "%";
        queueRenderPage(state.pageNum);
      });
      els.zoomOutBtn.addEventListener("click", () => {
        if (state.pdfDoc && state.pdfDoc.isStaticImage) return; // Ignore if static image
        if (state.scale > 0.4) {
          state.scale -= 0.2;
          els.zoomLevelSpan.innerText = Math.round(state.scale * 100) + "%";
          queueRenderPage(state.pageNum);
        }
      });
      els.fullscreenBtn.addEventListener("click", () => {
        document.fullscreenElement
          ? document.exitFullscreen()
          : document.documentElement.requestFullscreen();
      });

      initPersistence();
      switchMainView("overlay");
    </script>
  </body>
</html>
