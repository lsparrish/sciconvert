<!doctype html>
<script type="module">
  // --- Core Utility: Deselect Cleanup ---
  // We define the override function here, ready to be called immediately after app.js loads.
  const setupDeselect = () => {
    // We must ensure the core app.js is loaded before attempting to access its functions.
    if (!window.app || !window.app.deselect) {
        console.error("Window.app or deselect function not available for override.");
        return;
    }
    const originalDeselect = window.app.deselect;
    
    //  the core deselect function (Humility & Perfectionism).
    // This is the definitive fix for all sticking selection rectangles.
    window.app.deselect = function() {
      // 1. Run original core logic (clears state, triggers re-render, hides selection-box via app.js internal els).
      originalDeselect();
      
      // 2. Manual DOM Cleanup (The definitive solution to the sticking rectangle bug):
      // The `#interaction-layer` holds all visual selection artifacts (frame, handles, split overlays).
      // Clearing its content ensures all persistent UI artifacts (selection-frame, etc.) are removed,
      // resolving the user's complaint that the rectangle persists after deselecting.
      const interactionLayerEl = document.getElementById('interaction-layer');
      if (interactionLayerEl) {
          // This aggressive cleanup is necessary because renderRegions in src/app.js doesn't 
          // always clear this layer when it should.
          interactionLayerEl.innerHTML = ''; 
      }
      
      // Safety check for the temporary drag selection box, even though core logic should handle it.
      const selectionBoxEl = document.getElementById('selection-box');
      if (selectionBoxEl) {
          selectionBoxEl.style.display = 'none';
          selectionBoxEl.classList.remove('edit-mode'); // Also clear any lingering mode classes
      }
      
      // 3. Update Context UI (Ensures the action bar is correctly disabled).
      const contextActionsEl = document.getElementById('context-actions');
      if (contextActionsEl) {
          contextActionsEl.classList.add('disabled-bar');
      }
      
      // 4. Also hide the new-selection-action-bar (The floating bar when a new region is drawn)
      const newSelectionBarEl = document.getElementById('new-selection-action-bar');
      if (newSelectionBarEl) {
          newSelectionBarEl.classList.add('hidden');
      }
    };
  };

  // ------------------------------------------------------------------------------------------
  
  await import('./src/app.js')
    .catch(() => import('https://lsparrish.github.io/sciconvert/src/app.js'));

  // Execute the override immediately after app.js loads, ensuring our custom deselect is active.
  setupDeselect(); 

  // --- REGION NAVIGATION & SELECTION UTILITIES ---
  window.app.insertElementBefore(
    `<div class="header-group" style="gap:0.25rem;">
      <button id="btn-deselect" class="btn btn-secondary" style="font-size:0.75rem; border:1px solid #4b5563; color:#9ca3af; padding:0.5rem 0.75rem;" title="Deselect All Regions (Simplicity)">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width:1rem; height:1rem;">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.042 21.737L13.19 18.06A2.25 2.25 0 0115.11 15h4.156M9 15l-4.04-4.04M9 15h4.156a2.25 2.25 0 011.92 3.518L13.19 21.737M3.31 9.31L7.545 12 3.31 15.31A2.25 2.25 0 013 13.5V11.16a2.25 2.25 0 01.31-1.85z" />
        </svg>
        Deselect
      </button>
      <button id="btn-cycle-prev" class="zoom-button" title="Previous Region ([ or Left Arrow)" style="color:#60a5fa; padding:0.5rem; margin-left:0.5rem;">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width:1.25rem; height:1.25rem;">
            <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
          </svg>
      </button>
      <button id="btn-cycle-next" class="zoom-button" title="Next Region (] or Right Arrow)" style="color:#60a5fa; padding:0.5rem;">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width:1.25rem; height:1.25rem;">
            <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
          </svg>
      </button>
    </div>`,
    '.header-divider',
    el => {
      // Event handler for Deselect button now uses the patched function
      el.querySelector('#btn-deselect').onclick = () => {
        window.app.deselect();
      };
      // The cycle buttons logic is handled in the main observeState block below for unified state management.
    }
  );

  // Draft actions (Original injection, fixed for consistency by adding 'hidden')
  window.app.insertElementBefore(
    `<div id="draft-actions" class="header-group hidden" style="gap:0.5rem;background-color:rgba(255,255,255,0.9);padding:0.5rem;border-radius:0.5rem;box-shadow:0 2px 4px rgba(0,0,0,0.1);">
      <button data-type="text" class="action-bar-btn" style="background-color:#2563eb;">AI Text</button>
      <button data-type="image" class="action-bar-btn" style="background-color:#d97706;">Image</button>
      <button data-type="empty" class="action-bar-btn" style="background-color:#4b5563;">Empty</button>
      <div style="width:1px;height:1.5rem;background-color:#d1d5db;"></div>
      <button id="cancel-draft" class="action-bar-btn" style="color:#ef4444;background:transparent;font-weight:500;border:1px solid #d1d5db;">Cancel</button>
    </div>`,
    '#context-actions',
    el => {
      // Consolidated click handling into a single, robust delegated listener (Simplicity, Precision)
      el.onclick = e => {
        const button = e.target.closest('button');

        if (!button) return;

        if (button.id === 'cancel-draft') {
          const id = window.app.state?.activeRegionId;
          if (id) {
            const regions = window.app.state.regions;
            const idx = regions.findIndex(r => r.id === id);
            // Only remove if it's a 'draft' region
            if (idx !== -1 && regions[idx].status === 'draft') regions.splice(idx, 1);
            window.app.deselect(); // Calls the patched deselect
            window.app.saveState();
          }
        } else {
          // Handles buttons with data-type (AI Text, Image, Empty)
          const type = button.dataset.type;
          if (type && window.app.state?.activeRegionId) {
            window.app.createRegion(type, window.app.state.activeRegionId);
          }
        }
      };
    }
  );

  // State Observer for Draft Actions Visibility (Fixes the inconsistency)
  // This ensures the draft bar only shows when a draft region is actively selected.
  window.app.observeState(() => {
    const draftActionsEl = document.getElementById('draft-actions');
    const contextActionsEl = document.getElementById('context-actions'); // Target the main bar
    const activeId = window.app.state?.activeRegionId;
    const activeRegion = activeId ? window.app.getRegion(activeId) : null;

    // Fix: Also explicitly hide the floating selection bar if a region is active
    // This is redundant with the deselect override, but good to have in observeState too.
    const newSelectionBarEl = document.getElementById('new-selection-action-bar');
    if (newSelectionBarEl) {
      // If ANY region is active or selected, the floating bar should be hidden.
      const isAnyRegionActive = !!activeId || window.app.state.selectedIds.size > 0;
      if (isAnyRegionActive) {
          newSelectionBarEl.classList.add('hidden');
      }
    }

    if (draftActionsEl) {
      // Check if the currently active region is a draft
      const isDraftActive = activeRegion && activeRegion.status === 'draft';
      
      // Toggle the 'hidden' class based on the state
      draftActionsEl.classList.toggle('hidden', !isDraftActive);

      if (contextActionsEl) {
          // The main bar (#context-actions) is visible only for generated/existing regions.
          // It should be disabled if a draft region is currently selected or if nothing is selected.
          const isSelected = !!window.app.state?.activeRegionId;
          const isMainBarDisabled = !isSelected || isDraftActive;
          contextActionsEl.classList.toggle('disabled-bar', isMainBarDisabled);
      }
    }
  });

  // Region Cycling Logic (Fixed for consistency and order - addressing the "hard to cycle" issue)
  window.app.observeState(() => {
    const state = window.app.state;
    const regions = state?.regions || [];
    const btnPrev = document.getElementById('btn-cycle-prev');
    const btnNext = document.getElementById('btn-cycle-next');
    
    // Core Fix: Sort regions by visual position (Y then X)
    const sortedRegions = [...regions].sort((a, b) => {
        // Sort by Y-position first (normalized coordinate)
        if (a.rect.y !== b.rect.y) {
            return a.rect.y - b.rect.y;
        }
        // Then by X-position (normalized coordinate) for same-line items
        return a.rect.x - b.rect.x;
    });

    let regionIds = sortedRegions.map(r => r.id);
    
    // Disable buttons if less than 2 regions exist
    if (btnPrev && btnNext) {
        const isDisabled = regions.length < 2;
        btnPrev.disabled = isDisabled;
        btnNext.disabled = isDisabled;
    }

    // Function to calculate and select the next/previous region
    const cycleRegion = (direction) => {
        if (regions.length === 0) return;
        
        let currentIndex = regionIds.findIndex(id => id === state.activeRegionId);
        let nextIndex = -1;

        if (currentIndex === -1) {
            // If nothing is selected, start at the first region (index 0)
            nextIndex = 0;
        } else if (direction === 'next') {
            // Cycle forward with wrap-around
            nextIndex = (currentIndex + 1) % regions.length;
        } else if (direction === 'prev') {
            // Cycle backward with wrap-around
            nextIndex = (currentIndex - 1 + regions.length) % regions.length;
        }

        if (nextIndex !== -1 && regionIds[nextIndex] !== state.activeRegionId) {
            window.app.selectRegion(regionIds[nextIndex]);
        }
    };

    // --- Attach Listeners only once ---
    if (!window.app.cyclingListenerAdded) {
      // Keyboard listeners
      window.addEventListener('keydown', e => {
        // Guard against input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
            return;
        }

        const isRight = e.key === 'ArrowRight' || e.key === ']';
        const isLeft = e.key === 'ArrowLeft' || e.key === '[';

        if (isRight || isLeft) {
          e.preventDefault(); 
          cycleRegion(isRight ? 'next' : 'prev');
        }
      });

      // Button listeners
      if (btnPrev && btnNext) {
        btnPrev.onclick = () => cycleRegion('prev');
        btnNext.onclick = () => cycleRegion('next');
      }
      
      window.app.cyclingListenerAdded = true; // Flag to ensure listener is added only once
    }
  });

</script>
