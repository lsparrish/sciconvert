<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SciText Digitizer (SVG)</title>

    <!-- External Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #111827;
        height: 100vh;
        overflow: hidden;
      }
      ::-webkit-scrollbar { width: 10px; height: 10px; }
      ::-webkit-scrollbar-track { background: #1f2937; }
      ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 5px; border: 2px solid #1f2937; }
      ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

      #canvas-wrapper {
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        transition: width 0.15s ease-out;
      }
      
      .grid-overlay {
          background-size: 50px 50px;
          background-image:
            linear-gradient(to right, rgba(0, 0, 0, 0.05) 1px, transparent 1px),
            linear-gradient(to bottom, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
          pointer-events: none;
      }

      .region-highlight {
          stroke: #f97316; stroke-width: 2; fill: rgba(249, 115, 22, 0.05);
          opacity: 0; transition: opacity 0.15s; pointer-events: all;
      }
      .region-highlight:hover { opacity: 1.0; cursor: pointer; }

      .region-selected {
          stroke: #3b82f6; stroke-width: 2; fill: rgba(59, 130, 246, 0.2);
          pointer-events: all; cursor: move;
      }
      
      .region-draft {
          fill: rgba(59, 130, 246, 0.1); stroke: #3b82f6; stroke-width: 2;
          stroke-dasharray: 8, 4; animation: dash 30s linear infinite;
          pointer-events: none;
      }
      
      .split-overlay {
          stroke: #6366f1; stroke-width: 1; fill: rgba(99, 102, 241, 0.1); stroke-dasharray: 4, 2;
          pointer-events: all; cursor: pointer;
      }
      .split-overlay:hover { stroke-width: 2; fill: rgba(99, 102, 241, 0.3); }
      .split-overlay.selected { stroke: #ef4444; stroke-width: 2; fill: rgba(239, 68, 68, 0.4); }
      
      @keyframes dash { to { stroke-dashoffset: -1000; } }

      #selection-box {
        border: 2px dashed #3b82f6; background-color: rgba(59, 130, 246, 0.1);
        position: absolute; pointer-events: none; display: none; z-index: 50;
      }

      .selection-frame {
          position: absolute; border: 1px solid #3b82f6;
          box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.3);
          background-color: rgba(59, 130, 246, 0.05);
          cursor: move; z-index: 40; box-sizing: border-box;
      }

      .resize-handle {
          position: absolute; width: 10px; height: 10px;
          background-color: white; border: 2px solid #3b82f6;
          z-index: 50; border-radius: 2px; transition: transform 0.1s;
      }
      .resize-handle:hover { transform: scale(1.2); background-color: #eff6ff; }
      
      .handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
      .handle-n  { top: -6px; left: 50%; margin-left: -5px; cursor: n-resize; }
      .handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
      .handle-e  { top: 50%; right: -6px; margin-top: -5px; cursor: e-resize; }
      .handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
      .handle-s  { bottom: -6px; left: 50%; margin-left: -5px; cursor: s-resize; }
      .handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }
      .handle-w  { top: 50%; left: -6px; margin-top: -5px; cursor: w-resize; }

      #new-selection-action-bar {
        position: fixed; z-index: 100; display: none; animation: fadeIn 0.1s ease-out;
      }
      @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

      .disabled-bar { opacity: 0.5; pointer-events: none; }
      .disabled-input { opacity: 0.5; pointer-events: none; background-color: #f9fafb; color: #9ca3af; }
      .tab-button { @apply px-4 py-2 text-sm font-semibold text-gray-500 border-b-2 border-transparent hover:text-gray-800 cursor-pointer transition; }
      .tab-button.active { @apply text-blue-600 border-blue-600 bg-white; }
      .editor-textarea { font-family: monospace; line-height: 1.5; resize: none; font-size: 11px; }
      .editor-textarea:focus { outline: none; background-color: #fff; box-shadow: inset 0 0 0 2px #bfdbfe; }
      input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
    </style>
  </head>
  <body class="flex flex-col h-screen text-gray-800">
    
    <!-- HEADER -->
    <header class="bg-gray-800 text-white p-3 flex justify-between items-center shadow-lg z-30 shrink-0 border-b border-gray-900">
      <div class="flex items-center gap-4">
        <h1 class="text-xl font-bold tracking-wider mr-4 text-gray-100">SciText <span class="text-blue-400">Digitizer</span></h1>
        
        <div class="relative group">
          <input type="file" id="pdf-upload" accept="application/pdf, image/*" class="hidden" />
          <label for="pdf-upload" class="cursor-pointer bg-blue-600 hover:bg-blue-500 px-4 py-1.5 rounded text-sm font-semibold transition flex items-center gap-2 shadow-sm ring-1 ring-blue-400/20">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" /></svg>
            Load
          </label>
        </div>
        
        <div class="h-6 w-px bg-gray-600 mx-2"></div>

        <div id="pdf-zoom-controls" class="flex items-center bg-gray-700 rounded-md p-0.5 shadow-inner border border-gray-600">
          <button id="zoom-out" class="hover:bg-gray-600 hover:text-white text-gray-300 p-1 px-2 rounded-sm font-bold transition">-</button>
          <span id="zoom-level" class="text-xs font-mono w-14 text-center text-gray-200 select-none">100%</span>
          <button id="zoom-in" class="hover:bg-gray-600 hover:text-white text-gray-300 p-1 px-2 rounded-sm font-bold transition">+</button>
        </div>

        <div class="flex items-center gap-1 ml-2">
            <button id="btn-undo" class="text-gray-400 hover:text-white p-1 rounded disabled:opacity-30 transition" title="Undo"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" /></svg></button>
            <button id="btn-redo" class="text-gray-400 hover:text-white p-1 rounded disabled:opacity-30 transition" title="Redo"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l6-6m0 0l-6-6m6 6H9a6 6 0 000 12h3" /></svg></button>
        </div>
      </div>
      
      <div class="flex items-center gap-4">
          <span id="ai-status" class="hidden text-blue-400 text-xs font-mono animate-pulse flex items-center gap-2">Processing...</span>
          <button id="fullscreen-toggle" class="bg-gray-700 hover:bg-gray-600 text-gray-200 px-3 py-1.5 rounded text-xs font-semibold transition border border-gray-600">Full Screen</button>
      </div>
    </header>

    <main class="flex-1 flex flex-col overflow-hidden relative bg-white">
      <div class="flex bg-gray-50 border-b border-gray-200 shadow-sm shrink-0 z-20">
        <button id="tab-overlay" class="tab-button active">Compositor</button>
        <button id="tab-debug" class="tab-button">Debug View</button>
      </div>

      <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-50 z-50 text-gray-500">
        <div class="bg-white p-8 rounded-2xl shadow-xl text-center border border-gray-200">
            <h2 class="text-xl font-bold mb-2 text-gray-700">No Document Loaded</h2>
            <p class="text-sm text-gray-500">Upload a PDF or Image to begin.</p>
        </div>
      </div>
      
      <div id="pdf-loader" class="absolute inset-0 bg-gray-900 bg-opacity-70 flex flex-col items-center justify-center hidden z-50 backdrop-blur-sm">
          <div class="w-12 h-12 border-4 border-t-blue-500 border-gray-600 rounded-full animate-spin mb-4"></div>
          <span class="text-white font-bold tracking-wide text-lg">Loading...</span>
      </div>

      <div id="workspace-container" class="flex-1 flex overflow-hidden relative hidden">
          <div class="w-80 min-w-[320px] h-full flex flex-col border-r border-gray-200 bg-white z-10 shadow-xl">
              <div class="bg-gray-100 px-4 py-3 text-xs font-bold text-gray-600 border-b border-gray-200 flex flex-col gap-2">
                  <div class="flex justify-between items-center">
                      <span class="tracking-wide uppercase">Properties</span>
                      <div class="flex items-center gap-2">
                          <div class="flex bg-gray-200 rounded p-0.5 border border-gray-300">
                              <button id="mode-area" class="px-2 py-0.5 rounded text-[10px] font-bold transition bg-white shadow-sm text-blue-600">Area</button>
                              <button id="mode-content" class="px-2 py-0.5 rounded text-[10px] font-bold transition text-gray-500 hover:text-gray-700">Content</button>
                          </div>
                          <span id="region-count" class="bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full text-[10px] font-bold">0</span>
                      </div>
                  </div>
                  <div class="flex justify-between items-center border-t border-gray-200 pt-2 mt-1">
                      <span class="text-[10px] text-gray-400 font-normal">Actions:</span>
                      <div class="flex gap-2">
                           <button id="btn-fit-area" class="text-gray-600 hover:text-blue-600 flex items-center gap-1 bg-white border border-gray-300 px-2 py-0.5 rounded shadow-sm">Fit Area</button>
                           <button id="btn-fit-content" class="text-gray-600 hover:text-blue-600 flex items-center gap-1 bg-white border border-gray-300 px-2 py-0.5 rounded shadow-sm">Fill Content</button>
                      </div>
                  </div>
              </div>

              <div class="p-4 bg-gray-50 border-b border-gray-200 grid grid-cols-2 gap-3 text-xs select-none relative">
                  <div id="mode-label" class="absolute top-1 right-2 text-[9px] font-bold text-blue-400 uppercase tracking-widest pointer-events-none">Area Mode</div>
                  <div class="col-span-2 grid grid-cols-2 gap-3">
                      <div><label id="lbl-x" class="block text-gray-400 font-bold mb-1 uppercase text-[10px]">Pos X</label><input type="number" id="prop-x" class="w-full bg-white border border-gray-300 rounded p-1.5 focus:border-blue-500 focus:ring-1 outline-none font-mono text-gray-700" disabled></div>
                      <div><label id="lbl-y" class="block text-gray-400 font-bold mb-1 uppercase text-[10px]">Pos Y</label><input type="number" id="prop-y" class="w-full bg-white border border-gray-300 rounded p-1.5 focus:border-blue-500 focus:ring-1 outline-none font-mono text-gray-700" disabled></div>
                  </div>
                  <div class="col-span-2 grid grid-cols-2 gap-3">
                      <div><label id="lbl-w" class="block text-gray-400 font-bold mb-1 uppercase text-[10px]">Width</label><input type="number" id="prop-w" class="w-full bg-white border border-gray-300 rounded p-1.5 focus:border-blue-500 focus:ring-1 outline-none font-mono text-gray-700" disabled></div>
                      <div><label id="lbl-h" class="block text-gray-400 font-bold mb-1 uppercase text-[10px]">Height</label><input type="number" id="prop-h" class="w-full bg-white border border-gray-300 rounded p-1.5 focus:border-blue-500 focus:ring-1 outline-none font-mono text-gray-700" disabled></div>
                  </div>
              </div>
              
              <div class="px-4 py-2 text-xs font-bold text-gray-500 border-b bg-gray-100 flex justify-between items-center shadow-inner">
                  <span class="tracking-wide uppercase">Region Layers</span>
                  <button id="btn-add-layer" class="text-[10px] text-blue-600 hover:text-blue-800 font-bold px-2 py-0.5 bg-blue-50 rounded border border-blue-200 hover:bg-blue-100 transition">+ Add</button>
              </div>
              <!-- Replaced Textarea with List Container -->
              <div id="layer-list" class="flex-1 overflow-y-auto p-2 space-y-2 bg-gray-100 border-t border-gray-200">
                  <div class="text-center text-gray-400 text-[10px] mt-4">Select a region to view layers</div>
              </div>
              
              <div class="p-3 border-t border-gray-200 bg-gray-50 flex flex-wrap gap-2 items-center justify-between">
                  <div id="debug-actions-left" class="flex gap-2">
                    <button id="btn-export" class="bg-white text-green-700 border border-green-300 hover:bg-green-50 px-3 py-1.5 rounded text-xs font-bold shadow-sm transition">Compose SVG</button>
                    <button id="btn-clear-all" class="text-red-500 hover:text-red-700 px-2 py-1.5 rounded text-xs font-medium transition">Reset</button>
                  </div>
                  <div id="context-actions" class="flex gap-2 transition-opacity duration-200">
                       <button id="btn-digitize" class="bg-purple-600 text-white border border-transparent hover:bg-purple-500 px-3 py-1.5 rounded text-xs font-bold shadow-sm transition">AI Text</button>
                       <button id="btn-split" class="bg-indigo-50 text-indigo-700 border border-indigo-200 hover:bg-indigo-100 px-3 py-1.5 rounded text-xs font-bold shadow-sm transition">Split</button>
                       <button id="btn-group" class="bg-teal-600 text-white border border-transparent hover:bg-teal-500 px-3 py-1.5 rounded text-xs font-bold shadow-sm transition">Group</button>
                       <button id="btn-optimize" class="bg-indigo-50 text-indigo-700 border border-indigo-200 hover:bg-indigo-100 px-3 py-1.5 rounded text-xs font-bold shadow-sm transition">Opt</button>
                       <button id="btn-regen" class="bg-blue-600 text-white border border-transparent hover:bg-blue-500 px-3 py-1.5 rounded text-xs font-bold shadow-sm transition">Regen</button>
                       <button id="btn-delete" class="bg-white text-gray-700 border border-gray-300 hover:bg-gray-100 px-3 py-1.5 rounded text-xs font-semibold shadow-sm transition">Del</button>
                  </div>
              </div>
          </div>

          <div class="flex-1 h-full flex flex-col bg-gray-200 relative overflow-hidden">
              <div class="bg-white px-4 py-2 flex justify-center items-center gap-6 text-xs font-bold text-gray-600 border-b border-gray-300 shrink-0 shadow-sm z-20">
                   <label class="flex items-center gap-2 cursor-pointer hover:text-gray-900 group"><input type="checkbox" id="chk-source" checked class="rounded text-blue-600 focus:ring-blue-500"><span class="group-hover:text-blue-600">Source</span></label>
                   <div class="w-px h-4 bg-gray-300"></div>
                   <label class="flex items-center gap-2 cursor-pointer hover:text-gray-900 group"><input type="checkbox" id="chk-svg" checked class="rounded text-blue-600 focus:ring-blue-500"><span class="group-hover:text-blue-600">SVG Overlay</span></label>
                   <div class="w-px h-4 bg-gray-300"></div>
                   <label class="flex items-center gap-2 cursor-pointer hover:text-gray-900 group"><input type="checkbox" id="chk-grid" class="rounded text-blue-600 focus:ring-blue-500"><span class="group-hover:text-blue-600">Grid</span></label>
              </div>
              <div id="canvas-scroller" class="flex-1 overflow-auto flex justify-center p-12 relative cursor-default bg-gray-200">
                  <div id="canvas-wrapper" class="relative bg-white origin-top ring-1 ring-gray-900/5 transition-all ease-out duration-150">
                      <div id="pdf-layer" class="transition-opacity duration-200"></div> 
                      <div id="grid-layer" class="absolute inset-0 grid-overlay hidden opacity-50 pointer-events-none z-0"></div>
                      <div id="svg-layer" class="absolute inset-0 z-10 transition-opacity duration-200 pointer-events-none"></div> 
                      <div id="interaction-layer" class="absolute inset-0 z-20"></div>
                      <div id="selection-box"></div>
                  </div>
              </div>
          </div>
      </div>
      
      <div id="debug-container" class="flex-1 hidden flex-col bg-gray-900 p-6 overflow-auto text-white">
           <div class="flex justify-center gap-4 mb-6 h-80">
               <div class="border border-gray-700 bg-black p-3 rounded-lg flex flex-col items-center w-1/3 shadow-lg">
                   <span class="text-xs font-bold text-yellow-500 mb-2 uppercase tracking-wide">Source Crop</span>
                   <img id="debug-img-source" class="h-full object-contain bg-[#1a1a1a] rounded border border-gray-800">
               </div>
               <div class="border border-gray-700 bg-black p-3 rounded-lg flex flex-col items-center w-1/3 shadow-lg">
                   <span class="text-xs font-bold text-purple-400 mb-2 uppercase tracking-wide">Blueprint (RLE)</span>
                   <div id="debug-blueprint" class="h-full w-full flex items-center justify-center bg-white text-black rounded border border-gray-800"></div>
               </div>
               <div class="border border-gray-700 bg-black p-3 rounded-lg flex flex-col items-center w-1/3 shadow-lg">
                   <span class="text-xs font-bold text-blue-400 mb-2 uppercase tracking-wide">SVG Result</span>
                   <div id="debug-svg-preview" class="h-full w-full flex items-center justify-center bg-white text-black rounded border border-gray-800"></div>
               </div>
           </div>
           <div class="flex-1 border border-gray-700 bg-gray-800 rounded-lg p-3 shadow-inner">
               <span class="text-xs font-bold text-gray-400 block mb-2 uppercase tracking-wide border-b border-gray-700 pb-1">System Log</span>
               <pre id="debug-log" class="text-xs font-mono text-green-400 overflow-auto h-full p-2"></pre>
           </div>
      </div>
    </main>

    <div id="new-selection-action-bar" class="bg-gray-800 text-white rounded-lg shadow-2xl flex items-center p-1.5 gap-2 border border-gray-600 ring-1 ring-black/50 backdrop-blur-md bg-opacity-95">
      <span class="text-[10px] font-bold text-gray-400 px-2 uppercase tracking-wider">Create:</span>
      <button class="px-3 py-1 bg-blue-600 hover:bg-blue-500 rounded text-xs font-bold text-white shadow-sm transition" onclick="app.createRegion('text')">Text</button>
      <button class="px-3 py-1 bg-amber-600 hover:bg-amber-500 rounded text-xs font-bold text-white shadow-sm transition" onclick="app.createRegion('image')">Image</button>
      <button class="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-xs font-bold text-white shadow-sm transition" onclick="app.createRegion('empty')">Empty</button>
      <div class="w-px h-4 bg-gray-600 mx-1"></div>
      <button class="px-2 py-1 text-gray-400 hover:text-white text-xs font-medium transition" onclick="app.clearSelection()">Cancel</button>
    </div>
    
    <canvas id="processing-canvas" style="display:none;"></canvas>

    <script type="module">
        const CONFIG = { defaultPdfUrl: "https://lsparrish.github.io/sciconvert/sample.png", aiScale: 2.0 };
        const apiKey = "";
        const state = {
            pdfDoc: null,
            scaleMultiplier: 1.0,
            baseWidth: 0,
            regions: [],
            activeRegionId: null,
            selectedIds: new Set(),
            splitMode: false,
            splitTargetId: null,
            splitSelection: new Set(),
            aspectLocked: false,
            editMode: 'area', 
            history: [],
            historyIndex: -1,
            dragAction: null, 
            dragStart: { x: 0, y: 0 }, 
            initialRect: null, 
            initialScale: null,
            canvas: document.createElement('canvas'),
        };
        
        const els = {
            upload: document.getElementById('pdf-upload'),
            btnZoomIn: document.getElementById('zoom-in'),
            btnZoomOut: document.getElementById('zoom-out'),
            txtZoomLevel: document.getElementById('zoom-level'),
            btnUndo: document.getElementById('btn-undo'),
            btnRedo: document.getElementById('btn-redo'),
            workspace: document.getElementById('workspace-container'),
            emptyState: document.getElementById('empty-state'),
            loader: document.getElementById('pdf-loader'),
            wrapper: document.getElementById('canvas-wrapper'), 
            pdfLayer: document.getElementById('pdf-layer'),
            svgLayer: document.getElementById('svg-layer'),
            interactionLayer: document.getElementById('interaction-layer'),
            selectionBox: document.getElementById('selection-box'),
            selectionBar: document.getElementById('new-selection-action-bar'),
            // Replaced editor with layerList
            layerList: document.getElementById('layer-list'), 
            btnAddLayer: document.getElementById('btn-add-layer'),
            regionCount: document.getElementById('region-count'),
            contextActions: document.getElementById('context-actions'),
            aiStatus: document.getElementById('ai-status'),
            modeArea: document.getElementById('mode-area'),
            modeContent: document.getElementById('mode-content'),
            modeLabel: document.getElementById('mode-label'),
            btnFitArea: document.getElementById('btn-fit-area'),
            btnFitContent: document.getElementById('btn-fit-content'),
            lblX: document.getElementById('lbl-x'), lblY: document.getElementById('lbl-y'),
            lblW: document.getElementById('lbl-w'), lblH: document.getElementById('lbl-h'),
            propX: document.getElementById('prop-x'), propY: document.getElementById('prop-y'),
            propW: document.getElementById('prop-w'), propH: document.getElementById('prop-h'),
            chkSource: document.getElementById('chk-source'),
            chkSvg: document.getElementById('chk-svg'),
            chkGrid: document.getElementById('chk-grid'),
            debugContainer: document.getElementById('debug-container'),
            debugImg: document.getElementById('debug-img-source'),
            debugSvg: document.getElementById('debug-svg-preview'),
            debugBlueprint: document.getElementById('debug-blueprint'),
            debugLog: document.getElementById('debug-log'),
            btnDigitize: document.getElementById('btn-digitize'),
            btnSplit: document.getElementById('btn-split')
        };

        // --- INIT & SETUP ---
        async function init() {
            try { 
                loadDefaultImage(); 
            } catch(e) { 
                console.error("Initialization Error:", e);
                els.loader.classList.add('hidden');
            }
            setupEventListeners();
            updateHistoryUI();
        }
        
        function loadDefaultImage() {
            els.loader.classList.remove('hidden');
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                state.canvas.width = img.width;
                state.canvas.height = img.height;
                state.baseWidth = img.width;
                const ctx = state.canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                state.pdfDoc = { numPages: 1, isImage: true };
                renderPage();
                els.loader.classList.add('hidden');
                els.emptyState.classList.add('hidden');
                els.workspace.classList.remove('hidden');
                els.workspace.classList.add('flex');
                saveState(true);
                switchTab('overlay');
            };
            img.onerror = () => {
                console.error("Failed to load default image");
                // Removed alert();
                els.emptyState.innerHTML = '<div class="bg-white p-8 rounded-2xl shadow-xl text-center border border-gray-200"><h2 class="text-xl font-bold mb-2 text-red-700">Load Error</h2><p class="text-sm text-gray-500">Could not load default image. Please try uploading a file.</p></div>';
                els.loader.classList.add('hidden');
            };
            img.src = CONFIG.defaultPdfUrl;
        }
        
        function setupEventListeners() {
            els.interactionLayer.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('keydown', handleKeyDown);

            els.btnZoomIn.onclick = () => setZoom(state.scaleMultiplier + 0.25);
            els.btnZoomOut.onclick = () => setZoom(state.scaleMultiplier - 0.25);
            els.btnUndo.onclick = undo;
            els.btnRedo.onclick = redo;
            
            els.modeArea.onclick = () => setMode('area');
            els.modeContent.onclick = () => setMode('content');
            els.btnFitContent.onclick = fitContentToArea;
            els.btnFitArea.onclick = fitAreaToContent;

            [els.propX, els.propY, els.propW, els.propH].forEach(input => {
                input.addEventListener('input', updateRegionFromInput);
                input.addEventListener('change', () => saveState());
            });
            
            els.btnAddLayer.onclick = addLayerToRegion;

            els.chkSource.onchange = () => els.pdfLayer.style.opacity = els.chkSource.checked ? 1 : 0;
            els.chkSvg.onchange = () => els.svgLayer.style.opacity = els.chkSvg.checked ? 1 : 0;
            els.chkGrid.onchange = () => document.getElementById('grid-layer').classList.toggle('hidden', !els.chkGrid.checked);
            
            els.upload.onchange = handleFileUpload;
            
            document.getElementById('btn-export').onclick = exportSVG;
            document.getElementById('btn-clear-all').onclick = () => { if(confirm('Clear all?')) { state.regions = []; renderRegions(); saveState(); }};
            document.getElementById('btn-delete').onclick = () => { if(state.activeRegionId) { state.regions = state.regions.filter(r => !state.selectedIds.has(r.id)); deselect(); renderRegions(); saveState(); }};
            document.getElementById('btn-regen').onclick = () => { if(state.activeRegionId) createRegion('text', state.activeRegionId); };
            if(els.btnDigitize) els.btnDigitize.onclick = digitizeRegion;
            els.btnSplit.onclick = handleSplitAction;
            document.getElementById('btn-group').onclick = groupSelectedRegions;
            document.getElementById('btn-optimize').onclick = optimizeActiveRegion;
            
            document.getElementById('tab-overlay').onclick = () => switchTab('overlay');
            document.getElementById('tab-debug').onclick = () => switchTab('debug');
            document.getElementById('fullscreen-toggle').onclick = () => document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen();
        }

        // --- HISTORY SYSTEM ---
        function saveState(isInitial = false) {
            if (state.historyIndex < state.history.length - 1) state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(JSON.parse(JSON.stringify(state.regions)));
            state.historyIndex++;
            if (state.history.length > 50) { state.history.shift(); state.historyIndex--; }
            updateHistoryUI();
        }
        function undo() { if (state.historyIndex > 0) { state.historyIndex--; restoreState(); } }
        function redo() { if (state.historyIndex < state.history.length - 1) { state.historyIndex++; restoreState(); } }
        function restoreState() { state.regions = JSON.parse(JSON.stringify(state.history[state.historyIndex])); deselect(); renderRegions(); updateHistoryUI(); }
        function updateHistoryUI() {
            els.btnUndo.disabled = state.historyIndex <= 0;
            els.btnUndo.classList.toggle('opacity-30', state.historyIndex <= 0);
            els.btnRedo.disabled = state.historyIndex >= state.history.length - 1;
            els.btnRedo.classList.toggle('opacity-30', state.historyIndex >= state.history.length - 1);
        }

        // --- ZOOM & RENDER ---
        function setZoom(m) { state.scaleMultiplier = Math.max(0.25, Math.min(5.0, m)); applyZoom(); }
        function applyZoom() {
            const nw = state.baseWidth * state.scaleMultiplier;
            const nh = (state.canvas.height / state.canvas.width) * nw;
            els.wrapper.style.width = `${nw}px`; els.wrapper.style.height = `${nh}px`;
            els.txtZoomLevel.textContent = `${Math.round(state.scaleMultiplier * 100)}%`;
        }
        function renderPage() { els.pdfLayer.innerHTML = ''; els.pdfLayer.appendChild(state.canvas); state.canvas.style.width='100%'; state.canvas.style.height='100%'; applyZoom(); initSvgLayer(); }
        function initSvgLayer() {
            const w = state.canvas.width; const h = state.canvas.height;
            els.svgLayer.innerHTML = `<svg id="main-svg" width="${w}" height="${h}" style="width:100%; height:100%;" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg"><g id="regions"></g><g id="highlights"></g></svg>`;
            renderRegions();
        }

        // --- MOUSE HANDLERS ---
        function handleMouseDown(e) {
            if(e.button !== 0) return;
            const target = e.target;
            
            if (target.classList.contains('split-overlay')) {
                const idx = parseInt(target.dataset.splitIndex);
                if (state.splitSelection.has(idx)) {
                    state.splitSelection.delete(idx);
                } else {
                    state.splitSelection.add(idx);
                }
                renderRegions(); // Re-render to update overlay colors
                return;
            }

            if (state.splitMode) {
                return;
            }

            if (target.dataset.action) {
                const frame = target.closest('.selection-frame');
                if (frame && frame.dataset.id && frame.dataset.id !== state.activeRegionId) {
                    selectRegion(frame.dataset.id, e.shiftKey);
                    return; 
                }
                state.dragAction = target.dataset.action;
                state.dragStart = getLocalPos(e);
                
                const r = state.regions.find(x => x.id === state.activeRegionId);
                if (r) {
                    r.scale = r.scale || {x: 1, y: 1}; r.offset = r.offset || {x: 0, y: 0};
                    state.initialRect = { ...r.rect }; 
                    state.initialScale = { ...r.scale };
                    updateUIProperties(r);
                }
                return;
            }
            
            els.interactionLayer.style.pointerEvents = 'none';
            const below = document.elementFromPoint(e.clientX, e.clientY);
            els.interactionLayer.style.pointerEvents = 'auto';
            
            if (below && below.classList.contains('region-highlight')) {
                selectRegion(below.getAttribute('data-id'), e.shiftKey);
                return;
            } else if (below && below.classList.contains('region-selected')) {
                // Clicking an already selected item with Shift should deselect it, or select it if not active
                selectRegion(below.getAttribute('data-id'), e.shiftKey);
                return;
            }

            state.dragAction = 'create';
            state.dragStart = getLocalPos(e); 
            if (!e.shiftKey) deselect(); // Only clear selection if not shift-clicking
            els.selectionBox.style.display = 'block';
            els.selectionBox.style.width = '0'; els.selectionBox.style.height = '0';
            els.selectionBar.style.display = 'none';
        }

        function handleMouseMove(e) {
            if (!state.dragAction) return;
            const cw = state.canvas.width; const ch = state.canvas.height;
            const pos = getLocalPos(e);

            if (state.dragAction === 'create') {
                const start = state.dragStart;
                const x = Math.min(pos.x, start.x); const y = Math.min(pos.y, start.y);
                const w = Math.abs(pos.x - start.x); const h = Math.abs(pos.y - start.y);
                const wrapRect = els.interactionLayer.getBoundingClientRect();
                const ratio = wrapRect.width / cw; 
                els.selectionBox.style.left = (x * ratio) + 'px'; 
                els.selectionBox.style.top = (y * ratio) + 'px';
                els.selectionBox.style.width = (w * ratio) + 'px'; 
                els.selectionBox.style.height = (h * ratio) + 'px';
            } else {
                const r = state.regions.find(x => x.id === state.activeRegionId);
                if (!r || !state.initialRect) return;

                const dx = (pos.x - state.dragStart.x) / cw;
                const dy = (pos.y - state.dragStart.y) / ch;
                let newRect = { ...state.initialRect };
                let newScale = { ...r.scale }; 

                const action = state.dragAction;
                if (action === 'move') {
                    newRect.x += dx; newRect.y += dy;
                } else {
                    if (action.includes('e')) newRect.w = Math.max(0.001, state.initialRect.w + dx);
                    if (action.includes('s')) newRect.h = Math.max(0.001, state.initialRect.h + dy);
                    if (action.includes('w')) { 
                        const maxD = state.initialRect.w - 0.001;
                        const validDx = Math.min(maxD, dx);
                        newRect.x += validDx; newRect.w -= validDx; 
                    }
                    if (action.includes('n')) {
                        const maxD = state.initialRect.h - 0.001;
                        const validDy = Math.min(maxD, dy);
                        newRect.y += validDy; newRect.h -= validDy;
                    }
                }
                
                if (newRect.w > 0.005 && newRect.h > 0.005) {
                    r.rect = newRect;
                    r.scale = newScale;
                    updateRegionVisuals(r, cw, ch);
                    updatePropertyInputs();
                }
            }
        }

        function handleMouseUp(e) {
            if (!state.dragAction) return;
            
            if (state.dragAction === 'create') {
                 const sb = els.selectionBox;
                 if ((parseFloat(sb.style.width)||0) > 5) {
                     const rect = els.interactionLayer.getBoundingClientRect();
                     const ratio = state.canvas.width / rect.width;
                     const lx = parseFloat(sb.style.left) * ratio;
                     const ly = parseFloat(sb.style.top) * ratio;
                     const w = parseFloat(sb.style.width) * ratio;
                     const h = parseFloat(sb.style.height) * ratio;
                     
                     const newRegion = {
                         id: `r${Date.now()}`,
                         rect: { x: lx/state.canvas.width, y: ly/state.canvas.height, w: w/state.canvas.width, h: h/state.canvas.height },
                         bpDims: { w: w, h: h },
                         svgContent: '', 
                         scale: { x: 1, y: 1 }, offset: { x: 0, y: 0 },
                         status: 'draft'
                     };
                     state.regions.push(newRegion);
                     saveState();
                     selectRegion(newRegion.id); 
                 }
                 sb.style.display = 'none';
            } else {
                saveState();
            }
            state.dragAction = null;
            state.dragStart = null;
            state.initialRect = null;
        }
        
        function handleKeyDown(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); return; }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); return; }
            if (e.key === 'Escape') {
                if (state.splitMode) {
                    // Exit split mode
                    state.splitMode = false;
                    state.splitTargetId = null;
                    state.splitSelection.clear();
                    els.btnSplit.textContent = "Split";
                    renderRegions();
                    updateUI();
                    return;
                }

                if (state.dragAction === 'create') { state.dragAction = null; els.selectionBox.style.display = 'none'; }
                else if (state.activeRegionId) deselect();
                return;
            }
            if (!state.activeRegionId) return;
            if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
            
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if (!r) return;
            
            const step = e.shiftKey ? 0.01 : 0.001;
            let handled = true;
            if (e.key === 'ArrowUp') r.rect.y -= step;
            else if (e.key === 'ArrowDown') r.rect.y += step;
            else if (e.key === 'ArrowLeft') r.rect.x -= step;
            else if (e.key === 'ArrowRight') r.rect.x += step;
            else if (e.key === 'Delete' || e.key === 'Backspace') {
                state.regions = state.regions.filter(x => x.id !== state.activeRegionId);
                deselect(); saveState(); handled = true;
            } else handled = false;
            
            if (handled) { e.preventDefault(); renderRegions(); updatePropertyInputs(); }
        }

        // --- DATA UPDATE LOGIC ---
        function updateRegionFromInput() {
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if(!r) return;
            const cw = state.canvas.width; const ch = state.canvas.height;
            
            if (state.editMode === 'area') {
                r.rect.x = parseFloat(els.propX.value) / cw;
                r.rect.y = parseFloat(els.propY.value) / ch;
                r.rect.w = parseFloat(els.propW.value) / cw;
                r.rect.h = parseFloat(els.propH.value) / ch;
            } else {
                r.offset.x = parseFloat(els.propX.value) || 0;
                r.offset.y = parseFloat(els.propY.value) || 0;
                // Update bpDims (zooming) instead of scale
                const inputW = parseFloat(els.propW.value);
                const inputH = parseFloat(els.propH.value);
                if (inputW > 0) r.bpDims.w = inputW;
                if (inputH > 0) r.bpDims.h = inputH;
            }
            
            updateRegionVisuals(r, cw, ch);
        }
        
        function renderLayerList(r) {
            const list = els.layerList;
            list.innerHTML = '';
            
            if (!r || !r.svgContent) {
                 list.innerHTML = '<div class="text-center text-gray-400 text-[10px] mt-4">Select a region to view layers</div>';
                 return;
            }

            // Parse content
            const parser = new DOMParser();
            // Wrapping in svg because r.svgContent contains the inner elements, usually multiple
            const doc = parser.parseFromString(`<svg>${r.svgContent}</svg>`, "image/svg+xml");
            const root = doc.documentElement;
            
            // Filter for Element nodes only
            const children = Array.from(root.childNodes).filter(n => n.nodeType === 1);

            if (children.length === 0) {
                if(r.svgContent.trim()) {
                    createLayerItem(r.svgContent, 0);
                } else {
                    list.innerHTML = '<div class="text-center text-gray-400 text-[10px] mt-4">No content</div>';
                }
            } else {
                children.forEach((child, index) => {
                    createLayerItem(child.outerHTML, index);
                });
            }
        }
        
        function createLayerItem(content, index) {
            const div = document.createElement('div');
            div.className = 'bg-white border border-gray-300 rounded p-2 shadow-sm group relative mb-2';
            
            // Header
            const match = content.match(/^<([a-z0-9]+)/i);
            const tagName = match ? match[1] : 'element';
            
            const header = document.createElement('div');
            header.className = 'text-[10px] font-bold text-blue-500 uppercase mb-1 flex justify-between items-center';
            
            const title = document.createElement('span');
            title.innerText = tagName;
            header.appendChild(title);
            
            const delBtn = document.createElement('button');
            delBtn.innerHTML = '&times;';
            delBtn.className = 'text-gray-400 hover:text-red-500 text-lg leading-none px-1';
            delBtn.title = 'Delete Element';
            delBtn.onclick = () => deleteLayer(index);
            header.appendChild(delBtn);

            div.appendChild(header);

            // Textarea
            const ta = document.createElement('textarea');
            ta.className = 'w-full text-[10px] font-mono border border-gray-100 bg-gray-50 rounded p-1 resize-y outline-none focus:border-blue-300 h-16';
            ta.value = content;
            ta.spellcheck = false;
            ta.oninput = () => updateRegionFromList(); // Live update? Or debounce?
            ta.onblur = () => { updateRegionFromList(); saveState(); }; // Save on blur
            ta.dataset.index = index;
            
            div.appendChild(ta);
            els.layerList.appendChild(div);
        }

        function deleteLayer(index) {
            const textareas = Array.from(els.layerList.querySelectorAll('textarea'));
            textareas.splice(index, 1); // Remove from UI list logic
            
            // Reconstruct
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if(!r) return;
            
            r.svgContent = textareas.map(ta => ta.value).join('\n');
            
            updateRegionVisuals(r, state.canvas.width, state.canvas.height);
            renderLayerList(r); // Re-render list to update indices
            saveState();
        }
        
        function addLayerToRegion() {
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if(!r) return;
            
            // Append a dummy element
            r.svgContent += `\n<text x="10" y="10" font-size="10" fill="black">New Text</text>`;
            updateRegionVisuals(r, state.canvas.width, state.canvas.height);
            renderLayerList(r);
            saveState();
        }

        function updateRegionFromList() {
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if(!r) return;

            const textareas = Array.from(els.layerList.querySelectorAll('textarea'));
            r.svgContent = textareas.map(ta => ta.value).join('\n');
            
            updateRegionVisuals(r, state.canvas.width, state.canvas.height);
        }
        
        // Helper function to just update the edit text if needed, but now we have list
        // Old updateRegionFromEditor is obsolete.
        // function updateRegionFromEditor() ... // Removed as we use list now

        function updateRegionVisuals(r, cw, ch) {
            const frame = document.getElementById(`frame-${r.id}`);
            const nested = document.getElementById(`svg-region-${r.id}`);
            
            if(frame) {
                frame.style.left = (r.rect.x * cw) + 'px'; frame.style.top = (r.rect.y * ch) + 'px';
                frame.style.width = (r.rect.w * cw) + 'px'; frame.style.height = (r.rect.h * ch) + 'px';
            }
            if(nested) {
                const pxW = r.rect.w * cw; const pxH = r.rect.h * ch;
                nested.setAttribute('x', r.rect.x * cw); nested.setAttribute('y', r.rect.y * ch);
                nested.setAttribute('width', pxW); nested.setAttribute('height', pxH);
                // FIX: Use bpDims for viewBox to handle scaling via SVG behavior
                nested.setAttribute('viewBox', `0 0 ${r.bpDims.w} ${r.bpDims.h}`); 
                
                const grp = document.getElementById(`group-${r.id}`);
                if (grp) {
                    // FIX: Removed scale transform, relying on viewBox. Only translation remains.
                    grp.setAttribute('transform', `translate(${r.offset.x}, ${r.offset.y})`);
                    grp.innerHTML = r.svgContent;
                }
            }
        }

        // --- GEOMETRY UTILS ---
        function fitContentToArea() {
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if (!r) return;
            
            const group = document.getElementById(`group-${r.id}`);
            if (!group) return;
            
            try {
                // 1. Get Intrinsic Bounds (untransformed BBox)
                const originalTransform = group.getAttribute('transform');
                group.removeAttribute('transform'); 
                const contentBBox = group.getBBox();
                group.setAttribute('transform', originalTransform || "");
                
                const contentW = contentBBox.width;
                const contentH = contentBBox.height;
                const contentX = contentBBox.x;
                const contentY = contentBBox.y;

                if (contentW <= 0 || contentH <= 0) {
                    console.warn("Content has zero dimensions. Cannot fit content.");
                    return;
                }

                // 2. Update bpDims to match content size -> ViewBox matches content -> Scale is effectively 1
                r.bpDims.w = contentW;
                r.bpDims.h = contentH;
                
                // 3. Reset Scale to 1 (implied by removal of scale transform usage)
                r.scale.x = 1;
                r.scale.y = 1;
                
                // 4. Calculate Offset: Shift content origin to 0,0
                r.offset.x = -contentX;
                r.offset.y = -contentY;

            } catch(e) {
                console.error("Error calculating content BBox for Fill Content:", e);
                return;
            }

            renderLayerList(r);
            updateRegionVisuals(r, state.canvas.width, state.canvas.height);
            renderRegions(); 
            updatePropertyInputs(); 
            saveState();
        }

        function fitAreaToContent() {
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if (!r) return;
            const nestedSvg = document.getElementById(`svg-region-${r.id}`);
            const group = document.getElementById(`group-${r.id}`);
            if (!nestedSvg || !group) return;

            const cw = state.canvas.width; 
            const ch = state.canvas.height;

            try {
                // 1. Get absolute screen coordinates of content
                const contentRect = group.getBoundingClientRect();
                const wrapperRect = els.interactionLayer.getBoundingClientRect();
                
                // 2. Convert to Canvas Coordinates
                const ratio = cw / wrapperRect.width;
                const absX = (contentRect.left - wrapperRect.left) * ratio;
                const absY = (contentRect.top - wrapperRect.top) * ratio;
                const absW = contentRect.width * ratio;
                const absH = contentRect.height * ratio;

                // 3. Update Region Rect to match visual bounds perfectly
                r.rect = { 
                    x: absX / cw, 
                    y: absY / ch, 
                    w: absW / cw, 
                    h: absH / ch 
                };

                // 4. Update visuals to move container to new location
                updateRegionVisuals(r, cw, ch);
                
                // 5. Reset internal content to align with new container (0,0)
                fitContentToArea(); 
                
            } catch(e) {
                console.error("Error calculating visual BBox for Fit Area:", e);
                return;
            }
        }

        // --- CORE FUNCTIONS ---
        function renderRegions() {
            const gRegions = els.svgLayer.querySelector('#regions');
            const gHighlights = els.svgLayer.querySelector('#highlights');
            gRegions.innerHTML = ''; gHighlights.innerHTML = '';
            
            if (!state.dragAction || state.dragAction === 'create') els.interactionLayer.innerHTML = '';
            
            const cw = state.canvas.width; const ch = state.canvas.height;
            
            state.regions.forEach(r => {
                r.scale = r.scale || {x:1, y:1}; r.offset = r.offset || {x:0, y:0};
                if (!r.bpDims) r.bpDims = { w: r.rect.w*cw, h: r.rect.h*ch };

                const px = r.rect.x * cw; const py = r.rect.y * ch;
                const pw = r.rect.w * cw; const ph = r.rect.h * ch; 
                
                if (r.status === 'draft') {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("x", px); rect.setAttribute("y", py);
                    rect.setAttribute("width", pw);
                    rect.setAttribute("height", ph); 
                    rect.setAttribute("class", "region-draft");
                    gRegions.appendChild(rect);
                } else {
                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttribute("x", px); svg.setAttribute("y", py);
                    svg.setAttribute("width", pw);
                    svg.setAttribute("height", ph); 
                    // FIX: ViewBox uses bpDims (intrinsic content size), not pixel size
                    svg.setAttribute("viewBox", `0 0 ${r.bpDims.w} ${r.bpDims.h}`); 
                    svg.setAttribute("preserveAspectRatio", "none");
                    svg.setAttribute("id", `svg-region-${r.id}`);
                    
                    // FIX: Removed scale transform. Only offset is applied. Scaling is implicit via viewBox.
                    svg.innerHTML = `<g id="group-${r.id}" transform="translate(${r.offset.x}, ${r.offset.y})">${r.svgContent}</g>`;
                    gRegions.appendChild(svg);
                }
                
                if (r.id === state.activeRegionId && state.selectedIds.size <= 1 && !state.dragAction) {
                    // If in split mode, don't render resize handles, render the overlays
                    if (state.splitMode && state.splitTargetId === r.id) {
                         renderSplitOverlays(r);
                    } else {
                         renderActiveSelectionControls(r);
                    }
                } else if (state.selectedIds.has(r.id)) {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("x", px); rect.setAttribute("y", py);
                    rect.setAttribute("width", pw); rect.setAttribute("height", ph); 
                    rect.setAttribute("class", "region-selected");
                    rect.setAttribute("data-id", r.id);
                    gHighlights.appendChild(rect);
                } else {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("x", px); rect.setAttribute("y", py);
                    rect.setAttribute("width", pw); rect.setAttribute("height", ph); 
                    rect.setAttribute("class", "region-highlight");
                    rect.setAttribute("data-id", r.id);
                    gHighlights.appendChild(rect);
                }
            });
            updateUI();
        }

        function renderActiveSelectionControls(region) {
            if (document.querySelector(`.selection-frame[data-id="${region.id}"]`)) return;
            const w = state.canvas.width; const h = state.canvas.height;
            const px = region.rect.x * w; const py = region.rect.y * h;
            const pw = region.rect.w * w; const ph = region.rect.h * h;

            const frame = document.createElement('div');
            frame.className = 'selection-frame'; frame.id = `frame-${region.id}`;
            frame.style.left = `${px}px`; frame.style.top = `${py}px`;
            frame.style.width = `${pw}px`; frame.style.height = `${ph}px`;
            frame.dataset.id = region.id; frame.dataset.action = 'move';

            ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'].forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle handle-${pos}`;
                handle.dataset.action = pos;
                frame.appendChild(handle);
            });
            els.interactionLayer.appendChild(frame);
        }

        function renderSplitOverlays(region) {
             const group = document.getElementById(`group-${region.id}`);
             if (!group) return;
             
             const children = Array.from(group.children);
             const wrapperRect = els.interactionLayer.getBoundingClientRect();
             const cw = state.canvas.width;
             const ratio = cw / wrapperRect.width; // Scale ratio from screen pixels to canvas pixels

             children.forEach((child, idx) => {
                 if (!(child instanceof SVGGraphicsElement)) return;
                 
                 // Get Bounding Box in Screen Coords
                 const rect = child.getBoundingClientRect();
                 
                 // Convert to Interaction Layer Coords (screen space relative to layer)
                 
                 const layerRect = els.interactionLayer.getBoundingClientRect();
                 const x = (rect.left - layerRect.left);
                 const y = (rect.top - layerRect.top);
                 const w = rect.width;
                 const h = rect.height;
                 
                 const div = document.createElement('div');
                 div.className = 'absolute border-2 border-dashed border-indigo-400 bg-indigo-500/20 hover:bg-indigo-500/40 cursor-pointer pointer-events-auto transition-colors';
                 if (state.splitSelection.has(idx)) {
                     div.className = 'absolute border-2 border-red-500 bg-red-500/40 cursor-pointer pointer-events-auto transition-colors';
                 }
                 
                 div.style.left = x + 'px';
                 div.style.top = y + 'px';
                 div.style.width = w + 'px';
                 div.style.height = h + 'px';
                 div.dataset.splitIndex = idx;
                 div.dataset.regionId = region.id;
                 div.classList.add('split-overlay');
                 
                 els.interactionLayer.appendChild(div);
             });
        }

        function selectRegion(id, multi = false) {
            if (state.splitMode) return; // Lock selection change while splitting

            if (multi) {
                if (state.selectedIds.has(id)) {
                    state.selectedIds.delete(id);
                    if (state.activeRegionId === id) {
                        state.activeRegionId = state.selectedIds.size > 0 ? Array.from(state.selectedIds).pop() : null;
                    }
                } else {
                    state.selectedIds.add(id);
                    state.activeRegionId = id;
                }
            } else {
                state.selectedIds.clear();
                state.selectedIds.add(id);
                state.activeRegionId = id;
            }
            
            renderRegions();
            
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if(r) {
                // Update List View
                renderLayerList(r);
                updateUIProperties(r);
                if (r.status === 'draft') showCreationBar(r); else els.selectionBar.style.display = 'none';
            } else els.selectionBar.style.display = 'none';
        }
        
        function deselect() {
            if (state.splitMode) {
                state.splitMode = false;
                state.splitTargetId = null;
                state.splitSelection.clear();
                els.btnSplit.textContent = "Split";
                els.btnSplit.classList.remove('ring-2', 'ring-offset-1', 'ring-indigo-500');
                // Fallthrough to clear general selection
            }
            
            state.activeRegionId = null;
            state.selectedIds.clear();
            renderRegions();
            els.selectionBar.style.display = 'none';
            els.selectionBox.style.display = 'none';
            // Clear List
            els.layerList.innerHTML = '<div class="text-center text-gray-400 text-[10px] mt-4">Select a region to view layers</div>';
            els.contextActions.classList.add('disabled-bar');
            [els.propX, els.propY, els.propW, els.propH].forEach(el => { el.value = ''; el.disabled = true; });
        }

        function updateUIProperties(r) {
            const multiple = state.selectedIds.size > 1;
            [els.propX, els.propY, els.propW, els.propH].forEach(el => { 
                el.disabled = multiple; 
                if (multiple) {
                    el.classList.add('disabled-input');
                    el.value = '';
                } else {
                    el.classList.remove('disabled-input'); 
                }
            });
            
            if (!multiple) {
                updatePropertyInputs();
                updateDebug(r);
            }
        }

        function getLocalPos(e) {
            const r = els.interactionLayer.getBoundingClientRect();
            const sx = state.canvas.width / r.width;
            const sy = state.canvas.height / r.height;
            return { x: (e.clientX - r.left) * sx, y: (e.clientY - r.top) * sy };
        }
        
        function showCreationBar(r) {
             const rect = els.interactionLayer.getBoundingClientRect();
             const cw = state.canvas.width; const ch = state.canvas.height;
             const ratio = rect.width / cw; 
             const sx = rect.left + (r.rect.x * cw * ratio);
             const sy = rect.top + (r.rect.y * ch * ratio) + (r.rect.h * ch * ratio) + 10;
             els.selectionBar.style.left = Math.min(window.innerWidth - 250, Math.max(10, sx)) + 'px';
             els.selectionBar.style.top = sy + 'px';
             els.selectionBar.style.display = 'flex';
        }

        function updatePropertyInputs() {
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if(!r || state.selectedIds.size > 1) return;
            const cw = state.canvas.width || 1000; const ch = state.canvas.height || 1000;
            
            if (state.editMode === 'area') {
                els.lblX.textContent = 'Pos X'; els.lblY.textContent = 'Pos Y';
                els.lblW.textContent = 'Width'; els.lblH.textContent = 'Height';
                els.propX.value = (r.rect.x * cw).toFixed(0);
                els.propY.value = (r.rect.y * ch).toFixed(0);
                els.propW.value = (r.rect.w * cw).toFixed(0);
                els.propH.value = (r.rect.h * ch).toFixed(0);
            } else {
                els.lblX.textContent = 'Shift X'; els.lblY.textContent = 'Shift Y';
                els.lblW.textContent = 'Eff. W'; els.lblH.textContent = 'Eff. H';
                els.propX.value = r.offset.x.toFixed(2);
                els.propY.value = r.offset.y.toFixed(2);
                // Display bpDims directly, as scale is assumed 1
                els.propW.value = (r.bpDims.w).toFixed(2);
                els.propH.value = (r.bpDims.h).toFixed(2);
            }
        }
        
        function updateUI() {
            els.regionCount.textContent = `${state.regions.length}`;
            if(state.activeRegionId) els.contextActions.classList.remove('disabled-bar');
            else els.contextActions.classList.add('disabled-bar');
        }

        async function handleFileUpload(e) {
            const file = e.target.files[0]; if(!file) return;
            els.loader.classList.remove('hidden');
            if (file.type === 'application/pdf') {
                const ab = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(ab).promise;
                const page = await pdf.getPage(1);
                const viewport = page.getViewport({ scale: 2.0 });
                state.canvas.width = viewport.width; state.canvas.height = viewport.height; state.baseWidth = viewport.width;
                await page.render({ canvasContext: state.canvas.getContext('2d'), viewport }).promise;
            } else {
                const img = new Image(); img.src = URL.createObjectURL(file);
                await new Promise(r => img.onload = r);
                state.canvas.width = img.width; state.canvas.height = img.height; state.baseWidth = img.width;
                state.canvas.getContext('2d').drawImage(img, 0, 0);
            }
            state.regions = []; state.history = []; renderPage();
            els.loader.classList.add('hidden'); els.emptyState.classList.add('hidden');
            els.workspace.classList.remove('hidden'); els.workspace.classList.add('flex');
            saveState(true);
        }

        async function createRegion(type, id) {
            const tid = id || state.activeRegionId; if(!tid) return;
            const r = state.regions.find(x => x.id === tid); if(!r) return;
            els.aiStatus.classList.remove('hidden'); els.selectionBar.style.display = 'none';
            
            const cw = state.canvas.width; const ch = state.canvas.height;
            const pw = Math.floor(r.rect.w * cw); const ph = Math.floor(r.rect.h * ch);
            const tmp = document.createElement('canvas'); tmp.width = pw * 2; tmp.height = ph * 2;
            tmp.getContext('2d').drawImage(state.canvas, r.rect.x * cw, r.rect.y * ch, pw, ph, 0, 0, pw*2, ph*2);
            
            r.srcCrop = tmp.toDataURL();

            try {
                const bpC = document.createElement('canvas'); 
                const MAX_BP = 300;
                let bpW = pw, bpH = ph;
                if (pw > MAX_BP || ph > MAX_BP) {
                    const ratio = Math.min(MAX_BP/pw, MAX_BP/ph);
                    bpW = Math.floor(pw*ratio); bpH = Math.floor(ph*ratio);
                }
                bpC.width = bpW; bpC.height = bpH;
                bpC.getContext('2d').drawImage(tmp, 0, 0, bpW, bpH);
                
                const rlePath = runLengthEncode(bpC.getContext('2d').getImageData(0,0,bpW,bpH));
                
                r.blueprint = `<svg viewBox="0 0 ${bpW} ${bpH}"><path d="${rlePath}" fill="#00ff00"/></svg>`;
                
                r.svgContent = `<path d="${rlePath}" fill="black" />`;
                
                r.bpDims = {w: bpW, h: bpH}; 
                r.status = undefined; 
                r.scale = {x: 1, y: 1}; r.offset = {x: 0, y: 0};
                
                saveState(); selectRegion(r.id);
            } catch(e) { console.error(e); }
            els.aiStatus.classList.add('hidden');
        }

        async function digitizeRegion() {
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if (!r) return;
            
            els.aiStatus.classList.remove('hidden');
            els.aiStatus.textContent = 'Digitizing...';

            const cw = state.canvas.width; const ch = state.canvas.height;
            const pw = Math.floor(r.rect.w * cw); const ph = Math.floor(r.rect.h * ch);
            
            const tmp = document.createElement('canvas'); tmp.width = pw * 2; tmp.height = ph * 2;
            tmp.getContext('2d').drawImage(state.canvas, r.rect.x * cw, r.rect.y * ch, pw, ph, 0, 0, pw*2, ph*2);
            const base64 = tmp.toDataURL('image/png').split(',')[1];
            
            const bpC = document.createElement('canvas');
            bpC.width = pw; bpC.height = ph; 
            bpC.getContext('2d').drawImage(state.canvas, r.rect.x * cw, r.rect.y * ch, pw, ph, 0, 0, pw, ph);
            const rle = runLengthEncode(bpC.getContext('2d').getImageData(0,0,pw,ph));

            const prompt = `You are a precision SVG Typesetter.
INPUTS:
1. IMAGE: A 2x scale scan of text. Read this text.
2. BLUEPRINT: A 1x scale vector path marking the exact black pixels of the text.

TASK:
Generate semantic SVG <text> elements that match the text in the IMAGE, but positioned precisely over the BLUEPRINT.
- Use the BLUEPRINT as the ground truth for positioning (x, y) and font-size.
- The Output ViewBox is 0 0 ${pw} ${ph}.
- Do not return the blueprint path itself, only the new text elements.
- Use fill="black".
- Output strictly valid SVG elements (e.g. <text x="..." y="...">Content</text>).

BLUEPRINT PATH (Partial):
${rle.substring(0, 500)}...`; 
            
            const payload = { 
                contents: [{ role: "user", parts: [{ text: prompt }, { inlineData: { mimeType: "image/png", data: base64 } }] }] 
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent`;

            const MAX_RETRIES = 5;
            let attempt = 0;
            let resp;
            let success = false;

            while (attempt < MAX_RETRIES && !success) {
                try {
                    resp = await fetch(apiUrl, {
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (resp.status === 429 || resp.status >= 500) {
                        if (attempt < MAX_RETRIES - 1) {
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            attempt++;
                            continue;
                        }
                    }
                    if (!resp.ok) throw new Error(`API Error: ${resp.status}`);
                    success = true;
                } catch (e) {
                    console.error(`Attempt ${attempt + 1} failed:`, e);
                    attempt++;
                    if (attempt === MAX_RETRIES) throw e; 
                }
            }

            if (!success || !resp) {
                els.aiStatus.textContent = 'Error: Max Retries';
                setTimeout(() => { els.aiStatus.classList.add('hidden'); els.aiStatus.textContent = 'Processing...'; }, 3000);
                return;
            }
            
            try {
                const json = await resp.json();
                const text = json.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error(`No SVG generated.`);

                let cleanSvg = text.replace(/```svg/g, '').replace(/```/g, '').trim();
                
                r.svgContent = cleanSvg;
                r.bpDims = { w: pw, h: ph };
                r.scale = { x: 1, y: 1 }; 
                r.offset = { x: 0, y: 0 };
                
                saveState();
                selectRegion(r.id);

            } catch(e) {
                console.error("Digitization Processing Error:", e);
                els.aiStatus.textContent = `Error: ${e.message.substring(0, 30)}...`;
            } finally {
                setTimeout(() => { 
                     els.aiStatus.classList.add('hidden');
                     els.aiStatus.textContent = 'Processing...'; 
                }, 3000);
            }
        }

        function runLengthEncode(imgData) {
            let path = "";
            const { width, height, data } = imgData;
            for (let y = 0; y < height; y += 2) {
                let startX = -1;
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const isDark = data[idx+3] > 128 && data[idx] < 128;
                    if (isDark) {
                        if (startX === -1) startX = x;
                    } else {
                        if (startX !== -1) {
                            path += `M${startX} ${y}h${x - startX}v2h-${x - startX}z`;
                            startX = -1;
                        }
                    }
                }
                if (startX !== -1) path += `M${startX} ${y}h${width - startX}v2h-${width - startX}z`;
            }
            return path;
        }

        function optimizeActiveRegion() {
            if (!state.activeRegionId) return;
            const r = state.regions.find(x => x.id === state.activeRegionId);
            if (r && r.svgContent) {
                 const original = r.svgContent;
                 const optimized = mergeAdjacentTextElements(original);
                 r.svgContent = optimized;
                 renderLayerList(r);
                 updateRegionVisuals(r, state.canvas.width, state.canvas.height);
                 saveState();
                 console.log("Optimization complete");
            }
        }

        function groupSelectedRegions() {
            const selected = state.regions.filter(r => state.selectedIds.has(r.id));
            if (selected.length < 2) {
                alert("Please select at least 2 regions to group.");
                return;
            }

            const cw = state.canvas.width;
            const ch = state.canvas.height;

            let minX = 1, minY = 1, maxX = 0, maxY = 0;
            selected.forEach(r => {
                minX = Math.min(minX, r.rect.x);
                minY = Math.min(minY, r.rect.y);
                maxX = Math.max(maxX, r.rect.x + r.rect.w);
                maxY = Math.max(maxY, r.rect.y + r.rect.h);
            });

            const unionRect = { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
            const pxW = unionRect.w * cw;
            const pxH = unionRect.h * ch;

            let mergedContent = "";
            selected.forEach(r => {
                const relX = (r.rect.x - minX) * cw;
                const relY = (r.rect.y - minY) * ch;
                const visW = r.rect.w * cw;
                const visH = r.rect.h * ch;
                
                // Use nested SVG for grouping to handle scaling naturally
                mergedContent += `<svg x="${relX.toFixed(3)}" y="${relY.toFixed(3)}" width="${visW.toFixed(3)}" height="${visH.toFixed(3)}" viewBox="0 0 ${r.bpDims.w} ${r.bpDims.h}" preserveAspectRatio="none" overflow="visible">
                    <g transform="translate(${r.offset.x}, ${r.offset.y})">
                        ${r.svgContent}
                    </g>
                </svg>`;
            });

            const newRegion = {
                id: `r${Date.now()}`,
                rect: unionRect,
                bpDims: { w: pxW, h: pxH }, 
                svgContent: mergedContent,
                scale: { x: 1, y: 1 },
                offset: { x: 0, y: 0 },
                status: 'grouped'
            };

            state.regions = state.regions.filter(r => !state.selectedIds.has(r.id));
            state.regions.push(newRegion);
            
            state.selectedIds.clear();
            selectRegion(newRegion.id); 
            saveState();
        }

        function handleSplitAction() {
             if (state.splitMode) {
                 // Perform extraction
                 const r = state.regions.find(x => x.id === state.splitTargetId);
                 if (!r) {
                     // Should cancel
                     deselect();
                     return;
                 }
                 
                 if (state.splitSelection.size === 0) {
                     // User didn't select anything, just cancel
                     deselect();
                     return;
                 }
                 
                 // Extraction Logic
                 const group = document.getElementById(`group-${r.id}`);
                 if (!group) return;
                 
                 const children = Array.from(group.children);
                 const newRegions = [];
                 const cw = state.canvas.width;
                 const ch = state.canvas.height;
                 
                 // Base position of the parent region
                 const parentPxX = r.rect.x * cw;
                 const parentPxY = r.rect.y * ch;
                 const wrapperRect = els.interactionLayer.getBoundingClientRect();
                 const ratio = cw / wrapperRect.width;

                 const indicesToExtract = Array.from(state.splitSelection).sort((a,b) => b-a); // Reverse sort to splice safely if we were modifying array, but we are rebuilding string
                 
                 // We need to rebuild the original SVG content sans extracted items
                 // Parsing string to DOM again to manipulate safely
                 const parser = new DOMParser();
                 const doc = parser.parseFromString(`<svg>${r.svgContent}</svg>`, "image/svg+xml");
                 const root = doc.documentElement;
                 const domChildren = Array.from(root.children); // Should match index of rendered children?
                 // Note: rendered group children come from r.svgContent which is what we parsed.
                 // Order should be preserved.
                 
                 const extractedNodes = [];
                 
                 indicesToExtract.forEach(idx => {
                     const child = domChildren[idx];
                     const renderedChild = children[idx]; // Corresponding rendered element for bounds
                     
                     if (child && renderedChild) {
                         // Calculate new region props
                         let absX, absY, absW, absH, content, bpW, bpH;
                         
                         if (child.tagName === 'svg') {
                            // Nested SVG
                            const cx = parseFloat(child.getAttribute('x') || 0);
                            const cy = parseFloat(child.getAttribute('y') || 0);
                            const cw_attr = parseFloat(child.getAttribute('width') || 0);
                            const ch_attr = parseFloat(child.getAttribute('height') || 0);
                            const vb = (child.getAttribute('viewBox') || "0 0 100 100").split(' ').map(parseFloat);
                            
                            // Absolute positions are relative to parent region's origin + child's x/y
                            // Wait, nested SVG x/y are usually pixels within the parent coordinate system
                            // Parent coordinate system is 0..bpDims.w.
                            // But in our renderer, we use viewBox to map bpDims to rect.w/h.
                            // So x/y in the SVG content are in "blueprint units".
                            // We need to convert blueprint units to canvas pixels.
                            
                            // Scale factor from blueprint units to canvas pixels
                            const scaleX = (r.rect.w * cw) / r.bpDims.w;
                            const scaleY = (r.rect.h * ch) / r.bpDims.h;
                            
                            absX = parentPxX + (cx * scaleX);
                            absY = parentPxY + (cy * scaleY);
                            absW = cw_attr * scaleX;
                            absH = ch_attr * scaleY;
                            
                            content = child.innerHTML; // Unwrap the inner content
                            bpW = vb[2];
                            bpH = vb[3];
                            
                         } else {
                            // Raw Element
                            // Use bounding client rect of the *rendered* element to get absolute position
                            const rect = renderedChild.getBoundingClientRect();
                            const absX_screen = (rect.left - wrapperRect.left) * ratio;
                            const absY_screen = (rect.top - wrapperRect.top) * ratio;
                            absW = rect.width * ratio;
                            absH = rect.height * ratio;
                            
                            absX = absX_screen;
                            absY = absY_screen;
                            
                            // For content, we take the outerHTML
                            content = child.outerHTML;
                            
                            // Intrinsic size? Use getBBox of the node if possible? 
                            // Or just set bpDims to match pixel size and scale=1.
                            bpW = absW; 
                            bpH = absH;
                            
                            // We need to normalize the path/element to 0,0 if we move it.
                            // But raw paths might have absolute coords. 
                            // Simply wrapping in <g> with -x -y translate is safest.
                            // But we don't know internal x/y easily without parsing path data.
                            // Strategy: Wrap in group with translate(0,0) initially?
                            // Actually, if we take outerHTML, it retains coordinates.
                            // If coordinates were 500,500, and we move region to 500,500, we need to shift content by -500,-500.
                            
                            // Let's use the rendered BBox relative to the parent group to find offset
                            // renderedChild.getBBox() gives coords in parent SVG system.
                            const bbox = renderedChild.getBBox();
                            
                            // We want to shift so bbox.x, bbox.y becomes 0,0
                            content = `<g transform="translate(${-bbox.x}, ${-bbox.y})">${child.outerHTML}</g>`;
                            bpW = bbox.width;
                            bpH = bbox.height;
                            
                            // But wait, we calculated absX/absY/absW/absH from screen. 
                            // That defines the new region.
                            // The content inside needs to fill that region.
                         }

                         newRegions.push({
                            id: `r${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                            rect: { x: absX / cw, y: absY / ch, w: absW / cw, h: absH / ch },
                            bpDims: { w: bpW, h: bpH },
                            svgContent: content,
                            scale: { x: 1, y: 1 },
                            offset: { x: 0, y: 0 },
                            status: 'optimized'
                        });
                        
                        extractedNodes.push(child);
                     }
                 });

                 // Remove extracted nodes from parent
                 extractedNodes.forEach(node => node.parentNode.removeChild(node));
                 
                 // Update Parent Region
                 r.svgContent = root.innerHTML.trim();
                 
                 // If parent is empty, remove it. 
                 // Note: checking innerHTML is empty or just whitespace
                 if (!r.svgContent || r.svgContent.replace(/\s/g, '') === '') {
                     state.regions = state.regions.filter(reg => reg.id !== r.id);
                 }
                 
                 // Add new regions
                 state.regions = state.regions.concat(newRegions);
                 
                 // Reset Mode
                 deselect();
                 
             } else {
                 // Enter split mode
                 const r = state.regions.find(x => x.id === state.activeRegionId);
                 if (!r) return;
                 
                 state.splitMode = true;
                 state.splitTargetId = r.id;
                 state.splitSelection.clear();
                 
                 els.btnSplit.textContent = "Extract";
                 els.btnSplit.classList.add('ring-2', 'ring-offset-1', 'ring-indigo-500');
                 
                 renderRegions(); // Trigger overlay rendering
             }
        }

        function mergeAdjacentTextElements(svgString) {
            if (!svgString.includes('<text')) return svgString;
            const parser = new DOMParser();
            const doc = parser.parseFromString(`<svg>${svgString}</svg>`, "image/svg+xml");
            const svgRoot = doc.querySelector('svg');
            if (!svgRoot) return svgString;

            const textElements = Array.from(svgRoot.querySelectorAll('text'));
            textElements.sort((a, b) => {
                const ay = parseFloat(a.getAttribute('y') || '0');
                const by = parseFloat(b.getAttribute('y') || '0');
                if (Math.abs(ay - by) > 0.5) return ay - by;
                const ax = parseFloat(a.getAttribute('x') || '0');
                const bx = parseFloat(b.getAttribute('x') || '0');
                return ax - bx;
            });

            if (textElements.length < 2) return svgString;

            const mergedElements = [];
            let currentGroup = [];
            
            const getStyleKey = (el) => {
                let key = (el.getAttribute('font-family') || '') + '|' + 
                          (el.getAttribute('font-size') || '') + '|' + 
                          (el.getAttribute('font-weight') || '') + '|' + 
                          (el.getAttribute('fill') || '');
                const style = el.getAttribute('style') || '';
                return key + '|' + style;
            };

            for (const textEl of textElements) {
                if (currentGroup.length === 0) {
                    currentGroup.push(textEl);
                    continue;
                }
                const lastEl = currentGroup[currentGroup.length - 1];
                const currentY = parseFloat(textEl.getAttribute('y') || '0');
                const lastY = parseFloat(lastEl.getAttribute('y') || '0');
                
                if (getStyleKey(textEl) === getStyleKey(lastEl) && Math.abs(currentY - lastY) < 1.0) {
                    currentGroup.push(textEl);
                } else {
                    mergedElements.push(currentGroup);
                    currentGroup = [textEl];
                }
            }
            if (currentGroup.length > 0) mergedElements.push(currentGroup);

            for (const group of mergedElements) {
                if (group.length > 1) {
                    const firstEl = group[0];
                    let mergedText = firstEl.textContent;
                    group.sort((a, b) => parseFloat(a.getAttribute('x')) - parseFloat(b.getAttribute('x')));
                    
                    for (let i = 1; i < group.length; i++) {
                        const nextEl = group[i];
                        mergedText += ' ' + nextEl.textContent;
                        nextEl.remove();
                    }
                    firstEl.textContent = mergedText.trim();
                }
            }
            return svgRoot.innerHTML;
        }

        function updateDebug(r) {
             if(r.srcCrop) els.debugImg.src = r.srcCrop;
             if(r.blueprint) els.debugBlueprint.innerHTML = r.blueprint;
             els.debugSvg.innerHTML = `<svg width="100%" height="100%" viewBox="0 0 ${r.bpDims.w} ${r.bpDims.h}" style="border:1px solid red">${r.svgContent}</svg>`;
             els.debugLog.textContent = JSON.stringify(r, null, 2);
        }
        
        function switchTab(t) {
             els.workspace.classList.toggle('hidden', t !== 'overlay');
             els.debugContainer.classList.toggle('hidden', t !== 'debug');
             els.debugContainer.classList.toggle('flex', t === 'debug');
             document.getElementById('tab-overlay').classList.toggle('active', t === 'overlay');
             document.getElementById('tab-debug').classList.toggle('active', t === 'debug');
        }
        
        function exportSVG() {
            const w = state.canvas.width; const h = state.canvas.height;
            // Use logical indentation for better data readability
            let out = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n`;
            out += `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">\n`;
            out += `  <rect width="100%" height="100%" fill="white" id="background"/>\n`;
            
            state.regions.forEach(r => { 
                if(!r.svgContent) return;
                
                const x = (r.rect.x * w).toFixed(3);
                const y = (r.rect.y * h).toFixed(3);
                const width = (r.rect.w * w).toFixed(3);
                const height = (r.rect.h * h).toFixed(3);
                
                // Nesting structure: Outer SVG handles positioning (The "Special Bounding Box")
                // FIX: Use bpDims for viewBox to handle implicit scaling
                out += `  <svg x="${x}" y="${y}" width="${width}" height="${height}" viewBox="0 0 ${r.bpDims.w} ${r.bpDims.h}" preserveAspectRatio="none" overflow="visible">\n`;
                
                // Optional: Background for the patch itself, as seen in the user's sample <rect fill="#fff">
                // This ensures the text has a solid background if overlaid on other things.
                out += `    <rect width="100%" height="100%" fill="white" opacity="0" />\n`; 
                
                // Content Layer with transform (Scale removed, only Translate)
                out += `    <g id="content-${r.id}" transform="translate(${r.offset.x},${r.offset.y})">\n`;
                out += `      ${r.svgContent}\n`;
                out += `    </g>\n`;
                out += `  </svg>\n`;
            });
            out += `</svg>`;
            
            const url = URL.createObjectURL(new Blob([out], {type: 'image/svg+xml'}));
            const a = document.createElement('a'); a.href = url; a.download = "scitext.svg"; a.click();
        }

        const setMode = (m) => {
            state.editMode = m;
            els.modeArea.className = m === 'area' ? 'px-2 py-0.5 rounded text-[10px] font-bold transition bg-white shadow-sm text-blue-600' : 'px-2 py-0.5 rounded text-[10px] font-bold transition text-gray-500 hover:text-gray-700';
            els.modeContent.className = m === 'content' ? 'px-2 py-0.5 rounded text-[10px] font-bold transition bg-white shadow-sm text-blue-600' : 'px-2 py-0.5 rounded text-[10px] font-bold transition text-gray-500 hover:text-gray-700';
            els.modeLabel.textContent = m === 'area' ? 'Area Mode' : 'Content Mode';
            els.modeLabel.className = m === 'area' ? 'absolute top-1 right-2 text-[9px] font-bold text-blue-400 uppercase tracking-widest pointer-events-none' : 'absolute top-1 right-2 text-[9px] font-bold text-amber-500 uppercase tracking-widest pointer-events-none';
            els.lblX.textContent = m === 'area' ? 'Pos X' : 'Shift X';
            els.lblY.textContent = m === 'area' ? 'Pos Y' : 'Shift Y';
            els.lblW.textContent = m === 'area' ? 'Width' : 'Eff. W';
            els.lblH.textContent = m === 'area' ? 'Height' : 'Eff. H';
            updatePropertyInputs();
        };

        window.app = { clearSelection: deselect, createRegion: createRegion };
        init();
    </script>
  </body>
</html>
