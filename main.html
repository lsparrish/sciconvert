<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>main.html</title>

    <!-- Libraries -->
    <!-- PDF.js for rendering the scanned document -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
    </script>

    <!-- Marked for Markdown parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <!-- KaTeX for Math rendering -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js"></script>

    <!-- Tailwind for layout (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- html2canvas for DOM screenshots -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
      /* Custom Scrollbar for better aesthetics */
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #f1f1f1; }
      ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #555; }

      body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #e5e7eb; height: 100vh; overflow: hidden; }

      /* Custom Tab Styles */
      .tab-button {
          padding: 0.75rem 1.5rem;
          font-size: 0.875rem;
          font-weight: 600;
          color: #4b5563;
          border-bottom: 2px solid transparent;
          cursor: pointer;
          transition: all 0.1s ease-in-out;
      }
      .tab-button:hover {
          color: #1f2937;
          border-bottom-color: #e5e7eb;
      }
      .tab-button.active {
          color: #2563eb;
          border-bottom-color: #2563eb;
          background-color: #fff;
      }

      /* PDF Canvas Styles */
      #pdf-render-container {
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1兒童 size: 10px;
          background-color: #525659;
          overflow: auto;
          display: flex;
          justify-content: center;
          align-items: flex-start;
          padding: 20px;
      }

      canvas {
          box-shadow: 0 0 10px rgba(0,0,0,0.5);
          max-width: none;
      }

      /* Editor Styles */
      .editor-textarea {
          font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
          line-height: 1.6;
          resize: none;
      }

      /* Preview Styles */
      .preview-content {
          line-height: 1.6;
          text-align: justify;
      }

      /* Font Classes */
      .font-serif { font-family: 'Times New Roman', Times, serif; }
      .font-sans { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; }
      .font-mono { font-family: 'Courier New', Courier, monospace; }

      .two-columns { column-count: 2; column-gap: 2rem; }

      /* Loader */
      .loader {
          border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
          width: 30px; height: 30px; animation: spin 1s linear infinite;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

      /* Selection Box Styles */
      #selection-box {
          border: 2px dashed #2563eb;
          background-color: rgba(37, 99, 235, 0.1);
          position: absolute;
          pointer-events: none; /* Let events pass through to layer */
          display: none;
          z-index: 50;
      }

      /* Orange outline for Editing Mode */
      #selection-box.edit-mode {
          border-color: #f97316; /* Orange-500 */
          background-color: rgba(249, 115, 22, 0.1);
      }

      /* OVERLAY HEURISTIC RESET: Ensure AI/HTML content has no default margins */
      #overlay-html-layer * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
          /* STRICT RESET: 1.0 line height matches print closer than 1.15 */
          line-height: 1.0;
      }
      #overlay-html-layer div {
          /* Ensure the containers themselves don't collapse */
          box-sizing: border-box;
      }

      /* Debug View Overlay */
      #debug-vision-overlay {
          position: absolute;
          z-index: 99999;
          border: 2px solid red;
          background: rgba(255, 0, 0, 0.1);
          pointer-events: none;
          display: none;
      }
      #debug-vision-label {
          position: absolute;
          top: -20px;
          left: 0;
          background: red;
          color: white;
          font-size: 10px;
          padding: 2px 4px;
          font-weight: bold;
      }

      /* --- Context Menu Styles (Simplified/Stripped) --- */
      #context-menu {
          /* Hiding context menu logic since we are transitioning to action bar */
          display: none !important;
      }

      /* --- Action Bar Styles (Selection) --- */
      #selection-action-bar {
          position: fixed;
          z-index: 10000;
          display: none;
          transform-origin: top center;
          animation: fadeIn 0.1s ease-out;
      }

      /* --- Action Bar Styles (Edit) --- */
      #edit-action-bar {
          z-index: 0;
          /* Position and width managed by Tailwind classes in HTML: w-full shrink-0 */
      }

      .disabled-bar {
          opacity: 0.5;
          pointer-events: none;
          transition: opacity 0.2s ease-in-out;
      }

      .action-btn {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 0.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          transition: all 0.15s;
          color: #4b5563;
          background: #f9fafb;
          border: 1px solid #f3f4f6;
      }

      .action-btn:hover {
          background-color: #f3f4f6;
          color: #1f2937;
          transform: translateY(-1px);
      }

      .action-btn svg {
          width: 1.25rem;
          height: 1.25rem;
          margin-bottom: 0.1rem;
      }

      .action-btn span {
          font-size: 0.65rem;
          font-weight: 600;
      }

      @keyframes fadeIn {
          from { opacity: 0; transform: scale(0.95) translateY(-5px); }
          to { opacity: 1; transform: scale(1) translateY(0); }
      }
    </style>
  </head>
  <body class="flex flex-col h-screen">
    <!-- Header / Toolbar -->
    <header
      class="bg-gray-800 text-white p-3 flex justify-between items-center shadow-md z-10 shrink-0"
    >
      <div class="flex items-center gap-4">
        <h1 class="text-xl font-bold tracking-wider mr-4">
          SciText <span class="text-blue-400">Digitizer</span>
        </h1>

        <div class="relative">
          <input
            type="file"
            id="pdf-upload"
            accept="application/pdf"
            class="hidden"
          />
          <label
            for="pdf-upload"
            class="cursor-pointer bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          >
            <svg
              class="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
              ></path>
            </svg>
            Load PDF
          </label>
        </div>

        <div
          class="flex items-center bg-gray-700 rounded px-2 py-1 gap-2"
          id="pdf-nav-controls"
          style="display: none"
        >
          <button
            id="prev-page"
            class="hover:text-blue-300 p-1 disabled:opacity-50"
            title="Previous Page"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M15 19l-7-7 7-7"
              ></path>
            </svg>
          </button>
          <span class="text-sm font-mono"
            >Page <span id="page-num">0</span> /
            <span id="page-count">0</span></span
          >
          <button
            id="next-page"
            class="hover:text-blue-300 p-1 disabled:opacity-50"
            title="Next Page"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M9 5l7 7-7 7"
              ></path>
            </svg>
          </button>
        </div>

        <div
          class="flex items-center bg-gray-700 rounded px-2 py-1 gap-2"
          id="pdf-zoom-controls"
          style="display: none"
        >
          <button
            id="zoom-out"
            class="hover:text-blue-300 p-1"
            title="Zoom Out"
          >
            -
          </button>
          <span id="zoom-level" class="text-xs font-mono w-12 text-center"
            >100%</span
          >
          <button id="zoom-in" class="hover:text-blue-300 p-1" title="Zoom In">
            +
          </button>
        </div>
      </div>

      <div class="flex items-center gap-4">
        <span
          id="restore-badge"
          class="hidden bg-amber-100 text-amber-800 text-xs font-medium px-2.5 py-0.5 rounded border border-amber-400"
        >
          Restored: <span id="restored-filename" class="font-bold"></span>
        </span>

        <button
          id="export-md"
          class="bg-green-600 hover:bg-green-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          title="Download Transcription"
        >
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
            ></path>
          </svg>
          Export
        </button>

        <button
          id="fullscreen-toggle"
          class="bg-purple-600 hover:bg-purple-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          title="Toggle Fullscreen Mode"
        >
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 8V4m0 0h4M4 4l5 5m11-5v4m0 0h-4m4 0l-5-5M4 16v4m0 0h4M4 20l5-5m11 5v-4m0 0h-4m4 0l-5 5"
            ></path>
          </svg>
          Full
        </button>
      </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 flex flex-col overflow-hidden relative">
      <!-- Tab Bar -->
      <div
        id="main-tab-bar"
        class="flex bg-gray-50 border-b border-gray-200 shadow-inner shrink-0"
      >
        <button id="tab-source" class="tab-button">Source</button>
        <button id="tab-overlay" class="tab-button active">
          Overlay Editor
        </button>
        <button id="tab-write" class="tab-button">Markdown</button>
        <button id="tab-preview" class="tab-button">Render</button>
      </div>

      <div
        id="empty-state"
        class="absolute inset-0 flex flex-col items-center justify-center bg-gray-100 z-50 text-gray-500"
      >
        <svg
          class="w-24 h-24 mb-4 text-gray-300"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="1.5"
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          ></path>
        </svg>
        <h2 class="text-2xl font-bold mb-2">No Document Loaded</h2>
        <p class="mb-6">Upload a PDF to begin digitizing.</p>
      </div>

      <div id="workspace" class="flex-1 overflow-hidden relative bg-white">
        <!-- 1. Source (PDF) Container -->
        <div
          id="source-container"
          class="absolute inset-0 flex flex-col hidden"
        >
          <div id="pdf-render-container" class="w-full h-full">
            <canvas id="the-canvas"></canvas>
          </div>
          <div
            id="pdf-loader"
            class="absolute inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center hidden"
          >
            <div class="loader mb-2"></div>
            <span class="text-white text-sm font-semibold"
              >Rendering Page...</span
            >
          </div>
        </div>

        <!-- 2. Overlay Split View Container -->
        <div id="overlay-container" class="absolute inset-0 flex hidden">
          <!-- Left: Editor -->
          <div
            class="w-1/3 h-full flex flex-col border-r border-gray-300 z-20 bg-white shadow-xl"
          >
            <div
              class="bg-gray-100 px-4 py-2 text-xs font-bold text-gray-500 border-b flex justify-between"
            >
              <span id="editor-title">OVERLAY HTML</span>
              <div class="flex items-center gap-4">
                <span id="ai-status" class="text-blue-600 hidden"
                  >AI Processing...</span
                >
                <span
                  id="show-ai-log"
                  class="text-gray-500 hover:text-gray-900 cursor-pointer font-semibold hidden"
                  onclick="toggleAiLog()"
                >
                  [AI Log]
                </span>
              </div>
            </div>
            <textarea
              id="overlay-html-input"
              class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-gray-800 bg-gray-50 text-xs"
              placeholder="<!-- Select a region on the right to digitize -->"
            ></textarea>

            <!-- Action Bar for Editing a selected DIV (Always Visible, toggled enabled/disabled) -->
            <div
              id="edit-action-bar"
              class="w-full shrink-0 flex border-t border-gray-200 bg-gray-50 p-2 overflow-x-auto disabled-bar"
            >
              <!-- Smart Style (AI) Group -->
              <button
                id="btn-ai-replica-edit"
                class="action-btn text-blue-600 hover:text-blue-700"
                onclick="runAiReplica()"
                title="AI Replica Style Match"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                  ></path>
                </svg>
                <span>AI Style</span>
              </button>
              <button
                id="btn-ai-font-edit"
                class="action-btn text-purple-600 hover:text-purple-700"
                onclick="runAiFont()"
                title="AI Match Font Only"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                  ></path>
                </svg>
                <span>AI Font</span>
              </button>
              <button
                id="btn-ai-text-edit"
                class="action-btn text-green-600 hover:text-green-700"
                onclick="runAiText()"
                title="AI Transcribe Text Only"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 6h16M4 12h16M4 18h7"
                  ></path>
                </svg>
                <span>AI Text</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <!-- Typography Group -->
              <button
                class="action-btn font-serif text-sm h-auto w-10 text-gray-700 hover:text-black"
                onclick="updateStyle('font-family', 'Times New Roman, serif')"
                title="Serif"
              >
                T
              </button>
              <button
                class="action-btn font-sans text-sm h-auto w-10 text-gray-700 hover:text-black"
                onclick="updateStyle('font-family', 'Arial, sans-serif')"
                title="Sans"
              >
                S
              </button>
              <button
                class="action-btn text-gray-700 hover:text-black"
                onclick="updateStyle('text-align', 'justify')"
                title="Justify Text"
              >
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M3 6h18M3 12h18M3 18h18" />
                </svg>
                <span>Justify</span>
              </button>
              <button
                class="action-btn text-gray-700 hover:text-black"
                onclick="updateStyle('font-weight', 'bold')"
                title="Bold"
              >
                <span class="text-sm font-bold">B</span>
                <span>Bold</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <!-- Actions Group -->
              <button
                class="action-btn text-indigo-600 hover:text-indigo-700"
                onclick="manualSmartFit()"
                title="Auto-size text to fill box"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
                  ></path>
                </svg>
                <span>Fit Text</span>
              </button>
              <button
                id="btn-clear-styles-edit"
                class="action-btn text-amber-600 hover:text-amber-700"
                onclick="clearStyles()"
                title="Remove all styling"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"
                  ></path>
                </svg>
                <span>Clear CSS</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <button
                id="btn-delete-div-edit"
                class="action-btn text-red-600 hover:text-red-700"
                onclick="deleteDiv()"
                title="Delete Selection"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                  ></path>
                </svg>
                <span>Delete</span>
              </button>
            </div>
          </div>

          <!-- Right: Preview (Superimposed) -->
          <div class="w-2/3 h-full flex flex-col relative bg-gray-500">
            <!-- Overlay Toolbar -->
            <div
              class="bg-gray-200 p-2 flex gap-4 border-b border-gray-400 shrink-0 z-30 justify-center text-sm text-gray-700 shadow-sm"
            >
              <label
                class="flex items-center gap-2 cursor-pointer font-semibold hover:text-black"
              >
                <input
                  type="checkbox"
                  id="chk-show-source"
                  checked
                  class="rounded text-blue-600 focus:ring-blue-500"
                />
                Show Source PDF
              </label>
              <div class="w-px h-4 bg-gray-400 my-auto"></div>
              <label
                class="flex items-center gap-2 cursor-pointer font-semibold hover:text-black"
              >
                <input
                  type="checkbox"
                  id="chk-show-overlay"
                  checked
                  class="rounded text-blue-600 focus:ring-blue-500"
                />
                Show HTML Overlay
              </label>
            </div>

            <!-- Scroller -->
            <div
              id="overlay-scroller"
              class="flex-1 overflow-auto flex justify-center p-8 select-none relative"
            >
              <!-- Wrapper matches Canvas Size -->
              <div
                id="overlay-wrapper"
                class="relative shadow-2xl origin-top bg-white"
              >
                <!-- Mount point for Canvas when in this view -->
                <div
                  id="overlay-canvas-mount"
                  class="transition-opacity duration-200"
                ></div>

                <!-- HTML Layer (Rendered Content) -->
                <div
                  id="overlay-html-layer"
                  class="absolute inset-0 overflow-hidden pointer-events-none z-10 transition-opacity duration-200"
                ></div>

                <!-- Selection Layer (Interactive) -->
                <div
                  id="selection-layer"
                  class="absolute inset-0 z-20 cursor-crosshair"
                ></div>

                <!-- Visual Selection Box -->
                <div id="selection-box"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- 3. Editor Container (Write Tab - Markdown) -->
        <div
          id="editor-container-md"
          class="absolute inset-0 flex flex-col hidden"
        >
          <textarea
            id="markdown-input"
            class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-gray-800 bg-gray-50 text-sm"
            placeholder="# Transcription Area"
          ></textarea>
        </div>

        <!-- 4. Preview Container (Render Tab) -->
        <div
          id="preview-container"
          class="absolute inset-0 overflow-y-auto p-8 hidden bg-white"
        >
          <div
            id="preview-output"
            class="preview-content font-serif text-gray-900 max-w-none"
          ></div>
        </div>
      </div>
    </main>

    <!-- Action Bar (For new selections) -->
    <div
      id="selection-action-bar"
      class="bg-gray-800 text-white rounded-lg shadow-2xl flex items-center p-1.5 gap-2 border border-gray-700"
    >
      <button id="btn-digitize" class="action-btn" title="Digitize Text (AI)">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          ></path>
        </svg>
        <span>Digitize</span>
      </button>
      <button id="btn-copy-image" class="action-btn" title="Extract Image">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
          ></path>
        </svg>
        <span>Image</span>
      </button>
      <button id="btn-create-div" class="action-btn" title="Empty Box">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z"
          ></path>
        </svg>
        <span>Empty</span>
      </button>

      <div class="w-px h-8 bg-gray-600 mx-0.5"></div>

      <button
        id="btn-close-action"
        class="action-btn text-gray-400 hover:text-red-400"
        title="Close"
        onclick="closeSelection()"
      >
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"
          ></path>
        </svg>
        <span>Cancel</span>
      </button>
    </div>

    <!-- Context Menu (hidden) -->
    <div
      id="context-menu"
      class="flex flex-col bg-white border border-gray-300 shadow-lg"
      style="
        position: fixed;
        z-index: 9999;
        display: none;
        min-width: 230px;
        border-radius: 4px;
        overflow: hidden;
      "
    >
      <!-- Content removed, using edit-action-bar instead -->
    </div>

    <!-- Debug Vision Overlay Mount -->
    <div id="debug-vision-overlay">
      <div id="debug-vision-label">AI VISION (html2canvas)</div>
      <img
        id="debug-vision-img"
        style="width: 100%; height: 100%; object-fit: contain"
      />
    </div>

    <script type="module">
      const apiKey = ""; // Runtime key
      const STORAGE_KEY = "scitext_transcriptions";
      const STORAGE_KEY_LAST_PAGE = "scitext_last_page_num";
      const STORAGE_KEY_FILENAME = "scitext_last_filename";

      let transcriptionData = {};
      let aiQueryLog = []; // Global storage for AI request/response logs

      // --- State ---
      const state = {
        pdfDoc: null,
        pageNum: 1,
        pageRendering: false,
        pageNumPending: null,
        scale: 1.2,
        canvas: document.getElementById("the-canvas"),
        ctx: document.getElementById("the-canvas").getContext("2d"),
        activeTab: "overlay",
        fontClass: "font-serif",
        isAuthReady: false,
        saveTimeout: null,

        // Selection State
        isSelecting: false,
        selectionStart: { x: 0, y: 0 },
        selectionEnd: { x: 0, y: 0 },
        selectionRect: null,

        // Interaction Target
        targetDivId: null,

        isLogActive: false, // New state variable
      };

      // --- IndexedDB Utils ---
      const DB_NAME = "SciTextDB";
      const DB_VERSION = 1;
      const STORE_NAME = "files";

      function openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME);
            }
          };
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function savePDFToDB(blob) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(blob, "currentPdf"); // Store with fixed key
          request.onsuccess = () => resolve();
          request.onerror = (e) => reject(e);
        });
      }

      async function getPDFFromDB() {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get("currentPdf");
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (e) => reject(e);
        });
      }

      // --- DOM Elements ---
      const els = {
        upload: document.getElementById("pdf-upload"),
        emptyState: document.getElementById("empty-state"),
        pdfLoader: document.getElementById("pdf-loader"),
        navControls: document.getElementById("pdf-nav-controls"),
        zoomControls: document.getElementById("pdf-zoom-controls"),
        prevBtn: document.getElementById("prev-page"),
        nextBtn: document.getElementById("next-page"),
        pageNumSpan: document.getElementById("page-num"),
        pageCountSpan: document.getElementById("page-count"),
        zoomInBtn: document.getElementById("zoom-in"),
        zoomOutBtn: document.getElementById("zoom-out"),
        zoomLevelSpan: document.getElementById("zoom-level"),
        previewOutput: document.getElementById("preview-output"),
        previewContainer: document.getElementById("preview-container"),

        sourceContainer: document.getElementById("source-container"),
        overlayContainer: document.getElementById("overlay-container"),
        editorContainerMd: document.getElementById("editor-container-md"),
        overlayScroller: document.getElementById("overlay-scroller"),

        pdfRenderContainer: document.getElementById("pdf-render-container"),
        overlayCanvasMount: document.getElementById("overlay-canvas-mount"),
        overlayWrapper: document.getElementById("overlay-wrapper"),
        overlayHtmlLayer: document.getElementById("overlay-html-layer"),
        selectionLayer: document.getElementById("selection-layer"),
        selectionBox: document.getElementById("selection-box"),
        contextMenu: document.getElementById("context-menu"),
        actionBar: document.getElementById("selection-action-bar"),
        editActionBar: document.getElementById("edit-action-bar"),
        theCanvas: document.getElementById("the-canvas"),

        markdownInput: document.getElementById("markdown-input"),
        overlayHtmlInput: document.getElementById("overlay-html-input"),

        tabSource: document.getElementById("tab-source"),
        tabWrite: document.getElementById("tab-write"),
        tabOverlay: document.getElementById("tab-overlay"),
        tabPreview: document.getElementById("tab-preview"),

        fontSelect: document.getElementById("font-select"),
        exportBtn: document.getElementById("export-md"),
        fullscreenBtn: document.getElementById("fullscreen-toggle"),

        btnDigitize: document.getElementById("btn-digitize"),
        btnCopyImage: document.getElementById("btn-copy-image"),
        btnCreateDiv: document.getElementById("btn-create-div"),
        aiStatus: document.getElementById("ai-status"),

        chkShowSource: document.getElementById("chk-show-source"),
        chkShowOverlay: document.getElementById("chk-show-overlay"),
        restoreBadge: document.getElementById("restore-badge"),
        restoredFilename: document.getElementById("restored-filename"),

        menuGroupDiv: document.getElementById("menu-group-div"),

        // Debug
        debugOverlay: document.getElementById("debug-vision-overlay"),
        debugImg: document.getElementById("debug-vision-img"),

        // New AI Log Elements
        editorTitle: document.getElementById("editor-title"),
        showAiLog: document.getElementById("show-ai-log"),
      };

      // --- Persistence ---
      function initPersistence() {
        try {
          const storedData = localStorage.getItem(STORAGE_KEY);
          if (storedData) transcriptionData = JSON.parse(storedData);
        } catch (error) {
          console.error("Error loading text data:", error);
        }

        state.isAuthReady = true;
        restoreSessionFromDB();

        // Initial bar state check
        updateEditBarState();
      }

      async function restoreSessionFromDB() {
        try {
          const pdfBlob = await getPDFFromDB();
          if (pdfBlob) {
            const lastPageNum = localStorage.getItem(STORAGE_KEY_LAST_PAGE);
            const lastFilename = localStorage.getItem(STORAGE_KEY_FILENAME);
            if (lastFilename) {
              els.restoredFilename.textContent = lastFilename;
              els.restoreBadge.classList.remove("hidden");
            }
            const arrayBuffer = await pdfBlob.arrayBuffer();
            loadPDF(arrayBuffer, lastPageNum ? parseInt(lastPageNum) : 1);
          }
        } catch (error) {
          console.log("No previous session found or error loading DB:", error);
        }
      }

      function loadPDF(data, pageNum = 1) {
        pdfjsLib
          .getDocument(data)
          .promise.then(function (pdfDoc_) {
            state.pdfDoc = pdfDoc_;
            state.pageNum = pageNum;
            els.pageCountSpan.textContent = state.pdfDoc.numPages;
            els.emptyState.classList.add("hidden");
            els.navControls.style.display = "flex";
            els.zoomControls.style.display = "flex";
            renderPage(state.pageNum);
          })
          .catch((e) => {
            console.error("Error loading PDF data:", e);
          });
      }

      function loadContentForCurrentPage(forcePreviewUpdate = false) {
        const pageNum = state.pageNum;
        const mdKey = `md_page_${pageNum}`;
        const overlayKey = `overlay_page_${pageNum}`;

        if (els.markdownInput.value !== (transcriptionData[mdKey] || "")) {
          els.markdownInput.value = transcriptionData[mdKey] || "";
        }
        if (
          els.overlayHtmlInput.value !== (transcriptionData[overlayKey] || "")
        ) {
          els.overlayHtmlInput.value = transcriptionData[overlayKey] || "";
        }
        if (forcePreviewUpdate) {
          updatePreview();
          updateOverlayPreview();
        }
        // Ensure the correct content is shown if log is not active
        if (!state.isLogActive) {
          els.overlayHtmlInput.value = transcriptionData[overlayKey] || "";
        }
      }

      function saveContent() {
        if (!state.isAuthReady) return;
        if (state.isLogActive) return; // Do not save log content

        clearTimeout(state.saveTimeout);
        state.saveTimeout = setTimeout(() => {
          transcriptionData[`md_page_${state.pageNum}`] =
            els.markdownInput.value;
          transcriptionData[`overlay_page_${state.pageNum}`] =
            els.overlayHtmlInput.value;
          localStorage.setItem(STORAGE_KEY, JSON.stringify(transcriptionData));
          localStorage.setItem(STORAGE_KEY_LAST_PAGE, state.pageNum);
        }, 1000);
      }

      // --- PDF Rendering ---
      function renderPage(num) {
        state.pageRendering = true;
        els.pdfLoader.classList.remove("hidden");
        saveContent();

        state.pdfDoc.getPage(num).then(function (page) {
          var viewport = page.getViewport({ scale: state.scale });
          state.canvas.height = viewport.height;
          state.canvas.width = viewport.width;

          var renderTask = page.render({
            canvasContext: state.ctx,
            viewport: viewport,
          });

          renderTask.promise.then(function () {
            state.pageRendering = false;
            els.pdfLoader.classList.add("hidden");
            updateOverlayWrapperSize();
            loadContentForCurrentPage(true);
            if (state.pageNumPending !== null) {
              renderPage(state.pageNumPending);
              state.pageNumPending = null;
            }
          });
        });

        els.pageNumSpan.textContent = num;
        els.prevBtn.disabled = num <= 1;
        els.nextBtn.disabled = num >= state.pdfDoc.numPages;
      }

      function updateOverlayWrapperSize() {
        if (els.theCanvas) {
          els.overlayWrapper.style.width = els.theCanvas.width + "px";
          els.overlayWrapper.style.height = els.theCanvas.height + "px";
        }
      }

      function queueRenderPage(num) {
        state.pageRendering ? (state.pageNumPending = num) : renderPage(num);
      }

      // --- Helpers ---

      /**
       * Extracts a base64 string from a given rect on the current canvas.
       */
      function extractImageSnippet(pixelRect) {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = pixelRect.width;
        tempCanvas.height = pixelRect.height;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.drawImage(
          state.canvas,
          pixelRect.x,
          pixelRect.y,
          pixelRect.width,
          pixelRect.height,
          0,
          0,
          pixelRect.width,
          pixelRect.height,
        );
        return tempCanvas.toDataURL("image/png").split(",")[1];
      }

      /**
       * Helper to clone the element and strip non-internal CSS properties
       * before sending the HTML string to the AI.
       */
      function getDivInternalState(divElement) {
        const style = divElement.getAttribute("style") || "";

        // Define positional/layout styles we want to remove from the AI's view
        const positionalProps = [
          "position",
          "left",
          "top",
          "width",
          "height",
          "background",
          "overflow",
          "overflow-wrap",
          "z-index",
          "margin",
        ];

        let cleanStyle = style
          .split(";")
          .map((s) => s.trim())
          .filter((s) => {
            if (!s) return false;
            const prop = s.split(":")[0].trim().toLowerCase();
            // Keep the property ONLY if it is NOT a positional property
            return !positionalProps.some((p) => prop.startsWith(p));
          })
          .join("; ");

        return {
          id: divElement.id,
          content: divElement.innerHTML,
          internalStyleString: cleanStyle,
        };
      }

      // --- AI Log Logic ---
      function updateLogVisibility() {
        if (aiQueryLog.length > 0) {
          els.showAiLog.classList.remove("hidden");
        }
      }

      function renderAiLog() {
        let logContent = `// === AI Query Log (${aiQueryLog.length} entries - Latest First) ===\n\n`;

        // Note: Log entries are added to the start of the array (unshift), so map in order.
        aiQueryLog.forEach((entry, index) => {
          const status = entry.success ? "SUCCESS" : "ERROR";
          logContent += `// [${index + 1}] ${entry.timestamp} - Status: ${status}\n`;
          logContent += `// PROMPT:\n${entry.prompt}\n\n`;
          logContent += `// RESPONSE:\n${entry.response}\n\n`;
          logContent += "-------------------------------------------------\n\n";
        });

        return logContent;
      }

      window.toggleAiLog = function () {
        state.isLogActive = !state.isLogActive;

        if (state.isLogActive) {
          // Show Log
          els.overlayHtmlInput.value = renderAiLog();
          els.overlayHtmlInput.readOnly = true;
          els.editorTitle.textContent = "AI LOG";
          els.showAiLog.textContent = "[Show HTML]";
          els.editActionBar.classList.add("disabled-bar"); // Always disable bar when in log view
        } else {
          // Show HTML
          loadContentForCurrentPage(false); // Reload current page HTML content
          els.overlayHtmlInput.readOnly = false;
          els.editorTitle.textContent = "OVERLAY HTML";
          els.showAiLog.textContent = "[AI Log]";
          updateEditBarState(); // Re-evaluate bar state based on cursor
        }
      };

      /**
       * Generic Gemini API Call Wrapper
       * UPDATED: Robust Array Handling for Images and Logging
       */
      async function queryGemini(prompt, images) {
        els.aiStatus.style.display = "inline";
        els.aiStatus.textContent = "AI Processing...";

        // 1. Prepare Log Entry (strictly append-only)
        const logEntry = {
          timestamp: new Date().toLocaleTimeString(),
          prompt: prompt,
          response: "Awaiting response...",
          success: false,
        };
        aiQueryLog.unshift(logEntry); // Add to start of log
        updateLogVisibility(); // Ensure log button is visible
        if (state.isLogActive) toggleAiLog(); // Refresh log view if active

        let resultText = "";

        try {
          // Construct the prompt parts
          const parts = [{ text: prompt }];

          if (Array.isArray(images)) {
            // Multiple images
            images.forEach((img) => {
              parts.push({ inlineData: { mimeType: "image/png", data: img } });
            });
          } else if (images) {
            // Single image
            parts.push({ inlineData: { mimeType: "image/png", data: images } });
          }

          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                contents: [
                  {
                    role: "user",
                    parts: parts,
                  },
                ],
              }),
            },
          );

          if (!response.ok)
            throw new Error(
              `API request failed with status: ${response.status}`,
            );
          const data = await response.json();

          resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;

          els.aiStatus.textContent = "Done!";
          setTimeout(() => (els.aiStatus.style.display = "none"), 2000);

          // 2. Update Log on Success
          logEntry.response = resultText || "No text response received.";
          logEntry.success = true;
          if (state.isLogActive) toggleAiLog();

          return resultText;
        } catch (error) {
          console.error("AI Error:", error);
          els.aiStatus.textContent = "Error!";
          setTimeout(() => (els.aiStatus.style.display = "none"), 2000);

          // 2. Update Log on Error
          logEntry.response = `Error: ${error.message}`;
          logEntry.success = false;
          if (state.isLogActive) toggleAiLog();

          throw error;
        }
      }

      function parseAIJson(text) {
        try {
          // Try to find a JSON block first
          const jsonMatch = text.match(/\{[\s\S]*\}/);
          if (jsonMatch) return JSON.parse(jsonMatch[0]);
          return JSON.parse(text);
        } catch (e) {
          return null;
        }
      }

      // --- DOM Modification Helpers (Non-AI) ---

      // 1. Unified Parser for DOM Updates (Robust)
      function updateDOMWithCallback(callback) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(
          `<body>${els.overlayHtmlInput.value}</body>`,
          "text/html",
        );

        if (callback(doc)) {
          // If modification happened
          els.overlayHtmlInput.value = doc.body.innerHTML;
          updateOverlayPreview();
          saveContent();
          return true;
        }
        return false;
      }

      window.updateStyle = function (property, value) {
        if (!state.targetDivId) return;

        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            target.style[property] = value;
            return true;
          }
          return false;
        });
      };

      window.deleteDiv = function () {
        if (!state.targetDivId) return;
        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            target.remove();
            state.targetDivId = null;
            window.closeSelection(); // Hide the box and disable edit bar
            return true;
          }
          return false;
        });
      };

      window.clearStyles = function () {
        if (!state.targetDivId) return;
        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            // Keep positioning, clear typography
            const left = target.style.left;
            const top = target.style.top;
            const width = target.style.width;
            const height = target.style.height;

            target.removeAttribute("style");

            // Restore Layout
            target.style.position = "absolute";
            target.style.left = left;
            target.style.top = top;
            target.style.width = width;
            target.style.height = height;
            target.style.background = "rgba(255,255,255,0.8)";
            target.style.padding = "0px";
            target.style.margin = "0px";
            target.style.overflowWrap = "break-word";
            target.style.overflow = "hidden";
            target.style.lineHeight = "1.0";
            return true;
          }
          return false;
        });
      };

      window.snapLayout = function (type) {
        if (!state.targetDivId) return;

        if (type === "page-width") {
          window.updateStyle("left", "0%");
          window.updateStyle("width", "100%");
        } else if (type === "margin-standard") {
          // Simulate ~1 inch margins (approx 10%)
          window.updateStyle("left", "10%");
          window.updateStyle("width", "80%");
        } else if (type === "center") {
          window.updateStyle("left", "15%");
          window.updateStyle("width", "70%");
        }
      };

      window.manualSmartFit = function () {
        if (!state.targetDivId) return;
        smartFitText(state.targetDivId);
      };

      // --- Debug Vision Logic (New) ---
      window.showDebugView = async function () {
        if (!state.targetDivId) return;
        els.editActionBar.classList.add("disabled-bar"); // Hide edit bar temporarily

        const divEl = document.getElementById(state.targetDivId);
        if (!divEl) return;

        // Setup Overlay Position
        const rect = divEl.getBoundingClientRect();

        els.debugOverlay.style.left = rect.left + "px";
        els.debugOverlay.style.top = rect.top + "px";
        els.debugOverlay.style.width = rect.width + "px";
        els.debugOverlay.style.height = rect.height + "px";
        els.debugOverlay.style.display = "block";

        els.debugImg.src = ""; // Clear previous

        try {
          const canvas = await html2canvas(divEl, {
            backgroundColor: "#ffffff", // Force white to match paper
            scale: 2,
            logging: false,
            useCORS: true,
            allowTaint: true,
          });

          els.debugImg.src = canvas.toDataURL();

          // Auto hide after 3 seconds
          setTimeout(() => {
            els.debugOverlay.style.display = "none";
            els.editActionBar.classList.remove("disabled-bar"); // Restore edit bar state
          }, 3000);
        } catch (e) {
          console.error("Debug capture failed", e);
          els.debugOverlay.style.display = "none";
          els.editActionBar.classList.remove("disabled-bar"); // Restore edit bar state on error
        }
      };

      // --- Selection & Interaction Logic ---

      // 1. Shared Logic to Activate Edit Mode for a Div
      function activateDivEditMode(divElement, clickEvent = null) {
        if (!divElement) return;
        state.targetDivId = divElement.id;

        // Hide non-editing bars
        els.actionBar.style.display = "none";
        els.contextMenu.style.display = "none";

        // Enable the Edit Action Bar (which is always visible)
        els.editActionBar.classList.remove("disabled-bar");

        // Calculate Position
        const cw = els.theCanvas.width;
        const ch = els.theCanvas.height;
        const l = (parseFloat(divElement.style.left) / 100) * cw;
        const t = (parseFloat(divElement.style.top) / 100) * ch;
        const w = (parseFloat(divElement.style.width) / 100) * cw;
        const h = (parseFloat(divElement.style.height) / 100) * ch;

        // Draw Box
        els.selectionBox.style.left = l + "px";
        els.selectionBox.style.top = t + "px";
        els.selectionBox.style.width = w + "px";
        els.selectionBox.style.height = h + "px";
        els.selectionBox.style.display = "block";
        els.selectionBox.classList.add("edit-mode");

        // Auto Scroll to view if offscreen (only if in overlay view)
        if (state.activeTab === "overlay") {
          divElement.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      }

      // Helper: Get Div ID from Editor Cursor
      function getTargetDivIdFromCursor() {
        const cursor = els.overlayHtmlInput.selectionStart;
        const text = els.overlayHtmlInput.value;
        let openIndex = -1;
        let balance = 0;

        for (let i = cursor - 1; i >= 0; i--) {
          if (text.substring(i, i + 4) === "<div") {
            if (balance === 0) {
              openIndex = i;
              break;
            }
            balance--;
          } else if (text.substring(i, i + 5) === "/div>") {
            balance++;
          }
        }

        if (openIndex !== -1) {
          const tagEnd = text.indexOf(">", openIndex);
          if (tagEnd !== -1) {
            const tagContent = text.substring(openIndex, tagEnd);
            const match = tagContent.match(/id=["']([^"']+)["']/);
            return match ? match[1] : null;
          }
        }
        return null;
      }

      // NEW: Function to manage the state of the edit bar
      function updateEditBarState() {
        // If log is active, keep the bar disabled
        if (state.isLogActive) {
          els.editActionBar.classList.add("disabled-bar");
          return;
        }

        const divId = getTargetDivIdFromCursor();

        if (divId) {
          els.editActionBar.classList.remove("disabled-bar");
          state.targetDivId = divId; // Set target ID immediately on cursor focus
        } else {
          els.editActionBar.classList.add("disabled-bar");
          state.targetDivId = null;
          els.selectionBox.style.display = "none"; // Also hide the box when cursor leaves the div
          els.selectionBox.classList.remove("edit-mode");
        }
      }

      // 2. Editor Interaction (Listeners)
      els.overlayHtmlInput.addEventListener("input", updateEditBarState);
      els.overlayHtmlInput.addEventListener("click", updateEditBarState);
      els.overlayHtmlInput.addEventListener("keyup", updateEditBarState); // Ensure it catches arrow key movement

      // Right click on editor to trigger action bar (Kept as a fallback, but primary activation is left click on canvas)
      els.overlayHtmlInput.addEventListener("contextmenu", (e) => {
        if (state.isLogActive) return; // Ignore input when log is active

        const divId = getTargetDivIdFromCursor();
        if (divId) {
          const divEl = document.getElementById(divId);
          if (divEl) {
            e.preventDefault(); // Stop native menu
            // Use left-click activation logic for visual feedback
            activateDivEditMode(divEl, e);
          }
        }
      });

      // 3. Mouse Interaction (Canvas)
      function getPointerPos(e) {
        const rect = els.selectionLayer.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      // Context Menu Handler (Right Click) - REMOVED - Unified interaction is in mouseup
      // els.selectionLayer.addEventListener('contextmenu', (e) => { ... });

      els.selectionLayer.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;

        // Hide non-editing bars
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";
        els.editActionBar.classList.add("disabled-bar"); // Disable edit bar during potential selection

        state.isSelecting = true;
        state.selectionStart = getPointerPos(e);
        els.selectionBox.style.display = "block";
        els.selectionBox.style.width = "0px";
        els.selectionBox.style.height = "0px";
        els.selectionBox.classList.remove("edit-mode"); // Always start as new selection mode
      });

      els.selectionLayer.addEventListener("mousemove", (e) => {
        if (!state.isSelecting) return;
        const currentPos = getPointerPos(e);
        const x = Math.min(state.selectionStart.x, currentPos.x);
        const y = Math.min(state.selectionStart.y, currentPos.y);
        const width = Math.abs(currentPos.x - state.selectionStart.x);
        const height = Math.abs(currentPos.y - state.selectionStart.y);

        els.selectionBox.style.left = x + "px";
        els.selectionBox.style.top = y + "px";
        els.selectionBox.style.width = width + "px";
        els.selectionBox.style.height = height + "px";
      });

      els.selectionLayer.addEventListener("mouseup", (e) => {
        if (!state.isSelecting) return;
        state.isSelecting = false;

        const currentPos = getPointerPos(e);
        const width = Math.abs(currentPos.x - state.selectionStart.x);
        const height = Math.abs(currentPos.y - state.selectionStart.y);

        // 1. CHECK FOR CLICK ON EXISTING DIV (UNIFIED LEFT-CLICK ACTIVATION)
        const elements = document.elementsFromPoint(e.clientX, e.clientY);
        const clickedDiv = elements.find(
          (el) =>
            el.parentElement &&
            el.parentElement.id === "overlay-html-layer" &&
            el.id &&
            el.id.startsWith("div-"),
        );

        if (clickedDiv) {
          // Clicked on an existing div. Activate edit mode for it.
          activateDivEditMode(clickedDiv, e);
          els.actionBar.style.display = "none"; // Ensure new selection bar is hidden
          return;
        }

        // 2. CHECK FOR INVALID DRAG (Too small)
        if (width < 10 || height < 10) {
          // If it was a small movement (a failed click or small drag) and no DIV was hit, hide box and stop.
          els.selectionBox.style.display = "none";
          els.editActionBar.classList.add("disabled-bar"); // Ensure edit bar is disabled if no div was selected
          return;
        }

        // 3. NEW SELECTION LOGIC (Drag occurred)

        const canvasW = els.theCanvas.width;
        const canvasH = els.theCanvas.height;
        const x = Math.min(state.selectionStart.x, currentPos.x);
        const y = Math.min(state.selectionStart.y, currentPos.y);

        state.selectionRect = {
          left: (x / canvasW) * 100,
          top: (y / canvasH) * 100,
          width: (width / canvasW) * 100,
          height: (height / canvasH) * 100,
          pixelX: x,
          pixelY: y,
          pixelW: width,
          pixelH: height,
        };

        // --- Show Action Bar for NEW selection ---
        // Calculate absolute position on screen
        const rect = els.selectionLayer.getBoundingClientRect();
        const absX = rect.left + x;
        const absY = rect.top + y + height;

        const barWidth = 180;
        let barLeft = absX + width / 2 - barWidth / 2;
        let barTop = absY + 10;

        // Boundary checks
        if (barLeft < 10) barLeft = 10;
        if (barLeft + barWidth > window.innerWidth)
          barLeft = window.innerWidth - barWidth - 10;
        if (barTop + 50 > window.innerHeight) {
          barTop = rect.top + y - 60;
        }

        els.actionBar.style.left = barLeft + "px";
        els.actionBar.style.top = barTop + "px";
        els.actionBar.style.display = "flex";
      });

      document.addEventListener("click", (e) => {
        // If we click outside the whole editor pane (including the action bar)
        if (e.target.closest("#overlay-container") === null) {
          window.closeSelection();
        }
      });

      // --- Logic Hooks ---

      els.chkShowSource.addEventListener("change", (e) => {
        els.overlayCanvasMount.style.opacity = e.target.checked ? "1" : "0";
      });
      els.chkShowOverlay.addEventListener("change", (e) => {
        els.overlayHtmlLayer.style.display = e.target.checked
          ? "block"
          : "none";
      });

      els.btnCreateDiv.addEventListener("click", () => {
        insertDiv("Placeholder Content");
        window.closeSelection();
      });

      els.btnCopyImage.addEventListener("click", () => {
        const base64 = extractImageSnippet({
          x: state.selectionRect.pixelX,
          y: state.selectionRect.pixelY,
          width: state.selectionRect.pixelW,
          height: state.selectionRect.pixelH,
        });
        insertImage(`data:image/png;base64,${base64}`);
        window.closeSelection();
      });

      // Simplified Digitize (Text Only)
      els.btnDigitize.addEventListener("click", async () => {
        window.closeSelection();
        const base64 = extractImageSnippet({
          x: state.selectionRect.pixelX,
          y: state.selectionRect.pixelY,
          width: state.selectionRect.pixelW,
          height: state.selectionRect.pixelH,
        });

        const prompt =
          "Transcribe the text in this image. Return ONLY the raw text, preserving line breaks. Do not include markdown blocks or commentary. If it is a mathematical formula, return the KaTeX equivalent.";

        try {
          const resultText = await queryGemini(prompt, base64);
          // The insertDiv function now handles the heuristic padding reset
          insertDiv(resultText.trim());
        } catch (e) {
          /* Error handled in wrapper */
        }
      });

      // === AI Style Features (Refactored to global functions) ===

      function getSnippetFromDiv(divId) {
        const div = document.getElementById(divId);
        if (!div) return null;

        const cw = els.theCanvas.width;
        const ch = els.theCanvas.height;
        const pixelRect = {
          x: (parseFloat(div.style.left) / 100) * cw,
          y: (parseFloat(div.style.top) / 100) * ch,
          width: (parseFloat(div.style.width) / 100) * cw,
          height: (parseFloat(div.style.height) / 100) * ch,
        };
        return extractImageSnippet(pixelRect);
      }

      // 1. Replica: VISUAL COMPARISON
      window.runAiReplica = async function () {
        const divId = state.targetDivId;
        if (!divId) return;
        els.editActionBar.classList.add("disabled-bar");

        if (typeof html2canvas === "undefined") {
          return;
        }

        const base64Source = getSnippetFromDiv(divId);
        const divEl = document.getElementById(divId);
        if (!divEl) return;

        els.aiStatus.style.display = "inline";
        els.aiStatus.textContent = "Capturing...";

        try {
          const canvas = await html2canvas(divEl, {
            backgroundColor: "#ffffff",
            scale: 2,
            logging: false,
            useCORS: true,
            allowTaint: true,
          });
          const base64Render = canvas.toDataURL("image/png").split(",")[1];

          const internalState = getDivInternalState(divEl);

          const prompt = `You are a Visual CSS Alignment Engine. I am providing two images (Target and Example) and the current internal HTML/style of the text block.
                 
                 Image 1: The "Target" (Source PDF snippet). This is the visual truth within the crop region that we are targetting.
                 Image 2: The "Example" (Browser rendering of the content inside the fixed crop region).
                 
                 Your Mission: Make the alignment and typography in Image 2 as close as possible in appearance to Image 1.
                 
                 CRITICAL CONSTRAINTS:
                 1. Use **padding-top and padding-left** for alignment and adjust typography using **font-size, line-height, text-align**.
                 
                 PRACTICE THESE VIRTUES:

                 1.  **Curiosity**
                 2.  **Relinquishment**
                 3.  **Lightness**
                 4.  **Evenness**
                 5.  **Argument**
                 6.  **Empiricism**
                 7.  **Simplicity**
                 8.  **Humility**
                 9.  **Perfectionism**
                 10. **Precision**
                 11. **Scholarship**
                 12. **The Void** (**Focus solely on achieving the correct outcome.**)

                 ---
                 Content to be Styled: ${internalState.content}
                 ---
                 
                 Output:
                 Return the FULL, CORRECTED HTML string for the single <div> element.
                 - Return ONLY the HTML string (no markdown blocks or commentary).
                 `;

          const resultHtml = await queryGemini(prompt, [
            base64Source,
            base64Render,
          ]);

          updateDOMWithCallback((doc) => {
            const target = doc.getElementById(divId);
            if (target) {
              const cleaned = resultHtml
                .replace(/```html/g, "")
                .replace(/```/g, "")
                .trim();

              // Parse the AI's result to extract styles and inner HTML
              const tempDiv = document.createElement("div");
              tempDiv.innerHTML = cleaned;
              const newEl = tempDiv.firstChild;

              if (newEl && newEl.nodeName === "DIV" && newEl.id === divId) {
                // AI returned the full, correct DIV. We need to merge styles, preserving position.

                const newStyleString = newEl.getAttribute("style") || "";
                const originalStyleString = target.getAttribute("style") || "";

                const positionalPropsToKeep = [
                  "position",
                  "left",
                  "top",
                  "width",
                  "height",
                  "background",
                  "overflow",
                  "overflow-wrap",
                  "z-index",
                ];

                const originalStyles = originalStyleString
                  .split(";")
                  .map((s) => s.trim())
                  .filter((s) => {
                    const prop = s.split(":")[0].trim().toLowerCase();
                    return positionalPropsToKeep.some((p) =>
                      prop.startsWith(p),
                    );
                  });

                const newInternalStyles = newStyleString
                  .split(";")
                  .map((s) => s.trim())
                  .filter((s) => {
                    const prop = s.split(":")[0].trim().toLowerCase();
                    return (
                      !positionalPropsToKeep.some((p) => prop.startsWith(p)) &&
                      s
                    );
                  });

                const mergedStyles = [...originalStyles, ...newInternalStyles]
                  .filter((s) => s)
                  .join("; ");

                target.setAttribute("style", mergedStyles);
                target.innerHTML = newEl.innerHTML;
                els.editActionBar.classList.remove("disabled-bar");
                return true;
              } else {
                target.innerHTML = cleaned;
                els.editActionBar.classList.remove("disabled-bar");
                return true;
              }
            }
            els.editActionBar.classList.remove("disabled-bar");
            return false;
          });
        } catch (e) {
          console.error(e);
          els.aiStatus.textContent = "Error";
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // 2. Match Font: Style Heuristics only (CSS on Container)
      window.runAiFont = async function () {
        const divId = state.targetDivId;
        if (!divId) return;
        els.editActionBar.classList.add("disabled-bar");

        const base64 = getSnippetFromDiv(divId);

        const prompt = `Analyze the typography in this image snippet. 
             Return a JSON object (and nothing else) containing the following CSS properties that best approximate the text style found in the image:
             {
                "fontFamily": "string (standard web-safe stack)",
                "fontWeight": "string or number",
                "fontStyle": "string (normal/italic)",
                "textAlign": "string (left/center/justify/right)",
                "fontSize": "string (e.g. '14px')"
             }
             Do NOT include markdown formatting. Just the raw JSON string.`;

        try {
          const resultText = await queryGemini(prompt, base64);
          const styles = parseAIJson(resultText);

          if (styles) {
            updateDOMWithCallback((doc) => {
              const target = doc.getElementById(divId);
              if (target) {
                if (styles.fontFamily)
                  target.style.fontFamily = styles.fontFamily;
                if (styles.fontWeight)
                  target.style.fontWeight = styles.fontWeight;
                if (styles.fontStyle) target.style.fontStyle = styles.fontStyle;
                if (styles.textAlign) target.style.textAlign = styles.textAlign;
                if (styles.fontSize) target.style.fontSize = styles.fontSize;
                return true;
              }
              return false;
            });
          }
          els.editActionBar.classList.remove("disabled-bar");
        } catch (e) {
          console.error(e);
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // 3. Flow: Text Only (Clean Transcription)
      window.runAiText = async function () {
        const divId = state.targetDivId;
        if (!divId) return;
        els.editActionBar.classList.add("disabled-bar");

        const base64 = getSnippetFromDiv(divId);

        const prompt = `Transcribe the text in this image. 
             - Return ONLY the raw text. 
             - Use HTML <p> tags for paragraphs. 
             - Do not add any inline styles. 
             - Do not include markdown blocks.`;

        try {
          const resultHtml = await queryGemini(prompt, base64);
          updateDivContent(divId, resultHtml);
          els.editActionBar.classList.remove("disabled-bar");
        } catch (e) {
          console.error(e);
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // Helpers
      window.closeSelection = function () {
        els.selectionBox.style.display = "none";
        els.selectionBox.classList.remove("edit-mode");
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";
        els.editActionBar.classList.add("disabled-bar"); // Disable edit bar
        state.targetDivId = null;
      };

      function insertDiv(content, styles = {}) {
        const rect = state.selectionRect;
        const l = rect.left.toFixed(2);
        const t = rect.top.toFixed(2);
        const w = rect.width.toFixed(2);
        const h = rect.height.toFixed(2);
        const id = `div-${Date.now()}`;

        const safeContent = content
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\n/g, "<br>");

        // HEURISTIC UPDATE:
        // 1. Padding: 0px (User Request)
        // 2. Margin: 0px (User Request)
        // 3. Line-height: 1.0 (Strict print alignment)
        // 4. Font-size: 14px (Starting point)

        let styleStr = `position: absolute; left: ${l}%; top: ${t}%; width: ${w}%; height: ${h}%; background: rgba(255,255,255,0.8); padding: 0px; margin: 0px; overflow-wrap: break-word; overflow: hidden;`;
        styleStr += ` font-size: 14px; line-height: 1.0; font-family: 'Times New Roman', serif;`;

        appendHtml(`<div id="${id}" style="${styleStr}">${safeContent}</div>`);

        // Trigger Smart Fit Heuristic after DOM update
        setTimeout(() => smartFitText(id), 50);
      }

      // --- Smart Fit Algorithm (Binary Search) ---
      function smartFitText(divId) {
        const el = document.getElementById(divId);
        if (!el) return;

        // Reset line-height to ensure accurate height calculation
        el.style.lineHeight = "1.0";

        // Binary search for optimal font size
        let low = 6;
        let high = 100;
        let bestSize = 12;

        // We iterate to find the max size that fits
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          el.style.fontSize = mid + "px";

          // HEURISTIC FIX: Priority is Width Fit
          // We relax the height constraint slightly to allow filling the width
          // because print layouts often have strict column widths.
          const isWidthFit = el.scrollWidth <= el.clientWidth;
          const isHeightFit = el.scrollHeight <= el.clientHeight + 5; // Allow slight overflow (5px)

          if (isWidthFit && isHeightFit) {
            bestSize = mid;
            low = mid + 1; // Try bigger
          } else {
            high = mid - 1; // Too big
          }
        }

        // Apply best size permanently to source
        window.updateStyle("fontSize", bestSize + "px");
      }

      function insertImage(dataUrl) {
        const l = state.selectionRect.left.toFixed(2);
        const t = state.selectionRect.top.toFixed(2);
        const w = state.selectionRect.width.toFixed(2);
        const h = state.selectionRect.height.toFixed(2);
        appendHtml(
          `<img src="${dataUrl}" style="position: absolute; left: ${l}%; top: ${t}%; width: ${w}%; height: ${h}%; object-fit: contain;" />`,
        );
      }

      function appendHtml(str) {
        const input = els.overlayHtmlInput;
        input.value = input.value + str;
        updateOverlayPreview();
        saveContent();
      }

      function updateDivContent(divId, newContent) {
        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(divId);
          if (target) {
            const cleanedContent = newContent
              .replace(/```html/g, "")
              .replace(/```/g, "")
              .trim();
            target.innerHTML = cleanedContent;
            return true;
          }
          return false;
        });
        // Re-run fitting if content changed
        setTimeout(() => smartFitText(divId), 50);
      }

      // --- Added for context menu click handlers ---
      els.workspace = document.getElementById("workspace");

      // --- Core Application Logic ---
      els.upload.addEventListener("change", function (e) {
        var file = e.target.files[0];
        if (file.type !== "application/pdf") return;
        state.pageNum = 1;
        localStorage.setItem(STORAGE_KEY_FILENAME, file.name);
        els.restoredFilename.textContent = file.name;
        els.restoreBadge.classList.add("hidden");
        savePDFToDB(file).catch((err) =>
          console.error("Error saving PDF to DB:", err),
        );
        var fileReader = new FileReader();
        fileReader.onload = function () {
          var typedarray = new Uint8Array(this.result);
          loadPDF(typedarray, 1);
        };
        fileReader.readAsArrayBuffer(file);
      });

      function updatePreview() {
        const rawMarkdown = els.markdownInput.value;
        const htmlContent = marked.parse(rawMarkdown);
        els.previewOutput.innerHTML = htmlContent;
        renderMathInElement(els.previewOutput, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false },
          ],
          throwOnError: false,
        });
      }

      function updateOverlayPreview() {
        els.overlayHtmlLayer.innerHTML = els.overlayHtmlInput.value;
        renderMathInElement(els.overlayHtmlLayer, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false },
          ],
          throwOnError: false,
        });
      }

      function switchMainView(viewId) {
        saveContent();
        state.activeTab = viewId;
        if (viewId === "source") {
          if (!els.pdfRenderContainer.contains(els.theCanvas))
            els.pdfRenderContainer.appendChild(els.theCanvas);
        } else if (viewId === "overlay") {
          if (!els.overlayCanvasMount.contains(els.theCanvas))
            els.overlayCanvasMount.appendChild(els.theCanvas);
          updateOverlayPreview();
        }

        const containers = {
          source: els.sourceContainer,
          overlay: els.overlayContainer,
          write: els.editorContainerMd,
          preview: els.previewContainer,
        };
        const buttons = {
          source: els.tabSource,
          overlay: els.tabOverlay,
          write: els.tabWrite,
          preview: els.tabPreview,
        };
        Object.values(containers).forEach((c) => c.classList.add("hidden"));
        Object.values(buttons).forEach((b) => b.classList.remove("active"));
        if (containers[viewId]) containers[viewId].classList.remove("hidden");
        if (buttons[viewId]) buttons[viewId].classList.add("active");
        if (viewId === "preview") updatePreview();

        // Always revert from log view when switching tabs
        if (state.isLogActive) {
          state.isLogActive = false;
        }
      }

      els.overlayHtmlInput.addEventListener("input", () => {
        if (!state.isLogActive) {
          updateOverlayPreview();
          saveContent();
        }
      });
      els.markdownInput.addEventListener("input", () => {
        saveContent();
      });
      els.tabSource.addEventListener("click", () => switchMainView("source"));
      els.tabOverlay.addEventListener("click", () => switchMainView("overlay"));
      els.tabWrite.addEventListener("click", () => switchMainView("write"));
      els.tabPreview.addEventListener("click", () => switchMainView("preview"));
      els.prevBtn.addEventListener("click", () => {
        if (state.pageNum > 1) {
          state.pageNum--;
          queueRenderPage(state.pageNum);
        }
      });
      els.nextBtn.addEventListener("click", () => {
        if (state.pdfDoc && state.pageNum < state.pdfDoc.numPages) {
          state.pageNum++;
          queueRenderPage(state.pageNum);
        }
      });
      els.zoomInBtn.addEventListener("click", () => {
        state.scale += 0.2;
        els.zoomLevelSpan.innerText = Math.round(state.scale * 100) + "%";
        queueRenderPage(state.pageNum);
      });
      els.zoomOutBtn.addEventListener("click", () => {
        if (state.scale > 0.4) {
          state.scale -= 0.2;
          els.zoomLevelSpan.innerText = Math.round(state.scale * 100) + "%";
          queueRenderPage(state.pageNum);
        }
      });
      els.fullscreenBtn.addEventListener("click", () => {
        document.fullscreenElement
          ? document.exitFullscreen()
          : document.documentElement.requestFullscreen();
      });

      initPersistence();
      switchMainView("overlay");
    </script>
  </body>
</html>
