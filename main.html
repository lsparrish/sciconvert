<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>main.html</title>

    <!-- Libraries -->
    <!-- PDF.js for rendering the scanned document -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
    </script>

    <!-- Marked for Markdown parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <!-- KaTeX for Math rendering -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js"></script>

    <!-- Tailwind for layout (via CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- html2canvas for DOM screenshots -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
      /* Custom Scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      ::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #e5e7eb;
        height: 100vh;
        overflow: hidden;
      }

      /* Custom Tab Styles */
      .tab-button {
        padding: 0.75rem 1.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        color: #4b5563;
        border-bottom: 2px solid transparent;
        cursor: pointer;
        transition: all 0.1s ease-in-out;
      }
      .tab-button:hover {
        color: #1f2937;
        border-bottom-color: #e5e7eb;
      }
      .tab-button.active {
        color: #2563eb;
        border-bottom-color: #2563eb;
        background-color: #fff;
      }

      /* PDF Canvas Styles */
      #pdf-render-container {
        /* Fixed an invalid box-shadow string that was causing a SyntaxError */
        box-shadow:
          0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        background-color: #525659;
        overflow: auto;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 20px;
      }

      canvas {
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        max-width: none;
      }

      /* Editor Styles */
      .editor-textarea {
        font-family: "Consolas", "Monaco", "Courier New", monospace;
        line-height: 1.6;
        resize: none;
      }

      /* Preview Styles */
      .preview-content {
        line-height: 1.6;
        text-align: justify;
      }

      /* Font Classes */
      .font-serif {
        font-family: "Times New Roman", Times, serif;
      }
      .font-sans {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }
      .font-mono {
        font-family: "Courier New", Courier, monospace;
      }

      .two-columns {
        column-count: 2;
        column-gap: 2rem;
      }

      /* Loader */
      .loader {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Selection Box Styles */
      #selection-box {
        border: 2px dashed #2563eb;
        background-color: rgba(37, 99, 235, 0.1);
        position: absolute;
        pointer-events: none; /* Let events pass through to layer */
        display: none;
        z-index: 50;
      }

      /* Orange outline for Editing Mode */
      #selection-box.edit-mode {
        border-color: #f97316; /* Orange-500 */
        background-color: rgba(249, 115, 22, 0.1);
      }

      /* OVERLAY HEURISTIC RESET: Ensure AI/HTML content has no default margins */
      #overlay-html-layer * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        /* STRICT RESET: 1.0 line height matches print closer than 1.15 */
        line-height: 1;
      }
      #overlay-html-layer div {
        /* Ensure the containers themselves don't collapse */
        box-sizing: border-box;
      }

      /* Debug View Overlay (Updated for side-by-side comparison) */
      #debug-vision-overlay {
        position: fixed; /* Fixed position covers the entire viewport reliably */
        inset: 0;
        z-index: 99999;
        background: rgba(0, 0, 0, 0.85); /* Dark background for focus */
        pointer-events: all;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        color: white;
      }
      #debug-vision-content {
        display: flex;
        gap: 20px;
        max-width: 90%;
        max-height: 90%;
        justify-content: center;
        align-items: flex-start;
      }
      .debug-pane {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #333;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }
      .debug-pane img {
        max-width: 100%;
        max-height: 80vh;
        object-fit: contain;
        border: 1px solid #555;
      }
      #debug-vision-label {
        /* Placeholder, not used in new design */
        display: none;
      }
      #close-debug-vision {
        /* Style for the closing button */
        cursor: pointer;
      }

      /* --- Context Menu Styles (Simplified/Stripped) --- */
      #context-menu {
        /* Hiding context menu logic since we are transitioning to action bar */
        display: none !important;
      }

      /* --- Action Bar Styles (Selection) --- */
      #selection-action-bar {
        position: fixed;
        z-index: 10000;
        display: none;
        transform-origin: top center;
        animation: fadeIn 0.1s ease-out;
      }

      /* --- Action Bar Styles (Edit) --- */
      #edit-action-bar {
        z-index: 0;
        /* Position and width managed by Tailwind classes in HTML: w-full shrink-0 */
      }

      .disabled-bar {
        opacity: 0.5;
        pointer-events: none;
        transition: opacity 0.2s ease-in-out;
      }

      .action-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 0.5rem;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.15s;
        color: #4b5563;
        background: #f9fafb;
        border: 1px solid #f3f4f6;
      }

      .action-btn:hover {
        background-color: #f3f4f6;
        color: #1f2937;
        transform: translateY(-1px);
      }

      .action-btn svg {
        width: 1.25rem;
        height: 1.25rem;
        margin-bottom: 0.1rem;
      }

      .action-btn span {
        font-size: 0.65rem;
        font-weight: 600;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.95) translateY(-5px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }
    </style>
  </head>
  <body class="flex flex-col h-screen">
    <!-- Header / Toolbar -->
    <header
      class="bg-gray-800 text-white p-3 flex justify-between items-center shadow-md z-10 shrink-0"
    >
      <div class="flex items-center gap-4">
        <h1 class="text-xl font-bold tracking-wider mr-4">
          SciText <span class="text-blue-400">Digitizer</span>
        </h1>

        <div class="relative">
          <input
            type="file"
            id="pdf-upload"
            accept="application/pdf"
            class="hidden"
          />
          <label
            for="pdf-upload"
            class="cursor-pointer bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          >
            <svg
              class="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
              ></path>
            </svg>
            Load PDF
          </label>
        </div>

        <div
          class="flex items-center bg-gray-700 rounded px-2 py-1 gap-2"
          id="pdf-nav-controls"
          style="display: none"
        >
          <button
            id="prev-page"
            class="hover:text-blue-300 p-1 disabled:opacity-50"
            title="Previous Page"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M15 19l-7-7 7-7"
              ></path>
            </svg>
          </button>
          <span class="text-sm font-mono"
            >Page <span id="page-num">0</span> /
            <span id="page-count">0</span></span
          >
          <button
            id="next-page"
            class="hover:text-blue-300 p-1 disabled:opacity-50"
            title="Next Page"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M9 5l7 7-7 7"
              ></path>
            </svg>
          </button>
        </div>

        <div
          class="flex items-center bg-gray-700 rounded px-2 py-1 gap-2"
          id="pdf-zoom-controls"
          style="display: none"
        >
          <button
            id="zoom-out"
            class="hover:text-blue-300 p-1"
            title="Zoom Out"
          >
            -
          </button>
          <span id="zoom-level" class="text-xs font-mono w-12 text-center"
            >100%</span
          >
          <button id="zoom-in" class="hover:text-blue-300 p-1" title="Zoom In">
            +
          </button>
        </div>
      </div>

      <div class="flex items-center gap-4">
        <span
          id="restore-badge"
          class="hidden bg-amber-100 text-amber-800 text-xs font-medium px-2.5 py-0.5 rounded border border-amber-400"
        >
          Restored: <span id="restored-filename" class="font-bold"></span>
        </span>

        <button
          id="export-md"
          class="bg-green-600 hover:bg-green-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          title="Download Transcription"
        >
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
            ></path>
          </svg>
          Export
        </button>

        <button
          id="fullscreen-toggle"
          class="bg-purple-600 hover:bg-purple-500 px-4 py-2 rounded text-sm font-semibold transition flex items-center gap-2"
          title="Toggle Fullscreen Mode"
        >
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 8V4m0 0h4M4 4l5 5m11-5v4m0 0h-4m4 0l-5-5M4 16v4m0 0h4M4 20l5-5m11 5v-4m0 0h-4m4 0l-5 5"
            ></path>
          </svg>
          Full
        </button>
      </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 flex flex-col overflow-hidden relative">
      <!-- Tab Bar -->
      <div
        id="main-tab-bar"
        class="flex bg-gray-50 border-b border-gray-200 shadow-inner shrink-0"
      >
        <button id="tab-overlay" class="tab-button active">
          Overlay Editor
        </button>
        <button
          id="tab-prompts"
          class="tab-button text-red-600 hover:text-red-800"
        >
          Prompts (Debug)
        </button>
        <a href=https://github.com/lsparrish/sciconvert>GH</a>
      </div>

      <div
        id="empty-state"
        class="absolute inset-0 flex flex-col items-center justify-center bg-gray-100 z-50 text-gray-500"
      >
        <svg
          class="w-24 h-24 mb-4 text-gray-300"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="1.5"
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          ></path>
        </svg>
        <h2 class="text-2xl font-bold mb-2">No Document Loaded</h2>
        <p class="mb-6">Upload a PDF to begin digitizing.</p>
      </div>

      <div id="workspace" class="flex-1 overflow-hidden relative bg-white">
        <!-- 1. Source (PDF) Container: KEPT as it contains the canvas -->
        <div
          id="source-container"
          class="absolute inset-0 flex flex-col hidden"
        >
          <div id="pdf-render-container" class="w-full h-full">
            <canvas id="the-canvas"></canvas>
          </div>
          <div
            id="pdf-loader"
            class="absolute inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center hidden"
          >
            <div class="loader mb-2"></div>
            <span class="text-white text-sm font-semibold"
              >Rendering Page...</span
            >
          </div>
        </div>

        <!-- 2. Overlay Split View Container -->
        <div id="overlay-container" class="absolute inset-0 flex hidden">
          <!-- Left: Editor -->
          <div
            class="w-1/3 h-full flex flex-col border-r border-gray-300 z-20 bg-white shadow-xl"
          >
            <div
              class="bg-gray-100 px-4 py-2 text-xs font-bold text-gray-500 border-b flex justify-between"
            >
              <span id="editor-title">OVERLAY HTML</span>
              <div class="flex items-center gap-4">
                <span id="ai-status" class="text-blue-600 hidden"
                  >AI Processing...</span
                >
                <span
                  id="show-ai-log"
                  class="text-gray-500 hover:text-gray-900 cursor-pointer font-semibold hidden"
                  onclick="toggleAiLog()"
                >
                  [AI Log]
                </span>
              </div>
            </div>
            <textarea
              id="overlay-html-input"
              class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-gray-800 bg-gray-50 text-xs"
              placeholder="<!-- Select a region on the right to digitize -->"
            ></textarea>

            <!-- Action Bar for Editing a selected DIV (Always Visible, toggled enabled/disabled) -->
            <div
              id="edit-action-bar"
              class="w-full shrink-0 flex border-t border-gray-200 bg-gray-50 p-2 overflow-x-auto disabled-bar"
            >
              <!-- Smart Style (AI) Group -->
              <button
                id="btn-ai-replica-edit"
                class="action-btn text-blue-600 hover:text-blue-700"
                onclick="runAiReplica()"
                title="AI Replica Style Match"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                  ></path>
                </svg>
                <span>AI Style</span>
              </button>
              <button
                id="btn-ai-font-edit"
                class="action-btn text-purple-600 hover:text-purple-700"
                onclick="runAiFont()"
                title="AI Match Font Only"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                  ></path>
                </svg>
                <span>AI Font</span>
              </button>
              <button
                id="btn-ai-text-edit"
                class="action-btn text-green-600 hover:text-green-700"
                onclick="runAiText()"
                title="AI Transcribe Text Only"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 6h16M4 12h16M4 18h7"
                  ></path>
                </svg>
                <span>AI Text</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <!-- Typography Group -->
              <button
                class="action-btn font-serif text-sm h-auto w-10 text-gray-700 hover:text-black"
                onclick="updateStyle('font-family', 'Times New Roman, serif')"
                title="Serif"
              >
                T
              </button>
              <button
                class="action-btn font-sans text-sm h-auto w-10 text-gray-700 hover:text-black"
                onclick="updateStyle('font-family', 'Arial, sans-serif')"
                title="Sans"
              >
                S
              </button>
              <button
                class="action-btn text-gray-700 hover:text-black"
                onclick="updateStyle('text-align', 'justify')"
                title="Justify Text"
              >
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M3 6h18M3 12h18M3 18h18" />
                </svg>
                <span>Justify</span>
              </button>
              <button
                class="action-btn text-gray-700 hover:text-black"
                onclick="updateStyle('font-weight', 'bold')"
                title="Bold"
              >
                <span class="text-sm font-bold">B</span>
                <span>Bold</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <!-- Actions Group -->
              <button
                id="btn-clear-styles-edit"
                class="action-btn text-amber-600 hover:text-amber-700"
                onclick="clearStyles()"
                title="Remove all styling"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"
                  ></path>
                </svg>
                <span>Clear CSS</span>
              </button>

              <div class="w-px h-8 bg-gray-200 my-auto"></div>

              <button
                id="btn-delete-div-edit"
                class="action-btn text-red-600 hover:text-red-700"
                onclick="deleteDiv()"
                title="Delete Selection"
              >
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                  ></path>
                </svg>
                <span>Delete</span>
              </button>
            </div>
          </div>

          <!-- Right: Preview (Superimposed) -->
          <div class="w-2/3 h-full flex flex-col relative bg-gray-500">
            <!-- Overlay Toolbar -->
            <div
              class="bg-gray-200 p-2 flex gap-4 border-b border-gray-400 shrink-0 z-30 justify-center text-sm text-gray-700 shadow-sm"
            >
              <label
                class="flex items-center gap-2 cursor-pointer font-semibold hover:text-black"
              >
                <input
                  type="checkbox"
                  id="chk-show-source"
                  checked
                  class="rounded text-blue-600 focus:ring-blue-500"
                />
                Show Source PDF
              </label>
              <div class="w-px h-4 bg-gray-400 my-auto"></div>
              <label
                class="flex items-center gap-2 cursor-pointer font-semibold hover:text-black"
              >
                <input
                  type="checkbox"
                  id="chk-show-overlay"
                  checked
                  class="rounded text-blue-600 focus:ring-blue-500"
                />
                Show HTML Overlay
              </label>
            </div>

            <!-- Scroller -->
            <div
              id="overlay-scroller"
              class="flex-1 overflow-auto flex justify-center p-8 select-none relative"
            >
              <!-- Wrapper matches Canvas Size -->
              <div
                id="overlay-wrapper"
                class="relative shadow-2xl origin-top bg-white"
              >
                <!-- Mount point for Canvas when in this view -->
                <div
                  id="overlay-canvas-mount"
                  class="transition-opacity duration-200"
                ></div>

                <!-- HTML Layer (Rendered Content) -->
                <div
                  id="overlay-html-layer"
                  class="absolute inset-0 overflow-hidden pointer-events-none z-10 transition-opacity duration-200"
                ></div>

                <!-- Selection Layer (Interactive) -->
                <div
                  id="selection-layer"
                  class="absolute inset-0 z-20 cursor-crosshair"
                ></div>

                <!-- Visual Selection Box -->
                <div id="selection-box"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- 3. Editor Container (Markdown/Write - Removed from nav, kept for export) -->
        <div
          id="editor-container-md"
          class="absolute inset-0 flex flex-col hidden"
        >
          <textarea
            id="markdown-input"
            class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-gray-800 bg-gray-50 text-sm"
            placeholder="# Transcription Area"
          ></textarea>
        </div>

        <!-- 4. Preview Container (Render - Removed from nav) -->
        <div
          id="preview-container"
          class="absolute inset-0 overflow-y-auto p-8 hidden bg-white"
        >
          <div
            id="preview-output"
            class="preview-content font-serif text-gray-900 max-w-none"
          ></div>
        </div>

        <!-- 5. Prompts Container (Debug Tab) -->
        <div
          id="editor-container-prompts"
          class="absolute inset-0 flex flex-col hidden"
        >
          <textarea
            id="prompt-input"
            class="editor-textarea flex-1 w-full h-full p-4 border-none outline-none text-xs"
            placeholder="Loading AI prompts..."
          ></textarea>
        </div>
      </div>
    </main>

    <!-- Action Bar (For new selections) -->
    <div
      id="selection-action-bar"
      class="bg-gray-800 text-white rounded-lg shadow-2xl flex items-center p-1.5 gap-2 border border-gray-700"
    >
      <button id="btn-digitize" class="action-btn" title="Digitize Text (AI)">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          ></path>
        </svg>
        <span>Digitize</span>
      </button>
      <button id="btn-copy-image" class="action-btn" title="Extract Image">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
          ></path>
        </svg>
        <span>Image</span>
      </button>
      <button id="btn-create-div" class="action-btn" title="Empty Box">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z"
          ></path>
        </svg>
        <span>Empty</span>
      </button>

      <div class="w-px h-8 bg-gray-600 mx-0.5"></div>

      <button
        id="btn-close-action"
        class="action-btn text-gray-400 hover:text-red-400"
        title="Close"
        onclick="closeSelection()"
      >
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"
          ></path>
        </svg>
        <span>Cancel</span>
      </button>
    </div>

    <!-- Context Menu (hidden) -->
    <div
      id="context-menu"
      class="flex flex-col bg-white border border-gray-300 shadow-lg"
      style="
        position: fixed;
        z-index: 9999;
        display: none;
        min-width: 230px;
        border-radius: 4px;
        overflow: hidden;
      "
    >
      <!-- Content removed, using edit-action-bar instead -->
    </div>

    <!-- Debug Vision Overlay Mount (UPDATED STRUCTURE) -->
    <div id="debug-vision-overlay">
      <div id="debug-vision-content">
        <div class="debug-pane">
          <span
            id="debug-source-label"
            class="text-sm font-bold text-yellow-300"
            >1. TARGET (Source PDF Image)</span
          >
          <img id="debug-source-img" alt="Target Image Snippet" />
        </div>
        <div class="debug-pane">
          <span id="debug-render-label" class="text-sm font-bold text-blue-300"
            >2. TEST RENDER (Current HTML View)</span
          >
          <img id="debug-render-img" alt="Current HTML Render" />
        </div>
      </div>
      <button
        id="close-debug-vision"
        class="mt-4 bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded transition"
      >
        Close Debug View
      </button>
    </div>

    <script type="module">
      const apiKey = ""; // Runtime key
      const STORAGE_KEY = "scitext_transcriptions";
      const STORAGE_KEY_LAST_PAGE = "scitext_last_page_num";
      const STORAGE_KEY_FILENAME = "scitext_last_filename";
      const STORAGE_KEY_PROMPTS = "scitext_ai_prompts"; // Key for prompts

      // NEW: Default image URL for testing
      const DEFAULT_IMAGE_URL =
        "https://lsparrish.github.io/sciconvert/sample.png";

      let transcriptionData = {};
      let aiQueryLog = []; // Global storage for AI request/response logs

      // --- State ---
      const state = {
        pdfDoc: null,
        pageNum: 1,
        pageRendering: false,
        pageNumPending: null,
        scale: 1.2,
        canvas: document.getElementById("the-canvas"),
        ctx: document.getElementById("the-canvas").getContext("2d"),
        activeTab: "overlay",
        fontClass: "font-serif",
        isAuthReady: false,
        saveTimeout: null,

        // Selection State
        isSelecting: false,
        selectionStart: { x: 0, y: 0 },
        selectionEnd: { x: 0, y: 0 },
        selectionRect: null,

        // Interaction Target
        targetDivId: null,

        isLogActive: false, // New state variable

        // AI Prompts (Editable content stored here)
        prompts: {
          DIGITIZE_TEXT:
            "Transcribe the text in this image. Return ONLY the raw text, preserving line breaks. Do not include markdown blocks or commentary. If it is a mathematical formula, return the KaTeX equivalent enclosed in dollar signs ($...$ or $$...$$).",
          REPLICA_STYLE: `You are a Visual CSS Alignment Engine. 
I am providing two images ("Target Image" and "Test Render").
I am also providing the current HTML of the text block corresponding exactly to the Test Render.

Image 1: The "Target Image" (Source scanned image) -- make the HTML like this.
Image 2: The "Test Render" (Browser rendering) -- Use this to understand what the provided HTML currently does.

CHALLENGE: Make the alignment and typography in Image 2 as close as possible in appearance to Image 1.

CRITICAL CONSTRAINTS:
1. You MUST use inline styling on <span> or other appropriate structural HTML elements (like <p> or <h1>).
2. The (Bounding Box) is for informational purposes only. It shows the width and height. Do not add a enclosing div with these properties.
3. Use the properties **margin-top, margin-left, font-size, text-align, font-family, font-weight, and font-style** applied to the internal elements (<span>, <p>, etc.) to correct each element.
4. Changes to the style values must be in a direction that improves upon the current parameters shown in the test case, such that the HTML to be rendered will more closely resemble the Target Image.
5. Deeply consider for each element whether it needs to be smaller, larger, up, down, left, right. 
6. Picture the words like puzzle pieces that you can shrink or grow. Reaching the correct size is one "click", reaching the correct distance values is another "click".
7. Consider standardizing on all fonts having the same font-size, with relative modifiers for each style.

--- CURRENT STATE FOR TEST RENDER ---
(Bounding Box): {{promptDimensions}}
(Content HTML): {{content}}
------------------------------------

Respond ONLY with the corrected inner HTML, no commentary or markdown apart from HTML comments.`,
          FONT_STYLE: `Analyze the typography in this image snippet. 
Return a JSON object (and nothing else) containing the following CSS properties that best approximate the text style found in the image:
{
   "fontFamily": "string (standard web-safe stack)",
   "fontWeight": "string or number",
   "fontStyle": "string (normal/italic)",
   "textAlign": "string (left/center/justify/right)",
   "fontSize": "string (e.g. '14px')"
}
Do NOT include markdown formatting. Just the raw JSON string.`,

          TEXT_ONLY: `Transcribe the text in this image. 
- Return ONLY the raw text. 
- Use HTML <p> tags for paragraphs. 
- Do not add any inline styles. 
- Do not include markdown blocks.`,
        },
      };

      // --- IndexedDB Utils ---
      const DB_NAME = "SciTextDB";
      const DB_VERSION = 1;
      const STORE_NAME = "files";

      function openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME);
            }
          };
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function savePDFToDB(blob) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(blob, "currentPdf"); // Store with fixed key
          request.onsuccess = () => resolve();
          request.onerror = (e) => reject(e);
        });
      }

      async function getPDFFromDB() {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get("currentPdf");
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (e) => reject(e);
        });
      }

      // --- DOM Elements ---
      const els = {
        upload: document.getElementById("pdf-upload"),
        emptyState: document.getElementById("empty-state"),
        pdfLoader: document.getElementById("pdf-loader"),
        navControls: document.getElementById("pdf-nav-controls"),
        zoomControls: document.getElementById("pdf-zoom-controls"),
        prevBtn: document.getElementById("prev-page"),
        nextBtn: document.getElementById("next-page"),
        pageNumSpan: document.getElementById("page-num"),
        pageCountSpan: document.getElementById("page-count"),
        zoomInBtn: document.getElementById("zoom-in"),
        zoomOutBtn: document.getElementById("zoom-out"),
        zoomLevelSpan: document.getElementById("zoom-level"),

        // Removed elements from DOM: previewOutput, previewContainer, editorContainerMd
        // Retain only necessary DOM elements
        // sourceContainer is kept as it holds the canvas when not in overlay view
        sourceContainer: document.getElementById("source-container"),
        overlayContainer: document.getElementById("overlay-container"),

        overlayScroller: document.getElementById("overlay-scroller"),

        pdfRenderContainer: document.getElementById("pdf-render-container"),
        overlayCanvasMount: document.getElementById("overlay-canvas-mount"),
        overlayWrapper: document.getElementById("overlay-wrapper"),
        overlayHtmlLayer: document.getElementById("overlay-html-layer"),
        selectionLayer: document.getElementById("selection-layer"),
        selectionBox: document.getElementById("selection-box"),
        contextMenu: document.getElementById("context-menu"),
        actionBar: document.getElementById("selection-action-bar"),
        editActionBar: document.getElementById("edit-action-bar"),
        theCanvas: document.getElementById("the-canvas"),

        // Removed element from DOM: markdownInput
        // markdownInput is technically still in the DOM for 'export', but not mapped to an active tab. Lets keep it here for export to work.
        markdownInput: document.getElementById("markdown-input"),
        overlayHtmlInput: document.getElementById("overlay-html-input"),

        // Removed tabs: tabSource, tabWrite, tabPreview
        tabOverlay: document.getElementById("tab-overlay"),

        fontSelect: document.getElementById("font-select"),
        exportBtn: document.getElementById("export-md"),
        fullscreenBtn: document.getElementById("fullscreen-toggle"),

        btnDigitize: document.getElementById("btn-digitize"),
        btnCopyImage: document.getElementById("btn-copy-image"),
        btnCreateDiv: document.getElementById("btn-create-div"),
        aiStatus: document.getElementById("ai-status"),

        chkShowSource: document.getElementById("chk-show-source"),
        chkShowOverlay: document.getElementById("chk-show-overlay"),
        restoreBadge: document.getElementById("restore-badge"),
        restoredFilename: document.getElementById("restored-filename"),

        menuGroupDiv: document.getElementById("menu-group-div"),

        // Debug (Update mapping for new elements)
        debugOverlay: document.getElementById("debug-vision-overlay"),
        debugSourceImg: document.getElementById("debug-source-img"), // New
        debugRenderImg: document.getElementById("debug-render-img"), // New
        closeDebugVision: document.getElementById("close-debug-vision"), // New

        // New AI Log Elements
        editorTitle: document.getElementById("editor-title"),
        showAiLog: document.getElementById("show-ai-log"),

        // New Prompt Elements
        tabPrompts: document.getElementById("tab-prompts"),
        promptInput: document.getElementById("prompt-input"),

        // Need to explicitly map the hidden containers, as they are still referenced in switchMainView for display logic
        editorContainerPrompts: document.getElementById(
          "editor-container-prompts",
        ),
        editorContainerMd: document.getElementById("editor-container-md"),
        previewContainer: document.getElementById("preview-container"),
      };

      // --- Persistence ---
      function initPersistence() {
        try {
          const storedData = localStorage.getItem(STORAGE_KEY);
          if (storedData) transcriptionData = JSON.parse(storedData);

          const storedPrompts = localStorage.getItem(STORAGE_KEY_PROMPTS);
          if (storedPrompts) {
            // Load stored prompts into the editor and state
            // The editor input value is set when switching to the tab, but we need to parse it now.
            parsePrompts(storedPrompts);
          }
          // Set initial value in promptInput regardless of persistence load, using state.prompts
          els.promptInput.value = formatPromptsForEditor(state.prompts);
        } catch (error) {
          console.error("Error loading persistence data:", error);
        }

        state.isAuthReady = true;
        restoreSessionFromDB();

        // Initial bar state check
        updateEditBarState();
      }

      // NEW: Function to format state.prompts back into the editor's markdown format
      function formatPromptsForEditor(prompts) {
        let output = `# AI Prompts Configuration\n\nThis document contains the core system instructions and user queries for the AI model's operations. Edit these templates to refine the model's behavior.\n\n---\n`;
        for (const key in prompts) {
          output += `\n## ${key}\n\n\`\`\`\n${prompts[key]}\n\`\`\`\n\n---\n`;
        }
        return output.trim();
      }

      // NEW: Function to parse markdown prompt blocks into state.prompts
      function parsePrompts(markdownText) {
        const blocks = {};

        const regex = /##\s*(\w+)\s*\n+\s*```\s*([\s\S]*?)\s*```/g;
        let match;

        while ((match = regex.exec(markdownText)) !== null) {
          const key = match[1].trim();
          const content = match[2].trim();
          blocks[key] = content;
        }

        // Overwrite state prompts only if block exists
        const requiredKeys = Object.keys(state.prompts);
        let updatedCount = 0;
        requiredKeys.forEach((key) => {
          if (blocks[key]) {
            state.prompts[key] = blocks[key];
            updatedCount++;
          }
        });
        if (updatedCount > 0) {
          console.log(
            `Successfully updated ${updatedCount} prompts from editor.`,
          );
        }
      }

      // NEW: Function to save prompts
      function savePrompts() {
        // This function is now responsible for saving and parsing the prompts when the user types.
        const currentPromptText = els.promptInput.value;

        // 1. Save the raw text to localStorage for persistence
        localStorage.setItem(STORAGE_KEY_PROMPTS, currentPromptText);

        // 2. Reparse the content for immediate use in state.prompts
        parsePrompts(currentPromptText);
      }

      async function restoreSessionFromDB() {
        try {
          const pdfBlob = await getPDFFromDB();
          if (pdfBlob) {
            const lastPageNum = localStorage.getItem(STORAGE_KEY_LAST_PAGE);
            const lastFilename = localStorage.getItem(STORAGE_KEY_FILENAME);
            if (lastFilename) {
              els.restoredFilename.textContent = lastFilename;
              els.restoreBadge.classList.remove("hidden");
            }
            const arrayBuffer = await pdfBlob.arrayBuffer();
            loadPDF(arrayBuffer, lastPageNum ? parseInt(lastPageNum) : 1);
          } else {
            // NEW: Load default image if no PDF is stored
            loadDefaultImage();
          }
        } catch (error) {
          console.log("No previous session found or error loading DB:", error);
          // Fallback to loading default image if DB load fails
          loadDefaultImage();
        }
      }

      // NEW: Function to load the default image
      function loadDefaultImage() {
        // Check if a PDF is already loaded or in pending state
        if (
          (state.pdfDoc && !state.pdfDoc.isStaticImage) ||
          state.pageRendering
        )
          return;

        els.pdfLoader.classList.remove("hidden");
        els.pdfLoader.children[1].textContent = "Loading Sample Image...";

        const img = new Image();
        // Setting crossOrigin is essential for toDataURL on the canvas later
        img.crossOrigin = "anonymous";

        img.onload = function () {
          // 1. Set canvas dimensions
          state.canvas.width = img.width;
          state.canvas.height = img.height;

          // 2. Draw image
          state.ctx.drawImage(img, 0, 0);

          // 3. Mock PDF State for compatibility
          state.pdfDoc = { numPages: 1, isStaticImage: true };
          state.pageNum = 1;

          // 4. Update UI
          els.pdfLoader.classList.add("hidden");
          els.emptyState.classList.add("hidden");
          els.pageCountSpan.textContent = 1;
          els.pageNumSpan.textContent = 1;
          els.navControls.style.display = "flex";
          els.zoomControls.style.display = "none"; // Disable zoom for static image

          // Disable navigation buttons as it's a single static image
          els.prevBtn.disabled = true;
          els.nextBtn.disabled = true;

          // 5. Finalize setup
          updateOverlayWrapperSize();
          loadContentForCurrentPage(true); // Load content from storage for page 1
          els.pdfLoader.children[1].textContent = "Rendering Page..."; // Reset loader text
        };

        img.onerror = function () {
          console.error(
            "Failed to load default image from URL:",
            DEFAULT_IMAGE_URL,
          );
          els.pdfLoader.classList.add("hidden");
          els.emptyState.classList.remove("hidden"); // Show empty state if loading fails
          els.pdfLoader.children[1].textContent = "Rendering Page..."; // Reset loader text
        };

        img.src = DEFAULT_IMAGE_URL;
      }

      function loadPDF(data, pageNum = 1) {
        if (state.pdfDoc && state.pdfDoc.isStaticImage) {
          // Clear static image mock if a new PDF is being loaded
          state.pdfDoc = null;
        }

        pdfjsLib
          .getDocument(data)
          .promise.then(function (pdfDoc_) {
            state.pdfDoc = pdfDoc_;
            state.pageNum = pageNum;
            els.pageCountSpan.textContent = state.pdfDoc.numPages;
            els.emptyState.classList.add("hidden");
            els.navControls.style.display = "flex";
            els.zoomControls.style.display = "flex";
            renderPage(state.pageNum);
          })
          .catch((e) => {
            console.error("Error loading PDF data:", e);
          });
      }

      function updateOverlayWrapperSize() {
        if (els.theCanvas) {
          els.overlayWrapper.style.width = els.theCanvas.width + "px";
          els.overlayWrapper.style.height = els.theCanvas.height + "px";
        }
      }

      function queueRenderPage(num) {
        // Prevent PDF rendering if in static image mode
        if (state.pdfDoc && state.pdfDoc.isStaticImage) {
          return;
        }

        state.pageRendering ? (state.pageNumPending = num) : renderPage(num);
      }

      function loadContentForCurrentPage(forcePreviewUpdate = false) {
        const pageNum = state.pageNum;
        const overlayKey = `overlay_page_${pageNum}`;

        // Markdown logic retained in the data structure for potential future use (Export),
        // but removed from direct UI interaction logic.

        if (
          els.overlayHtmlInput.value !== (transcriptionData[overlayKey] || "")
        ) {
          els.overlayHtmlInput.value = transcriptionData[overlayKey] || "";
        }
        if (forcePreviewUpdate) {
          updateOverlayPreview();
        }
        // Ensure the correct content is shown if log is not active
        if (!state.isLogActive) {
          els.overlayHtmlInput.value = transcriptionData[overlayKey] || "";
        }
      }

      function saveContent() {
        if (!state.isAuthReady) return;
        if (state.isLogActive) return; // Do not save log content

        clearTimeout(state.saveTimeout);
        state.saveTimeout = setTimeout(() => {
          // Save Markdown data if it was somehow modified (e.g., via future feature)
          if (els.markdownInput) {
            transcriptionData[`md_page_${state.pageNum}`] =
              els.markdownInput.value;
          }

          transcriptionData[`overlay_page_${state.pageNum}`] =
            els.overlayHtmlInput.value;
          localStorage.setItem(STORAGE_KEY, JSON.stringify(transcriptionData));
          localStorage.setItem(STORAGE_KEY_LAST_PAGE, state.pageNum);

          // We assume prompt input changes are handled by its direct listener
        }, 1000);
      }

      function renderPage(num) {
        state.pageRendering = true;
        els.pdfLoader.classList.remove("hidden");
        saveContent();

        state.pdfDoc.getPage(num).then(function (page) {
          var viewport = page.getViewport({ scale: state.scale });
          state.canvas.height = viewport.height;
          state.canvas.width = viewport.width;

          var renderTask = page.render({
            canvasContext: state.ctx,
            viewport: viewport,
          });

          renderTask.promise.then(function () {
            state.pageRendering = false;
            els.pdfLoader.classList.add("hidden");
            updateOverlayWrapperSize();
            loadContentForCurrentPage(true);
            if (state.pageNumPending !== null) {
              renderPage(state.pageNumPending);
              state.pageNumPending = null;
            }
          });
        });

        els.pageNumSpan.textContent = num;
        els.prevBtn.disabled = num <= 1;
        els.nextBtn.disabled = num >= state.pdfDoc.numPages;
      }

      /**
       * Extracts a base64 string from a given rect on the current canvas.
       */
      function extractImageSnippet(pixelRect) {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = pixelRect.width;
        tempCanvas.height = pixelRect.height;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.drawImage(
          state.canvas,
          pixelRect.x,
          pixelRect.y,
          pixelRect.width,
          pixelRect.height,
          0,
          0,
          pixelRect.width,
          pixelRect.height,
        );
        return tempCanvas.toDataURL("image/png").split(",")[1];
      }

      /**
       * Helper to clone the element and strip non-internal CSS properties
       * before sending the HTML string to the AI.
       * * MODIFIED: Now returns only content, ID, width, and height.
       */
      var getDivData = function (divElement) {
        const style = divElement.getAttribute("style") || "";

        // Retrieve width and height directly from the element's style attribute
        // This is necessary because we need the dimensions, but must strip the
        // positional CSS (`left`, `top`) that the user does not want sent.
        const widthMatch = style.match(/width:\s*([^;]+)/i);
        const heightMatch = style.match(/height:\s*([^;]+)/i);

        const width = widthMatch ? widthMatch[1].trim() : "auto";
        const height = heightMatch ? heightMatch[1].trim() : "auto";

        return {
          id: divElement.id,
          content: divElement.innerHTML,
          width: width,
          height: height,
        };
      };

      // --- AI Log Logic ---
      function updateLogVisibility() {
        if (aiQueryLog.length > 0) {
          els.showAiLog.classList.remove("hidden");
        }
      }

      function renderAiLog() {
        let logContent = `// === AI Query Log (${aiQueryLog.length} entries - Latest First) ===\n\n`;

        // Note: Log entries are added to the start of the array (unshift), so map in order.
        aiQueryLog.forEach((entry, index) => {
          const status = entry.success ? "SUCCESS" : "ERROR";
          logContent += `// [${index + 1}] ${entry.timestamp} - Status: ${status}\n`;
          logContent += `// PROMPT:\n${entry.prompt}\n\n`;
          logContent += `// RESPONSE:\n${entry.response}\n\n`;
          logContent += "-------------------------------------------------\n\n";
        });

        return logContent;
      }

      window.toggleAiLog = function () {
        state.isLogActive = !state.isLogActive;

        if (state.isLogActive) {
          // Show Log
          els.overlayHtmlInput.value = renderAiLog();
          els.overlayHtmlInput.readOnly = true;
          els.editorTitle.textContent = "AI LOG";
          els.showAiLog.textContent = "[Show HTML]";
          els.editActionBar.classList.add("disabled-bar"); // Always disable bar when in log view
        } else {
          // Show HTML
          loadContentForCurrentPage(false); // Reload current page HTML content
          els.overlayHtmlInput.readOnly = false;
          els.editorTitle.textContent = "OVERLAY HTML";
          els.showAiLog.textContent = "[AI Log]";
          updateEditBarState(); // Re-evaluate bar state based on cursor
        }
      };

      /**
       * Generic Gemini API Call Wrapper
       * UPDATED: Robust Array Handling for Images and Logging
       */
      async function queryGemini(prompt, images) {
        els.aiStatus.style.display = "inline";
        els.aiStatus.textContent = "AI Processing...";

        // 1. Prepare Log Entry (strictly append-only)
        const logEntry = {
          timestamp: new Date().toLocaleTimeString(),
          prompt: prompt,
          response: "Awaiting response...",
          success: false,
        };
        aiQueryLog.unshift(logEntry); // Add to start of log
        updateLogVisibility(); // Ensure log button is visible
        if (state.isLogActive) toggleAiLog(); // Refresh log view if active

        let resultText = "";

        try {
          // Construct the prompt parts
          const parts = [{ text: prompt }];

          if (Array.isArray(images)) {
            // Multiple images
            images.forEach((img) => {
              parts.push({ inlineData: { mimeType: "image/png", data: img } });
            });
          } else if (images) {
            // Single image
            parts.push({ inlineData: { mimeType: "image/png", data: images } });
          }

          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                contents: [
                  {
                    role: "user",
                    parts: parts,
                  },
                ],
              }),
            },
          );

          if (!response.ok)
            throw new Error(
              `API request failed with status: ${response.status}`,
            );
          const data = await response.json();

          resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;

          els.aiStatus.textContent = "Done!";
          setTimeout(() => (els.aiStatus.style.display = "none"), 2000);

          // 2. Update Log on Success
          logEntry.response = resultText || "No text response received.";
          logEntry.success = true;
          if (state.isLogActive) toggleAiLog();

          return resultText;
        } catch (error) {
          console.error("AI Error:", error);
          els.aiStatus.textContent = "Error!";
          setTimeout(() => (els.aiStatus.style.display = "none"), 2000);

          // 2. Update Log on Error
          logEntry.response = `Error: ${error.message}`;
          logEntry.success = false;
          if (state.isLogActive) toggleAiLog();

          throw error;
        }
      }

      function parseAIJson(text) {
        try {
          // Try to find a JSON block first
          const jsonMatch = text.match(/\{[\s\S]*\}/);
          if (jsonMatch) return JSON.parse(jsonMatch[0]);
          return JSON.parse(text);
        } catch (e) {
          return null;
        }
      }

      // --- DOM Modification Helpers (Non-AI) ---

      // 1. Unified Parser for DOM Updates (Robust)
      function updateDOMWithCallback(callback) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(
          `<body>${els.overlayHtmlInput.value}</body>`,
          "text/html",
        );

        if (callback(doc)) {
          // If modification happened
          els.overlayHtmlInput.value = doc.body.innerHTML;
          updateOverlayPreview();
          saveContent();
          return true;
        }
        return false;
      }

      window.updateStyle = function (property, value) {
        if (!state.targetDivId) return;

        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            target.style[property] = value;
            return true;
          }
          return false;
        });
      };

      window.deleteDiv = function () {
        if (!state.targetDivId) return;
        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            target.remove();
            state.targetDivId = null;
            window.closeSelection(); // Hide the box and disable edit bar
            return true;
          }
          return false;
        });
      };

      window.clearStyles = function () {
        if (!state.targetDivId) return;
        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(state.targetDivId);
          if (target) {
            // Keep positioning, clear typography
            const left = target.style.left;
            const top = target.style.top;
            const width = target.style.width;
            const height = target.style.height;

            target.removeAttribute("style");

            // Restore Layout
            target.style.position = "absolute";
            target.style.left = left;
            target.style.top = top;
            target.style.width = width;
            target.style.height = height;
            target.style.background = "rgba(255,255,255,0.7)"; // Consistent background color
            target.style.padding = "0px";
            target.style.margin = "0px";
            target.style.overflowWrap = "break-word";
            target.style.overflow = "hidden";
            target.style.lineHeight = "1.0";
            return true;
          }
          return false;
        });
      };

      window.snapLayout = function (type) {
        if (!state.targetDivId) return;

        if (type === "page-width") {
          window.updateStyle("left", "0%");
          window.updateStyle("width", "100%");
        } else if (type === "margin-standard") {
          // Simulate ~1 inch margins (approx 10%)
          window.updateStyle("left", "10%");
          window.updateStyle("width", "80%");
        } else if (type === "center") {
          window.updateStyle("left", "15%");
          window.updateStyle("width", "70%");
        }
      };

      // --- Debug Vision Logic (New) ---

      /**
       * Shows the captured images in a modal for visual inspection.
       */
      function showAiVisionDebug(sourceB64, renderB64, dimensions) {
        // Update content
        els.debugSourceImg.src = `data:image/png;base64,${sourceB64}`;
        els.debugRenderImg.src = `data:image/png;base64,${renderB64}`;

        // Update labels to show dimensions being sent to AI
        document.getElementById("debug-source-label").textContent =
          `1. TARGET (Source PDF Image) - ${dimensions.native}`;
        document.getElementById("debug-render-label").textContent =
          `2. TEST RENDER (Current HTML View) - ${dimensions.scaled}`;

        // Show overlay
        els.debugOverlay.style.display = "flex";
      }

      window.showDebugView = function () {
        if (!state.targetDivId) return;
        const divEl = document.getElementById(state.targetDivId);
        if (!divEl) return;

        // Use the logic from runAiReplica to get the images and dimensions
        const base64Source = getSnippetFromDiv(state.targetDivId);

        html2canvas(divEl, {
          backgroundColor: "#ffffff",
          scale: 2,
          logging: false,
          useCORS: true,
          allowTaint: true,
        })
          .then((canvas) => {
            const base64Render = canvas.toDataURL("image/png").split(",")[1];

            const scaledPixelWidth = divEl.clientWidth;
            const scaledPixelHeight = divEl.clientHeight;
            const currentScale =
              state.pdfDoc && state.pdfDoc.isStaticImage ? 1.0 : state.scale;
            const nativePixelWidth = Math.round(
              scaledPixelWidth / currentScale,
            );
            const nativePixelHeight = Math.round(
              scaledPixelHeight / currentScale,
            );

            const dimensions = {
              scaled: `W:${scaledPixelWidth}px, H:${scaledPixelHeight}px (Scale: ${currentScale})`,
              native: `W:${nativePixelWidth}px, H:${nativePixelHeight}px (Original)`,
            };

            showAiVisionDebug(base64Source, base64Render, dimensions);
          })
          .catch((e) => {
            console.error("Debug capture failed", e);
          });
      };

      els.closeDebugVision.addEventListener("click", () => {
        els.debugOverlay.style.display = "none";
      });

      // --- Selection & Interaction Logic ---

      // 1. Shared Logic to Activate Edit Mode for a Div
      function activateDivEditMode(divElement, clickEvent = null) {
        if (!divElement) return;
        state.targetDivId = divElement.id;

        // Hide non-editing bars
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";

        // Enable the Edit Action Bar (which is always visible)
        els.editActionBar.classList.remove("disabled-bar");

        // Calculate Position
        const cw = els.theCanvas.width;
        const ch = els.theCanvas.height;
        const l = (parseFloat(divElement.style.left) / 100) * cw;
        const t = (parseFloat(divElement.style.top) / 100) * ch;
        const w = (parseFloat(divElement.style.width) / 100) * cw;
        const h = (parseFloat(divElement.style.height) / 100) * ch;

        // Draw Box
        els.selectionBox.style.left = l + "px";
        els.selectionBox.style.top = t + "px";
        els.selectionBox.style.width = w + "px";
        els.selectionBox.style.height = h + "px";
        els.selectionBox.style.display = "block";
        els.selectionBox.classList.add("edit-mode");

        // Auto Scroll to view if offscreen (only if in overlay view)
        if (state.activeTab === "overlay") {
          divElement.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      }

      // Helper: Get Div ID from Editor Cursor
      function getTargetDivIdFromCursor() {
        const cursor = els.overlayHtmlInput.selectionStart;
        const text = els.overlayHtmlInput.value;
        let openIndex = -1;
        let balance = 0;

        for (let i = cursor - 1; i >= 0; i--) {
          if (text.substring(i, i + 4) === "<div") {
            if (balance === 0) {
              openIndex = i;
              break;
            }
            balance--;
          } else if (text.substring(i, i + 5) === "/div>") {
            balance++;
          }
        }

        if (openIndex !== -1) {
          const tagEnd = text.indexOf(">", openIndex);
          if (tagEnd !== -1) {
            const tagContent = text.substring(openIndex, tagEnd);
            const match = tagContent.match(/id=["']([^"']+)["']/);
            return match ? match[1] : null;
          }
        }
        return null;
      }

      // NEW: Function to manage the state of the edit bar
      function updateEditBarState() {
        // If log is active, keep the bar disabled
        if (state.isLogActive) {
          els.editActionBar.classList.add("disabled-bar");
          return;
        }

        const divId = getTargetDivIdFromCursor();

        if (divId) {
          els.editActionBar.classList.remove("disabled-bar");
          state.targetDivId = divId; // Set target ID immediately on cursor focus
        } else {
          els.editActionBar.classList.add("disabled-bar");
          state.targetDivId = null;
          els.selectionBox.style.display = "none"; // Also hide the box when cursor leaves the div
          els.selectionBox.classList.remove("edit-mode");
        }
      }

      // 2. Editor Interaction (Listeners)
      els.overlayHtmlInput.addEventListener("input", updateEditBarState);
      els.overlayHtmlInput.addEventListener("click", updateEditBarState);
      els.overlayHtmlInput.addEventListener("keyup", updateEditBarState); // Ensure it catches arrow key movement

      // Right click on editor to trigger action bar (Kept as a fallback, but primary activation is left click on canvas)
      els.overlayHtmlInput.addEventListener("contextmenu", (e) => {
        if (state.isLogActive) return; // Ignore input when log is active

        const divId = getTargetDivIdFromCursor();
        if (divId) {
          const divEl = document.getElementById(divId);
          if (divEl) {
            e.preventDefault(); // Stop native menu
            // Use left-click activation logic for visual feedback
            activateDivEditMode(divEl, e);
          }
        }
      });

      // 3. Mouse Interaction (Canvas)
      function getPointerPos(e) {
        const rect = els.selectionLayer.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      // Context Menu Handler (Right Click) - REMOVED - Unified interaction is in mouseup
      // els.selectionLayer.addEventListener('contextmenu', (e) => { ... });

      els.selectionLayer.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;

        // Hide non-editing bars
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";
        els.editActionBar.classList.add("disabled-bar"); // Disable edit bar during potential selection

        state.isSelecting = true;
        state.selectionStart = getPointerPos(e);
        els.selectionBox.style.display = "block";
        els.selectionBox.style.width = "0px";
        els.selectionBox.style.height = "0px";
        els.selectionBox.classList.remove("edit-mode"); // Always start as new selection mode
      });

      els.selectionLayer.addEventListener("mousemove", (e) => {
        if (!state.isSelecting) return;
        const currentPos = getPointerPos(e);
        const x = Math.min(state.selectionStart.x, currentPos.x);
        const y = Math.min(state.selectionStart.y, currentPos.y);
        const width = Math.abs(currentPos.x - state.selectionStart.x);
        const height = Math.abs(currentPos.y - state.selectionStart.y);

        els.selectionBox.style.left = x + "px";
        els.selectionBox.style.top = y + "px";
        els.selectionBox.style.width = width + "px";
        els.selectionBox.style.height = height + "px";
      });

      els.selectionLayer.addEventListener("mouseup", (e) => {
        if (!state.isSelecting) return;
        state.isSelecting = false;

        const currentPos = getPointerPos(e);
        const width = Math.abs(currentPos.x - state.selectionStart.x);
        const height = Math.abs(currentPos.y - state.selectionStart.y);

        // 1. CHECK FOR CLICK ON EXISTING DIV (UNIFIED LEFT-CLICK ACTIVATION)
        const elements = document.elementsFromPoint(e.clientX, e.clientY);
        const clickedDiv = elements.find(
          (el) =>
            el.parentElement &&
            el.parentElement.id === "overlay-html-layer" &&
            el.id &&
            el.id.startsWith("div-"),
        );

        if (clickedDiv) {
          // Clicked on an existing div. Activate edit mode for it.
          activateDivEditMode(clickedDiv, e);
          els.actionBar.style.display = "none"; // Ensure new selection bar is hidden
          return;
        }

        // 2. CHECK FOR INVALID DRAG (Too small)
        if (width < 10 || height < 10) {
          // If it was a small movement (a failed click or small drag) and no DIV was hit, hide box and stop.
          els.selectionBox.style.display = "none";
          els.editActionBar.classList.add("disabled-bar"); // Ensure edit bar is disabled if no div was selected
          return;
        }

        // 3. NEW SELECTION LOGIC (Drag occurred)

        const canvasW = els.theCanvas.width;
        const canvasH = els.theCanvas.height;
        const x = Math.min(state.selectionStart.x, currentPos.x);
        const y = Math.min(state.selectionStart.y, currentPos.y);

        state.selectionRect = {
          left: (x / canvasW) * 100,
          top: (y / canvasH) * 100,
          width: (width / canvasW) * 100,
          height: (height / canvasH) * 100,
          pixelX: x,
          pixelY: y,
          pixelW: width,
          pixelH: height,
        };

        // --- Show Action Bar for NEW selection ---
        // Calculate absolute position on screen
        const rect = els.selectionLayer.getBoundingClientRect();
        const absX = rect.left + x;
        const absY = rect.top + y + height;

        const barWidth = 180;
        let barLeft = absX + width / 2 - barWidth / 2;
        let barTop = absY + 10;

        // Boundary checks
        if (barLeft < 10) barLeft = 10;
        if (barLeft + barWidth > window.innerWidth)
          barLeft = window.innerWidth - barWidth - 10;
        if (barTop + 50 > window.innerHeight) {
          barTop = rect.top + y - 60;
        }

        els.actionBar.style.left = barLeft + "px";
        els.actionBar.style.top = barTop + "px";
        els.actionBar.style.display = "flex";
      });

      document.addEventListener("click", (e) => {
        // If we click outside the whole editor pane (including the action bar)
        if (e.target.closest("#overlay-container") === null) {
          window.closeSelection();
        }
      });

      // --- Logic Hooks ---

      els.chkShowSource.addEventListener("change", (e) => {
        els.overlayCanvasMount.style.opacity = e.target.checked ? "1" : "0";
      });
      els.chkShowOverlay.addEventListener("change", (e) => {
        els.overlayHtmlLayer.style.display = e.target.checked
          ? "block"
          : "none";
      });

      els.btnCreateDiv.addEventListener("click", () => {
        insertDiv("Placeholder Content");
        window.closeSelection();
      });

      els.btnCopyImage.addEventListener("click", () => {
        const base64 = extractImageSnippet({
          x: state.selectionRect.pixelX,
          y: state.selectionRect.pixelY,
          width: state.selectionRect.pixelW,
          height: state.selectionRect.pixelH,
        });
        insertImage(`data:image/png;base64,${base64}`);
        window.closeSelection();
      });

      // Simplified Digitize (Text Only)
      els.btnDigitize.addEventListener("click", async () => {
        window.closeSelection();
        const base64 = extractImageSnippet({
          x: state.selectionRect.pixelX,
          y: state.selectionRect.pixelY,
          width: state.selectionRect.pixelW,
          height: state.selectionRect.pixelH,
        });

        // Use the editable prompt
        const prompt = state.prompts.DIGITIZE_TEXT;

        try {
          const resultText = await queryGemini(prompt, base64);
          // The insertDiv function now handles the heuristic padding reset
          insertDiv(resultText.trim());
        } catch (e) {
          /* Error handled in wrapper */
        }
      });

      // === AI Style Features (Refactored to global functions) ===

      function getSnippetFromDiv(divId) {
        const div = document.getElementById(divId);
        if (!div) return null;

        const cw = els.theCanvas.width;
        const ch = els.theCanvas.height;
        const pixelRect = {
          x: (parseFloat(div.style.left) / 100) * cw,
          y: (parseFloat(div.style.top) / 100) * ch,
          width: (parseFloat(div.style.width) / 100) * cw,
          height: (parseFloat(div.style.height) / 100) * ch,
        };
        return extractImageSnippet(pixelRect);
      }

      /**
       * Helper to clone the element and strip non-internal CSS properties
       * before sending the HTML string to the AI.
       * * MODIFIED: Now returns only content, ID, width, and height.
       */
      var getDivData = function (divElement) {
        const style = divElement.getAttribute("style") || "";

        // Retrieve width and height directly from the element's style attribute
        // This is necessary because we need the dimensions, but must strip the
        // positional CSS (`left`, `top`) that the user does not want sent.
        const widthMatch = style.match(/width:\s*([^;]+)/i);
        const heightMatch = style.match(/height:\s*([^;]+)/i);

        const width = widthMatch ? widthMatch[1].trim() : "auto";
        const height = heightMatch ? heightMatch[1].trim() : "auto";

        return {
          id: divElement.id,
          content: divElement.innerHTML,
          width: width,
          height: height,
        };
      };

      // 1. Replica: VISUAL COMPARISON (Now expects inner HTML string)
      window.runAiReplica = async function () {
        const divId = state.targetDivId;
        if (!divId) return;
        els.editActionBar.classList.add("disabled-bar");

        if (typeof html2canvas === "undefined") {
          return;
        }

        const base64Source = getSnippetFromDiv(divId);
        const divEl = document.getElementById(divId);
        if (!divEl) return;

        els.aiStatus.style.display = "inline";
        els.aiStatus.textContent = "Capturing...";

        try {
          // Capture the current appearance of the element we are trying to fix
          const canvas = await html2canvas(divEl, {
            backgroundColor: "#ffffff",
            scale: 2,
            logging: false,
            useCORS: true,
            allowTaint: true,
          });
          const base64Render = canvas.toDataURL("image/png").split(",")[1];

          // 1. Get current state to send to AI
          const internalState = getDivData(divEl);

          // --- FIX: Use correctly calculated NATIVE pixel value for context ---
          const scaledPixelWidth = divEl.clientWidth;
          const scaledPixelHeight = divEl.clientHeight;

          // Determine current effective rendering scale (1.0 for static images, state.scale for PDFs)
          const currentScale =
            state.pdfDoc && state.pdfDoc.isStaticImage ? 1.0 : state.scale;

          // Calculate Native (unscaled) dimensions
          const nativePixelWidth = Math.round(scaledPixelWidth / currentScale);
          const nativePixelHeight = Math.round(
            scaledPixelHeight / currentScale,
          );

          const dimensions = {
            scaled: `W:${scaledPixelWidth}px, H:${scaledPixelHeight}px (Scale: ${currentScale})`,
            native: `W:${nativePixelWidth}px, H:${nativePixelHeight}px (Original)`,
          };

          // CRITICAL FIX: Explicitly name the native size as the Reference Frame for the AI.

          const promptDimensions = `Reference Frame (Native Scan Resolution): W:${nativePixelWidth}px, H:${nativePixelHeight}px. Current Viewport Scale: ${currentScale}.`;

          // Show the comparison debug view before calling the AI (500ms delay for visibility)
          showAiVisionDebug(base64Source, base64Render, dimensions);
          await new Promise((resolve) => setTimeout(resolve, 5000));
          els.debugOverlay.style.display = "none";

          // Use the editable prompt and substitute current dimensions and content
          let prompt = state.prompts.REPLICA_STYLE;
          prompt = prompt.replace("{{dimensions}}", promptDimensions);
          prompt = prompt.replace("{{content}}", internalState.content);

          // Query AI, expecting the raw new INNER HTML of the div
          const resultHtml = await queryGemini(prompt, [
            base64Source,
            base64Render,
          ]);

          // Check if AI actually returned content. If not, log error and exit gracefully.
          if (!resultHtml) {
            els.aiStatus.textContent = "AI Error (Empty Response)";
            setTimeout(() => (els.aiStatus.style.display = "none"), 2000);
            els.editActionBar.classList.remove("disabled-bar");
            console.error(
              "AI Replica failed: received null/undefined resultHtml.",
            );
            return;
          }

          // Use a function to update the content, preserving the outer positional styles
          updateDivContent(divId, resultHtml);
        } catch (e) {
          console.error(e);
          els.aiStatus.textContent = "Error";
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // 2. Match Font: Style Heuristics only (CSS on Container)
      window.runAiFont = async function () {
        const divId = state.targetDivId;
        if (!divId) return;
        els.editActionBar.classList.add("disabled-bar");

        const base64 = getSnippetFromDiv(divId);

        // Use the editable prompt
        const prompt = state.prompts.FONT_STYLE;

        try {
          const resultText = await queryGemini(prompt, base64);
          if (!resultText) {
            console.error("AI Font failed: received null/undefined result.");
            els.aiStatus.textContent = "AI Error (Empty Response)";
            setTimeout(() => (els.aiStatus.style.display = "none"), 2000);
            els.editActionBar.classList.remove("disabled-bar");
            return;
          }

          const styles = parseAIJson(resultText);

          if (styles) {
            updateDOMWithCallback((doc) => {
              const target = doc.getElementById(divId);
              if (target) {
                if (styles.fontFamily)
                  target.style.fontFamily = styles.fontFamily;
                if (styles.fontWeight)
                  target.style.fontWeight = styles.fontWeight;
                if (styles.fontStyle) target.style.fontStyle = styles.fontStyle;
                if (styles.textAlign) target.style.textAlign = styles.textAlign;
                if (styles.fontSize) target.style.fontSize = styles.fontSize;
                return true;
              }
              return false;
            });
          }
          els.editActionBar.classList.remove("disabled-bar");
        } catch (e) {
          console.error(e);
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // 3. Flow: Text Only (Clean Transcription)
      window.runAiText = async function () {
        const divId = state.targetDivId;
        if (!divId) return;
        els.editActionBar.classList.add("disabled-bar");

        const base64 = getSnippetFromDiv(divId);

        // Use the editable prompt
        const prompt = state.prompts.TEXT_ONLY;

        try {
          const resultHtml = await queryGemini(prompt, base64);

          if (!resultHtml) {
            console.error("AI Text failed: received null/undefined result.");
            els.aiStatus.textContent = "AI Error (Empty Response)";
            setTimeout(() => (els.aiStatus.style.display = "none"), 2000);
            els.editActionBar.classList.remove("disabled-bar");
            return;
          }

          updateDivContent(divId, resultHtml);
          els.editActionBar.classList.remove("disabled-bar");
        } catch (e) {
          console.error(e);
          els.editActionBar.classList.remove("disabled-bar");
        }
      };

      // Helpers
      window.closeSelection = function () {
        els.selectionBox.style.display = "none";
        els.selectionBox.classList.remove("edit-mode");
        els.contextMenu.style.display = "none";
        els.actionBar.style.display = "none";
        els.editActionBar.classList.add("disabled-bar"); // Disable edit bar
        state.targetDivId = null;
      };

      function insertDiv(content, styles = {}) {
        const rect = state.selectionRect;
        const l = rect.left.toFixed(2);
        const t = rect.top.toFixed(2);
        const w = rect.width.toFixed(2);
        const h = rect.height.toFixed(2);
        const id = `div-${Date.now()}`;

        const safeContent = content
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\n/g, "<br>");

        // HEURISTIC UPDATE:
        // 1. Padding: 0px (User Request)
        // 2. Margin: 0px (User Request)
        // 3. Line-height: 1.0 (Strict print alignment)
        // 4. Font-size: 14px (Starting point)

        let styleStr = `position: absolute; left: ${l}%; top: ${t}%; width: ${w}%; height: ${h}%; background: rgba(255,255,255,0.7); padding: 0px; margin: 0px; overflow-wrap: break-word; overflow: hidden;`;
        //let there be no font styling in this div, as it serves as container.
        //styleStr += ` font-size: 14px; line-height: 1.0; font-family: 'Times New Roman', serif;`;

        appendHtml(`<div id="${id}" style="${styleStr}">${safeContent}</div>`);

        // Trigger Smart Fit Heuristic after DOM update
      }

      function insertImage(dataUrl) {
        const l = state.selectionRect.left.toFixed(2);
        const t = state.selectionRect.top.toFixed(2);
        const w = state.selectionRect.width.toFixed(2);
        const h = state.selectionRect.height.toFixed(2);
        appendHtml(
          `<img src="${dataUrl}" style="position: absolute; left: ${l}%; top: ${t}%; width: ${w}%; height: ${h}%; object-fit: contain;" />`,
        );
      }

      function appendHtml(str) {
        const input = els.overlayHtmlInput;
        input.value = input.value + str;
        updateOverlayPreview();
        saveContent();
      }

      function updateDivContent(divId, newContent) {
        // FIX: Add robust check for null/undefined content immediately.
        if (!newContent) {
          console.error(
            `AI response returned empty content (undefined or null) for div ${divId}. Skipping update.`,
          );
          els.aiStatus.textContent = "AI Error (Empty Response)";
          setTimeout(() => (els.aiStatus.style.display = "none"), 2000);
          els.editActionBar.classList.remove("disabled-bar");
          return;
        }

        updateDOMWithCallback((doc) => {
          const target = doc.getElementById(divId);
          if (target) {
            const cleanedContent = newContent
              .replace(/```html/g, "")
              .replace(/```/g, "")
              .trim();

            // Apply new inner HTML
            target.innerHTML = cleanedContent;

            // NOTE: The previous check for wrapped content is complex and potentially prone to false positives/negatives,
            // but the core fix is ensuring we only replace innerHTML, which is maintained.

            return true;
          }
          return false;
        });
        // Re-run fitting if content changed (may be needed if content structure changes height)
        els.editActionBar.classList.remove("disabled-bar");
      }

      // --- Added for context menu click handlers ---
      els.workspace = document.getElementById("workspace");

      // --- Core Application Logic ---
      els.upload.addEventListener("change", function (e) {
        var file = e.target.files[0];
        if (file.type !== "application/pdf") return;
        state.pageNum = 1;
        localStorage.setItem(STORAGE_KEY_FILENAME, file.name);
        els.restoredFilename.textContent = file.name;
        els.restoreBadge.classList.add("hidden");
        savePDFToDB(file).catch((err) =>
          console.error("Error saving PDF to DB:", err),
        );
        var fileReader = new FileReader();
        fileReader.onload = function () {
          var typedarray = new Uint8Array(this.result);
          loadPDF(typedarray, 1);
        };
        fileReader.readAsArrayBuffer(file);
      });

      // window.updatePreview is now unused

      function updateOverlayPreview() {
        els.overlayHtmlLayer.innerHTML = els.overlayHtmlInput.value;
        renderMathInElement(els.overlayHtmlLayer, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false },
          ],
          throwOnError: false,
        });
      }

      function switchMainView(viewId) {
        saveContent();
        state.activeTab = viewId;

        // Only Overlay and Prompts are active tabs
        if (viewId === "overlay") {
          // The canvas is mounted to overlayCanvasMount in the Overlay tab
          if (!els.overlayCanvasMount.contains(els.theCanvas))
            els.overlayCanvasMount.appendChild(els.theCanvas);
          updateOverlayPreview();
        } else if (viewId === "prompts") {
          // Ensure the editor reflects the current in-memory state when loading the tab
          // This is crucial for enabling editing based on the latest state
          els.promptInput.value = formatPromptsForEditor(state.prompts);
        }

        const containers = {
          source: els.sourceContainer, // Kept hidden/background container
          overlay: els.overlayContainer,
          write: els.editorContainerMd, // Kept hidden/background container
          preview: els.previewContainer, // Kept hidden/background container
          prompts: els.editorContainerPrompts,
        };
        const buttons = {
          overlay: els.tabOverlay,
          prompts: els.tabPrompts,
        };

        // FIX: Add null check for containers and buttons before accessing classList
        Object.values(containers).forEach((c) => {
          if (c) c.classList.add("hidden");
        });
        Object.values(buttons).forEach((b) => {
          if (b) b.classList.remove("active");
        });

        if (containers[viewId]) containers[viewId].classList.remove("hidden");
        if (buttons[viewId]) buttons[viewId].classList.add("active");

        // Always revert from log view when switching tabs
        if (state.isLogActive) {
          state.isLogActive = false;
        }
      }

      els.overlayHtmlInput.addEventListener("input", () => {
        if (!state.isLogActive) {
          updateOverlayPreview();
          saveContent();
        }
      });

      // Listener for the prompt input: saves and parses the text immediately upon input change
      els.promptInput.addEventListener("input", savePrompts);
      // Also save/parse on blur/change for reliable update if a paste occurs
      els.promptInput.addEventListener("blur", savePrompts);

      els.tabOverlay.addEventListener("click", () => switchMainView("overlay"));
      els.tabPrompts.addEventListener("click", () => switchMainView("prompts"));
      els.prevBtn.addEventListener("click", () => {
        if (state.pdfDoc && !state.pdfDoc.isStaticImage && state.pageNum > 1) {
          state.pageNum--;
          queueRenderPage(state.pageNum);
        }
      });
      els.nextBtn.addEventListener("click", () => {
        if (
          state.pdfDoc &&
          !state.pdfDoc.isStaticImage &&
          state.pageNum < state.pdfDoc.numPages
        ) {
          state.pageNum++;
          queueRenderPage(state.pageNum);
        }
      });
      els.zoomInBtn.addEventListener("click", () => {
        if (state.pdfDoc && state.pdfDoc.isStaticImage) return; // Ignore if static image
        state.scale += 0.2;
        els.zoomLevelSpan.innerText = Math.round(state.scale * 100) + "%";
        queueRenderPage(state.pageNum);
      });
      els.zoomOutBtn.addEventListener("click", () => {
        if (state.pdfDoc && state.pdfDoc.isStaticImage) return; // Ignore if static image
        if (state.scale > 0.4) {
          state.scale -= 0.2;
          els.zoomLevelSpan.innerText = Math.round(state.scale * 100) + "%";
          queueRenderPage(state.pageNum);
        }
      });
      els.fullscreenBtn.addEventListener("click", () => {
        document.fullscreenElement
          ? document.exitFullscreen()
          : document.documentElement.requestFullscreen();
      });

      initPersistence();
      switchMainView("overlay");
    </script>
  </body>
</html>
