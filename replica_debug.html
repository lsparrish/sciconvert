<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alternating Alignment Engine (Lean)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      body {
        background-color: #1f2937;
        overflow: hidden;
        font-family: sans-serif;
        height: 100vh;
      }
      .editor {
        font-family: monospace;
      }
      #overlay-html-layer * {
        margin: 0;
        padding: 0;
        left: 0%;
        top: 0%;
        box-sizing: border-box;
        line-height: 1;
      }
      .tab {
        @apply px-3 py-1 text-xs cursor-pointer text-gray-400 hover:text-white border-b-2 border-transparent;
      }
      .tab.active {
        @apply text-green-400 border-green-400 bg-gray-900;
      }
      .image-thumbnail-payload {
        width: 100px;
        height: auto;
        margin-top: 5px;
        border: 1px solid #4b5563;
        border-radius: 4px;
      }
      .log-pre {
        white-space: pre-wrap;
        background: #111827;
        padding: 0.5rem;
        border-radius: 4px;
        color: #d1d5db;
        font-size: 0.7rem;
        max-height: 150px;
        overflow-y: auto;
      }
      .log-history-entry {
        border-bottom: 1px solid #374151;
        padding-bottom: 1rem;
        margin-bottom: 1rem;
      }
      .mode-position {
        color: #60a5fa;
      }
      .mode-size {
        color: #fca311;
      }
      /* Ensure canvas elements are layered correctly */
      #view-canvas {
        z-index: 10;
      }
      #overlay-html-layer {
        z-index: 0;
      }
    </style>
  </head>
  <body class="flex flex-col h-screen text-white">
    <header
      class="bg-gray-900 p-2 flex justify-between items-center shadow border-b border-gray-800"
    >
      <h1 class="font-bold text-purple-400 tracking-wider">
        Alternating Alignment Engine (<span id="current-mode-display">---</span
        >)
      </h1>
      <button
        id="fullscreen-btn"
        class="bg-gray-700 hover:bg-gray-600 p-2 rounded-lg transition text-gray-300"
        onclick="document.documentElement.requestFullscreen()"
      >
        Full Screen
      </button>
      <div class="flex items-center gap-2">
        <span id="ai-status" class="text-blue-400 text-xs font-mono hidden"
          >Processing...</span
        >
        <input
          type="number"
          id="loop-count"
          value="4"
          min="2"
          max="10"
          class="w-12 bg-gray-800 text-center text-sm border border-gray-700 rounded"
        />
        <button
          id="run-btn"
          class="bg-purple-600 hover:bg-purple-500 px-3 py-1 text-sm rounded"
        >
          Run
        </button>
      </div>
    </header>

    <main class="flex-1 flex overflow-hidden">
      <div class="w-1/2 flex flex-col bg-gray-800 relative overflow-hidden">
        <div class="overflow-hidden flex-1 relative">
          <div id="wrapper" class="bg-white text-black absolute inset-0">
            <canvas id="view-canvas" class="absolute inset-0"></canvas>
            <div id="overlay-html-layer" class="absolute inset-0"></div>
          </div>
        </div>
      </div>

      <div class="w-1/2 flex flex-col bg-gray-800">
        <div class="flex border-b border-gray-800 bg-gray-800">
          <button id="tab-html" class="tab active" onclick="setTab('html')">
            HTML
          </button>
          <button id="tab-log" class="tab" onclick="setTab('log')">
            Diagnostic Log
          </button>
        </div>

        <div class="flex-1 w-full relative">
          <textarea
            id="debug-textarea"
            class="editor absolute inset-0 p-4 bg-gray-900 text-green-400 text-xs outline-none border-none resize-none"
          ></textarea>

          <div
            id="debug-log-view"
            class="absolute inset-0 p-4 bg-gray-900 text-white text-xs overflow-auto hidden"
          ></div>
        </div>
      </div>
    </main>

    <canvas id="target-canvas-ai" style="display: none"></canvas>
    <canvas id="render-canvas-ai" style="display: none"></canvas>
    <canvas id="overlap-canvas" style="display: none"></canvas>

    <script type="module">
      const apiKey = "";
      const SAMPLE_URL = "https://lsparrish.github.io/sciconvert/sample.png";
      const TEST_ID = "div-test-block";

      const DEFAULT_AI_SCALE = 0.5;
      const FINAL_AI_SCALE = 2.0;

      // --- FOCUSED PROMPT TEMPLATES ---

      // Template for POSITION Correction (Odd Runs: 1, 3, 5...)
      const POSITION_TEMPLATE = `# ROLE: FOCUSED POSITION ALIGNMENT
You are a Visual Alignment Engine strictly focused on matching the **X and Y coordinates (position)** of text elements.

# OBJECTIVE
Analyze the visuals (Target/Red Border vs. Current Render/Blue Border). Your SOLE goal is to issue JSON commands to align the top-left corner of the currently rendered text to the target text.
**Priority: Adjust position (top/left) only.**

{{positionCommands}}

# ANALYSIS STEPS
1. Delta Check: precise difference in X/Y coordinates compared to Target.
2. History Check: Did the previous move overshoot? If yes, apply damping.
3. Focus: Ignore size/font commands. Only adjust position.

# OUTPUT RULES
- Return **ONLY** a raw JSON object. No markdown, no commentary.
- Precision: Coefficients must use 2 decimal places (e.g., 0.50).
- Efficiency: Only include elements that require position changes.

# INPUT DATA
{{constraint}}
{{structure}}

# RESPONSE FORMAT
{
  "element-id": [
    { "action": "moveUp", "coefficient": 0.50 }
  ]
}`;

      // Template for SIZE Correction (Even Runs: 2, 4, 6...)
      const SIZE_TEMPLATE = `# ROLE: FOCUSED SIZE ALIGNMENT
You are a Visual Alignment Engine strictly focused on matching the **size** of text elements.

# OBJECTIVE
Analyze the visuals (Target/Red Border vs. Current Render/Blue Border). Your SOLE goal is to issue JSON commands to match the width and height of the currently rendered text to the target text by adjusting its scale (**fontSize**).
**Priority: Adjust size (grow/shrink) only.**

{{sizeCommands}}

# OUTPUT RULES
- Return **ONLY** a raw JSON object. No markdown, no commentary.
- Precision: Coefficients must use 2 decimal places (e.g., 0.50).
- Efficiency: Only include elements that require size changes.

# ANALYSIS STEPS
1. Delta Check: precise difference in current font size compared to Target size.
2. History Check: Did the previous size change overshoot? If yes, apply damping.
3. Constraint Check: Ensure 'grow' does not violate the max vertical extent.
4. Focus: Ignore position/font commands. Only adjust size.

# OUTPUT RULES
- Return ONLY a raw JSON object. No markdown formatting, no conversational text.
- Precision: Coefficients must use 2 decimal places (e.g., 0.50).
- Efficiency: Only include elements that require size changes.

# INPUT DATA
{{constraint}}
{{structure}}

# RESPONSE FORMAT
{
  "element-id": [
    { "action": "grow", "coefficient": 0.25 }
  ]
}`;

      let currentRunScale = DEFAULT_AI_SCALE;
      let img;

      // Initial Content
      const INITIAL_HTML = `<div id="${TEST_ID}" style="position: absolute; left: 4.92%; top: 2.34%; width: 88.80%; height: 26.53%; background: rgba(255,255,255,0.7); padding: 0px; margin: 0px; "> 
<p>Journal of the British Interplanetary Society, Vol. 36, pp. 115-128, 1983.</p>

<p>ORBITAL RING SYSTEMS AND JACOB'S LADDERS - II</p>

<p>PAUL BIRCH*</p>
<p>45, Brownville Road, Heaton Moor, Stockport, England.</p>

<p>A method of transferring payloads into space without using rockets has been presented in Part I, in which massive
rings encircle the globe in a low orbit supporting stationary 'sky-hooks,' from which cables hang down to any point on
the Earth's surface. Vehicles can climb up these 'ladders' into orbit, or can accelerate along the rings. The structure and
deployment of such Orbital Ring Systems is examined and their varied uses considered; several scenarios are considered
and shown to be economically feasible and beneficial.</p></div>`;

      // State
      const state = {
        // history: { score: string, commands: object, resultImage: base64String, structure: { elements, maxExtent } }
        history: [],
        aiLog: [],
        currTab: "html",
        targetAI: document.getElementById("target-canvas-ai"),
        renderAI: document.getElementById("render-canvas-ai"),
        overlapCanvas: document.getElementById("overlap-canvas"),
        viewCanvas: document.getElementById("view-canvas"),
        viewCtx: null,
        MAX_VERTICAL_EM: 10.0,

        // --- NEW STATE TRACKERS ---
        currentMode: "POSITION", // Starts with POSITION
        iterationCounter: 0, // Counts total iterations executed
        // --------------------------
      };

      const els = {
        wrapper: document.getElementById("wrapper"),
        layer: document.getElementById("overlay-html-layer"),
        output: document.getElementById("debug-textarea"),
        logView: document.getElementById("debug-log-view"),
        status: document.getElementById("ai-status"),
        runBtn: document.getElementById("run-btn"),
        loopInput: document.getElementById("loop-count"),
        modeDisplay: document.getElementById("current-mode-display"),
      };

      // --- UI Logic ---
      window.setTab = (t) => {
        state.currTab = t;

        const isHtmlTab = t === "html";
        els.output.classList.toggle("hidden", !isHtmlTab);
        els.logView.classList.toggle("hidden", isHtmlTab);

        document.querySelectorAll(".tab").forEach((el) => {
          el.classList.remove("active");
          if (el.id.includes(t)) {
            el.classList.add("active");
          }
        });

        if (t === "html") {
          els.output.value = els.layer.innerHTML
            .replace(/<\/div>/g, "</div>\n")
            .replace(/<br>/g, "<br>\n");
        } else if (t === "log") {
          renderDiagnosticLog();
        }
      };

      function renderDiagnosticLog() {
        let logContent = state.aiLog
          .map((entry, i) => {
            const status = entry.success ? "SUCCESS" : "ERROR";
            const rawResponse = entry.response
              ? JSON.stringify(entry.response, null, 2)
              : entry.response;

            const images = entry.request?.images;
            const score = entry.request?.score || "N/A";
            const mode = entry.request?.mode || "N/A";
            const modeClass = mode.toLowerCase();

            const targetImgHtml = images?.target
              ? `<img src="data:image/png;base64,${images.target}" class="image-thumbnail-payload border-red-400" alt="Target Image Thumbnail" />`
              : `<div style="width: 100px; height: 60px; background: #374151; display: flex; align-items: center; justify-content: center; color: #fff; font-size: 0.7rem;">[No Target]</div>`;

            const renderImgHtml = images?.render
              ? `<img src="data:image/png;base64,${images.render}" class="image-thumbnail-payload border-blue-400" alt="Render Image Thumbnail" />`
              : `<div style="width: 100px; height: 60px; background: #374151; display: flex; align-items: center; justify-content: center; color: #fff; font-size: 0.7rem;">[No Render]</div>`;

            // Only display the prompt/structure for the latest log entry (i=0)
            const structureSummary =
              i === 0
                ? `<p class="text-xs text-yellow-400 mt-2 mb-1">Structural Data (Pre-Execution):</p>
                  <pre class="log-pre" style="color: #60a5fa; max-height: 100px;">${JSON.stringify(entry.request?.structure, null, 2)}</pre>`
                : "";

            const promptText =
              i === 0
                ? `<p class="text-xs text-yellow-400 mt-2 mb-1">Prompt Text (Role & Structure):</p>
                  <pre class="log-pre" style="color: #9be658; max-height: 150px;">${entry.request?.promptText}</pre>`
                : "";

            return `<div class="log-history-entry">
                        <h4 style="font-weight: bold; color: ${entry.success ? "#9be658" : "#ef4444"};">
                          --- Iteration ${entry.iter} (${entry.timestamp}) - ${status} 
                          <span class="font-mono ${modeClass}">(${mode} MODE)</span> ---
                        </h4>
                        <div style="margin-top: 0.5rem; display: flex; gap: 1rem; align-items: flex-start;">
                            <div style="text-align: center; font-family: monospace;">Target:<br>${targetImgHtml}</div>
                            <div style="text-align: center; font-family: monospace;">Render:<br>${renderImgHtml}</div>
                            <div class="flex-1">
                                <p style="color: #60a5fa; margin-top: 0.5rem; font-family: monospace; font-size: 0.8rem;">Pre-Execution Delta Score: ${score}</p>
                                <p class="text-xs text-yellow-400 mt-1 mb-1">Raw Commands Executed:</p>
                                <pre class="log-pre" style="color: #fca311; max-height: 80px;">${rawResponse}</pre>
                            </div>
                        </div>
                        ${promptText}
                        ${structureSummary}
                    </div>`;
          })
          .join("");
        els.logView.innerHTML =
          logContent ||
          "<div style='font-family: monospace; color: #666;'>// No AI responses yet. Click 'Run' to start.</div>";
      }

      els.output.addEventListener("input", () => {
        if (state.currTab === "html") {
          els.layer.innerHTML = els.output.value;
        }
      });

      // --- Core Logic ---

      function getStructure(divId) {
        const div = document.getElementById(divId);
        if (!div) return { elements: [], maxExtent: "0.00" };

        Array.from(div.children).forEach((el, i) => {
          if (!el.id) el.id = `blk-${Date.now()}-${i}`;
        });

        let maxExtent = 0;

        const elements = Array.from(div.children)
          .filter((el) => el.innerText.trim().length > 0)
          .map((el) => {
            const computedStyle = window.getComputedStyle(el);
            // Default to 1.0em if not explicitly set, matching INITIAL_HTML
            const currentTop = parseFloat(el.style.top) || 0;
            const currentSize = parseFloat(el.style.fontSize) || 1.0;

            // This calculation is correct if top/size are in EM units relative to the container
            const elementBottom = currentTop + currentSize;
            if (elementBottom > maxExtent) {
              maxExtent = elementBottom;
            }

            return {
              id: el.id,
              tag: el.tagName.toLowerCase(),
              text: el.innerText.substring(0, 30),
              currentStyles: {
                top: el.style.top || "0em",
                left: el.style.left || "0em",
                fontSize: el.style.fontSize || "1.0em", // Ensures a value is always reported
                fontFamily: el.style.fontFamily || computedStyle.fontFamily,
                fontWeight: el.style.fontWeight || computedStyle.fontWeight,
              },
            };
          });

        return { elements, maxExtent: maxExtent.toFixed(2) };
      }

      /**
       * Applies commands, strictly filtering them based on the current execution mode.
       * @param {object} updates - The parsed JSON commands from the AI.
       * @param {string} mode - The current execution mode ("POSITION" or "SIZE").
       */
      function applyCommands(updates, mode) {
        const allowedActions =
          mode === "POSITION"
            ? ["moveUp", "moveDown", "moveLeft", "moveRight"]
            : ["grow", "shrink"];

        let applied = {};

        for (const [id, cmds] of Object.entries(updates)) {
          const el = document.getElementById(id);
          if (!el || !Array.isArray(cmds)) continue;

          el.style.position = "relative";
          let top = parseFloat(el.style.top) || 0;
          let left = parseFloat(el.style.left) || 0;
          let size = parseFloat(el.style.fontSize) || 1.0;

          let elementApplied = [];

          cmds.forEach((c) => {
            if (!allowedActions.includes(c.action)) return;

            const v = parseFloat(c.coefficient) || 0;
            if (c.action === "moveUp") top -= v;
            else if (c.action === "moveDown") top += v;
            else if (c.action === "moveLeft") left -= v;
            else if (c.action === "moveRight") left += v;
            else if (c.action === "grow") size += v;
            else if (c.action === "shrink") size = Math.max(0.1, size - v);

            elementApplied.push(c); // Record only the applied commands
          });

          if (elementApplied.length > 0) {
            el.style.top = top.toFixed(2) + "em";
            el.style.left = left.toFixed(2) + "em";
            el.style.fontSize = size.toFixed(2) + "em";
            applied[id] = elementApplied;
          }
        }
        return applied;
      }

      function createOverlapCanvas(targetCan, htmlCan) {
        const w = targetCan.width;
        const h = targetCan.height;
        const overlapCan = state.overlapCanvas;
        overlapCan.width = w;
        overlapCan.height = h;
        const overlapCtx = overlapCan.getContext("2d");

        overlapCtx.clearRect(0, 0, w, h);

        const targetData = targetCan.getContext("2d").getImageData(0, 0, w, h);
        const htmlData = htmlCan.getContext("2d").getImageData(0, 0, w, h);
        const overlapData = overlapCtx.createImageData(w, h);

        const COLOR_THRESHOLD = 120;
        const ALPHA_THRESHOLD = 100;
        const BLUE = [0, 0, 255, 255]; // Pure blue for overlap

        for (let i = 0; i < targetData.data.length; i += 4) {
          const avgTargetColor =
            (targetData.data[i] +
              targetData.data[i + 1] +
              targetData.data[i + 2]) /
            3;
          // Check if Target has dark text
          const isTargetText = avgTargetColor < COLOR_THRESHOLD;

          // Check if HTML Render has dark text and is visible (alpha > threshold)
          const avgHtmlColor =
            (htmlData.data[i] + htmlData.data[i + 1] + htmlData.data[i + 2]) /
            3;
          const isHtmlText =
            htmlData.data[i + 3] > ALPHA_THRESHOLD &&
            avgHtmlColor < COLOR_THRESHOLD;

          if (isTargetText && isHtmlText) {
            // Both have text: Draw Blue for overlap
            overlapData.data[i] = BLUE[0];
            overlapData.data[i + 1] = BLUE[1];
            overlapData.data[i + 2] = BLUE[2];
            overlapData.data[i + 3] = BLUE[3];
          }
        }

        overlapCtx.putImageData(overlapData, 0, 0);
        return overlapCan;
      }

      function createCombinedRender(targetCan, htmlCan) {
        const rendCan = state.renderAI;
        rendCan.width = targetCan.width;
        rendCan.height = targetCan.height;
        const rendCtx = rendCan.getContext("2d");

        rendCtx.drawImage(targetCan, 0, 0);
        rendCtx.drawImage(htmlCan, 0, 0);
        const overlapCan = createOverlapCanvas(targetCan, htmlCan);
        rendCtx.drawImage(overlapCan, 0, 0);

        return rendCan;
      }

      async function fetchWithBackoff(parts) {
        for (let attempt = 0; attempt < 5; attempt++) {
          try {
            const resp = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ contents: [{ role: "user", parts }] }),
              },
            );

            if (!resp.ok && resp.status === 429) {
              const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
              await new Promise((res) => setTimeout(res, delay));
              continue;
            }
            if (!resp.ok)
              throw new Error(
                `API error: ${resp.status} - ${await resp.text()}`,
              );

            const json = await resp.json();
            return json.candidates?.[0]?.content?.parts?.[0]?.text;
          } catch (e) {
            if (attempt === 4) throw e;
            await new Promise((res) =>
              setTimeout(res, Math.pow(2, attempt) * 1000),
            );
          }
        }
        throw new Error("API call failed after multiple retries.");
      }

      function cropAndScale(rect, scale, source) {
        const c = document.createElement("canvas");
        c.width = rect.w * scale;
        c.height = rect.h * scale;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, c.width, c.height);
        ctx.drawImage(
          source,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
          0,
          0,
          c.width,
          c.height,
        );
        return c;
      }

      function addBorder(canvas, color) {
        const c = document.createElement("canvas");
        c.width = canvas.width;
        c.height = canvas.height;
        const ctx = c.getContext("2d");
        ctx.drawImage(canvas, 0, 0);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, c.width, c.height);
        return c;
      }

      function getRect(divId) {
        const div = document.getElementById(divId);
        if (!div) return null;
        const cw = state.viewCanvas.width,
          ch = state.viewCanvas.height;
        return {
          x: (parseFloat(div.style.left) / 100) * cw,
          y: (parseFloat(div.style.top) / 100) * ch,
          w: (parseFloat(div.style.width) / 100) * cw,
          h: (parseFloat(div.style.height) / 100) * ch,
        };
      }

      function drawCombinedRenderToView() {
        const rect = getRect(TEST_ID);
        if (!rect || !state.viewCtx || !img) return;
        const rendCan = state.renderAI;
        state.viewCtx.drawImage(
          img,
          0,
          0,
          state.viewCanvas.width,
          state.viewCanvas.height,
        );
        state.viewCtx.drawImage(
          rendCan,
          0,
          0,
          rendCan.width,
          rendCan.height,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
        );
      }

      async function getDiff(b64A, b64B) {
        return new Promise((r) => {
          const i1 = new Image(),
            i2 = new Image();
          let c = 0;
          const onload = () => {
            if (++c === 2) diff();
          };
          i1.onload = onload;
          i2.onload = onload;
          i1.src = "data:image/png;base64," + b64A;
          i2.src = "data:image/png;base64," + b64B;
          function diff() {
            const cv = document.createElement("canvas");
            cv.width = i1.width;
            cv.height = i1.height;
            const cx = cv.getContext("2d");
            cx.drawImage(i1, 0, 0);
            const d1 = cx.getImageData(0, 0, cv.width, cv.height).data;
            cx.clearRect(0, 0, cv.width, cv.height);
            cx.drawImage(i2, 0, 0);
            const d2 = cx.getImageData(0, 0, cv.width, cv.height).data;
            let sum = 0;
            for (let k = 0; k < d1.length; k += 4)
              sum +=
                Math.abs(d1[k] - d2[k]) +
                Math.abs(d1[k + 1] - d2[k + 1]) +
                Math.abs(d1[k + 2] - d2[k + 2]);
            r(sum / (i1.width * i1.height * 765));
          }
        });
      }

      function preparePayloadAndPrompt(
        targetCanvas,
        renderCanvas,
        iterLabel,
        currentMode,
        currentTemplate,
      ) {
        const divEl = document.getElementById(TEST_ID);
        if (!divEl) {
          return { parts: [{ text: "// Error: Content not found" }] };
        }

        // 1. Get Current Structure and Max Extent (Pre-Delta)
        const { elements: currentElements, maxExtent } = getStructure(TEST_ID);
        // --- DELTA CALCULATION & COMMAND INJECTION ---
        const previousHistoryForDelta = state.history[1];
        const commandsFromPreviousRun = state.history[0]
          ? state.history[0].commands
          : {};
        let augmentedElements = currentElements;

        if (
          previousHistoryForDelta &&
          previousHistoryForDelta.structure &&
          previousHistoryForDelta.structure.elements
        ) {
          const previousElements = previousHistoryForDelta.structure.elements;

          augmentedElements = currentElements.map((currentEl) => {
            const prevEl = previousElements.find(
              (el) => el.id === currentEl.id,
            );

            const deltaStyles = {};

            if (prevEl) {
              const currentTop = parseFloat(currentEl.currentStyles.top);
              const prevTop = parseFloat(prevEl.currentStyles.top);
              deltaStyles.top = (currentTop - prevTop).toFixed(2) + "em";

              const currentLeft = parseFloat(currentEl.currentStyles.left);
              const prevLeft = parseFloat(prevEl.currentStyles.left);
              deltaStyles.left = (currentLeft - prevLeft).toFixed(2) + "em";

              const currentSize = parseFloat(currentEl.currentStyles.fontSize);
              const prevSize = parseFloat(prevEl.currentStyles.fontSize);
              deltaStyles.fontSize = (currentSize - prevSize).toFixed(2) + "em";
            }

            const commandsAppliedToThisElement =
              commandsFromPreviousRun[currentEl.id] || [];

            return {
              ...currentEl,
              deltaStyles: prevEl
                ? deltaStyles
                : { top: "0.00em", left: "0.00em", fontSize: "0.00em" },
              commandsAppliedInLastStep: commandsAppliedToThisElement,
            };
          });
        }
        // 2. Build Constraint Warning and Dynamic Command Lists
        const maxLimit = state.MAX_VERTICAL_EM.toFixed(2);
        const overLimit = parseFloat(maxExtent) >= parseFloat(maxLimit);
        const remaining = (
          parseFloat(maxLimit) - parseFloat(maxExtent)
        ).toFixed(2);

        // --- Dynamic Command List Generation ---
        let positionCommandsString;
        let sizeCommandsString;
        const ALL_POSITION_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO POSITION)
1. Move: "moveUp", "moveDown", "moveLeft", "moveRight" (Coefficient: 0.10 to 5.00).
`;
        const RESTRICTED_POSITION_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO POSITION)
1. Move: "moveUp", "moveLeft", "moveRight" (Coefficient: 0.10 to 5.00).
   // Note: "moveDown" is disabled due to vertical constraint (${maxExtent}em >= ${maxLimit}em).
`;

        const ALL_SIZE_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO SIZE)
1. Size: "grow", "shrink" (Coefficient: 0.10 to 5.00).
   - NOTE: 'grow' and 'shrink' adjust the 'fontSize' attribute.
`;
        const RESTRICTED_SIZE_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO SIZE)
1. Size: "shrink" (Coefficient: 0.10 to 5.00).
   // Note: "grow" is disabled due to vertical constraint (${maxExtent}em >= ${maxLimit}em).
   - NOTE: 'shrink' adjusts the 'fontSize' attribute.
`;

        if (overLimit) {
          positionCommandsString = RESTRICTED_POSITION_COMMANDS;
          sizeCommandsString = RESTRICTED_SIZE_COMMANDS;
        } else {
          positionCommandsString = ALL_POSITION_COMMANDS;
          sizeCommandsString = ALL_SIZE_COMMANDS;
        }
        // --- End Dynamic Command List Generation ---

        // Simplify constraint text
        let constraintText = `\n\n*** VERTICAL CONSTRAINT STATUS ***\n`;
        constraintText += `MAX: ${maxLimit}em. CURRENT: ${maxExtent}em. REMAINING: ${remaining}em.\n`;
        if (overLimit) {
          constraintText += `STATUS: LIMIT REACHED. Toolset restricted to UP/LEFT/RIGHT/SHRINK.\n`;
        }
        constraintText += `**********************************\n\n`;

        // Replace the placeholders in the chosen template
        let finalPromptText = currentTemplate.replace(
          "{{structure}}",
          JSON.stringify(augmentedElements, null, 2),
        );
        finalPromptText = finalPromptText.replace(
          "{{constraint}}",
          constraintText,
        );

        // Apply dynamic command lists
        finalPromptText = finalPromptText.replace(
          "{{positionCommands}}",
          positionCommandsString,
        );
        finalPromptText = finalPromptText.replace(
          "{{sizeCommands}}",
          sizeCommandsString,
        );

        // --- Prepare Payload Parts (Interleaved) ---
        const parts = [];

        // 3. History (if any)
        const chronologicalHistory = state.history.slice(0, 3).reverse();
        if (chronologicalHistory.length > 0) {
          parts.push({
            text: "### HISTORY OF RECENT ACTIONS (Oldest to Newest):\n",
          });
          chronologicalHistory.forEach((h, i) => {
            const currentRun = parseInt(iterLabel.match(/\d+/)?.[0] || "1", 10);
            const stepNum = currentRun - (state.history.length - i);

            const stepText = `\n--- Step ${Math.max(0, stepNum)} ---\nDelta Score (Pre-Command): ${h.score}\nCommands Executed: ${JSON.stringify(h.commands)}\nRESULTING FRAME (below):`;

            parts.push({ text: stepText });
            parts.push({
              inlineData: { mimeType: "image/png", data: h.resultImage },
            });
          });
          parts.push({ text: "\n----------------\n" });
        } else {
          parts.push({
            text: "(No history available yet. This is the first step.)\n",
          });
        }

        // 4. Current Context
        const borderedTarget = addBorder(targetCanvas, "#f00");
        const borderedRender = addBorder(renderCanvas, "#3b82f6");
        const targetBase64 = borderedTarget.toDataURL().split(",")[1];
        const renderBase64 = borderedRender.toDataURL().split(",")[1];

        // The prompt text goes first
        parts.push({
          text:
            finalPromptText +
            "\n\n--- VISUAL INPUTS ---\n1. TARGET (Red Border):\n",
        });
        parts.push({
          inlineData: { mimeType: "image/png", data: targetBase64 },
        });

        parts.push({ text: "\n2. CURRENT RENDER (Blue Border):\n" });
        parts.push({
          inlineData: { mimeType: "image/png", data: renderBase64 },
        });

        // --- Full Payload Object for Logging ---
        const payloadObj = {
          iter: iterLabel || "Initial",
          mode: currentMode,
          score: "Calculated Pre-Execution",
          constraint: { maxLimit, currentExtent: maxExtent },
          promptText: finalPromptText,
          structure: augmentedElements,
          images: {
            target: targetBase64,
            render: renderBase64,
          },
          history: chronologicalHistory.map((h, i) => {
            const currentRun = parseInt(iterLabel.match(/\d+/)?.[0] || "1", 10);
            const step = currentRun - (state.history.length - i);
            return {
              step: Math.max(0, step),
              score: h.score,
              commands: h.commands,
            };
          }),
        };

        return { parts, payloadObj };
      }

      async function updateAIImagesAndPayload(
        originalImage,
        isInitialRun,
        iterLabel,
        scale,
      ) {
        const divEl = document.getElementById(TEST_ID);
        if (!divEl) return;
        const rect = getRect(TEST_ID);

        if (isInitialRun) {
          const srcCan = cropAndScale(rect, DEFAULT_AI_SCALE, originalImage);
          state.targetAI.width = srcCan.width;
          state.targetAI.height = srcCan.height;
          state.targetAI.getContext("2d").drawImage(srcCan, 0, 0);
        }

        const htmlLayerCan = await html2canvas(divEl, {
          scale: scale,
          backgroundColor: null,
          width: rect.w,
          height: rect.h,
        });

        let scaledTargetCan = state.targetAI;
        if (scale !== DEFAULT_AI_SCALE) {
          scaledTargetCan = cropAndScale(rect, scale, originalImage);
        }

        const renderCan = createCombinedRender(scaledTargetCan, htmlLayerCan);

        // This call is just to prepare the payload object in memory, we don't use its 'parts'
        const { payloadObj } = preparePayloadAndPrompt(
          scaledTargetCan,
          renderCan,
          iterLabel,
          state.currentMode,
          state.currentMode === "POSITION" ? POSITION_TEMPLATE : SIZE_TEMPLATE,
        );

        if (isInitialRun) {
          const resultB64 = renderCan.toDataURL().split(",")[1];
          const { elements: initialElements, maxExtent: initialExtent } =
            getStructure(TEST_ID);

          if (
            state.history.length === 0 ||
            state.history[state.history.length - 1].commands !== null
          ) {
            state.history.unshift({
              score: "0.00%",
              commands: {},
              resultImage: resultB64,
              structure: {
                elements: initialElements,
                maxExtent: initialExtent,
              },
            });
          }
        }
      }

      async function runIteration(i, max) {
        state.iterationCounter++;
        state.currentMode =
          state.iterationCounter % 2 === 1 ? "POSITION" : "SIZE";
        const currentTemplate =
          state.currentMode === "POSITION" ? POSITION_TEMPLATE : SIZE_TEMPLATE;

        els.modeDisplay.textContent = state.currentMode;
        els.modeDisplay.className = `mode-${state.currentMode.toLowerCase()}`;

        const divEl = document.getElementById(TEST_ID);
        if (!divEl) return;

        const iter = `Run ${i}/${max}`;

        currentRunScale = i === max ? FINAL_AI_SCALE : DEFAULT_AI_SCALE;

        els.status.textContent = `${iter} Capturing for ${state.currentMode}... (Scale: ${currentRunScale})`;
        els.status.style.display = "inline";

        await updateAIImagesAndPayload(img, false, iter, currentRunScale);
        const srcCan = state.targetAI;
        const rendCan = state.renderAI;

        const srcB64 = srcCan.toDataURL().split(",")[1];
        const rendB64 = rendCan.toDataURL().split(",")[1];
        const deltaScore = await getDiff(srcB64, rendB64);
        const scoreString = (deltaScore * 100).toFixed(2) + "%";

        const { parts, payloadObj } = preparePayloadAndPrompt(
          srcCan,
          rendCan,
          iter,
          state.currentMode,
          currentTemplate,
        );
        payloadObj.score = scoreString;

        if (state.currTab === "log") renderDiagnosticLog();

        els.status.textContent = `${iter} Thinking in ${state.currentMode} Mode... (Score: ${scoreString})`;
        let logEntry = {
          iter,
          success: false,
          request: payloadObj,
          response: "Error/No response",
          timestamp: new Date().toLocaleTimeString(),
        };

        try {
          const resultJsonStr = await fetchWithBackoff(parts);
          if (!resultJsonStr) throw new Error("Empty response from AI.");

          const jsonMatch = resultJsonStr.match(/\{[\s\S]*\}/);
          const updates = JSON.parse(jsonMatch ? jsonMatch[0] : "{}");

          logEntry.response = updates;
          logEntry.success = true;

          // --- CRITICAL FILTERING STEP ---
          const appliedCommands = applyCommands(updates, state.currentMode);

          await updateAIImagesAndPayload(
            img,
            false,
            `${iter} (Post-Apply)`,
            DEFAULT_AI_SCALE,
          );
          const resultB64 = state.renderAI.toDataURL().split(",")[1];

          const {
            elements: postCommandElements,
            maxExtent: postCommandExtent,
          } = getStructure(TEST_ID);

          state.history.unshift({
            score: scoreString,
            commands: appliedCommands,
            resultImage: resultB64,
            structure: {
              elements: postCommandElements,
              maxExtent: postCommandExtent,
            },
          });

          console.log(
            `Applied ${Object.keys(appliedCommands).length} updates in ${state.currentMode} mode. Score: ${scoreString}`,
          );

          await updateAIImagesAndPayload(
            img,
            false,
            `Pre-Run ${i + 1}/${max}`,
            currentRunScale,
          );
          drawCombinedRenderToView();

          els.output.value = els.layer.innerHTML
            .replace(/<\/div>/g, "</div>\n")
            .replace(/<br>/g, "<br>\n");
          if (state.currTab === "html") window.setTab("html");
        } catch (e) {
          logEntry.response = `Error: ${e.message}`;
          console.error(e);
        } finally {
          state.aiLog.unshift(logEntry);
          if (state.currTab === "log") renderDiagnosticLog();

          await updateAIImagesAndPayload(
            img,
            false,
            `Pre-Run ${i + 1}/${max}`,
            currentRunScale,
          );
          drawCombinedRenderToView();
        }
      }

      els.runBtn.onclick = async () => {
        els.runBtn.disabled = true;
        state.history = [];
        state.aiLog = [];
        state.iterationCounter = 0; // Reset counter

        els.layer.innerHTML = INITIAL_HTML;
        els.output.value = INITIAL_HTML.replace(/<\/div>/g, "</div>\n").replace(
          /<br>/g,
          "</p>\n<p>",
        );
        await updateAIImagesAndPayload(
          img,
          true,
          "Initial Baseline Reset",
          DEFAULT_AI_SCALE,
        );

        const max = parseInt(els.loopInput.value);
        for (let i = 1; i <= max; i++) await runIteration(i, max);
        els.layer.innerHTML = els.output.value;
        drawCombinedRenderToView();
        els.status.style.display = "none";
        els.runBtn.disabled = false;
        window.setTab("html");
        els.modeDisplay.textContent = "DONE";
        els.modeDisplay.className = "text-green-400";
      };

      // Initialization
      els.output.value = INITIAL_HTML.replace(/<\/div>/g, "</div>\n").replace(
        /<br>/g,
        "</p>\n<p>",
      );
      els.layer.innerHTML = INITIAL_HTML;
      window.setTab("html");
      els.modeDisplay.textContent = "READY";

      img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = async () => {
        state.viewCanvas.width = img.width;
        state.viewCanvas.height = img.height;
        els.wrapper.style.width = state.viewCanvas.width + "px";
        els.wrapper.style.height = state.viewCanvas.height + "px";
        state.viewCtx = state.viewCanvas.getContext("2d");
        state.viewCtx.drawImage(
          img,
          0,
          0,
          state.viewCanvas.width,
          state.viewCanvas.height,
        );
        await updateAIImagesAndPayload(img, true, "Initial", DEFAULT_AI_SCALE);

        drawCombinedRenderToView();
      };
      img.src = SAMPLE_URL;
    </script>
  </body>
</html>
