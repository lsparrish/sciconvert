<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Style Replica Test</title>
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css"
    />

    <style>
      body {
        background-color: #1f2937;
        overflow: hidden;
        font-family: sans-serif;
        height: 100vh;
      }
      .editor {
        font-family: monospace;
      }
      #overlay-html-layer * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        line-height: 1;
      }
      .tab {
        @apply px-3 py-1 text-xs cursor-pointer text-gray-400 hover:text-white border-b-2 border-transparent;
      }
      .tab.active {
        @apply text-green-400 border-green-400 bg-gray-900;
      }
    </style>
  </head>
  <body class="flex flex-col h-screen text-white">
    <!-- Header -->
    <header
      class="bg-gray-900 p-2 flex justify-between items-center shadow border-b border-gray-800"
    >
      <h1 class="font-bold text-purple-400 tracking-wider">
        Replica Debug: Command Strategy
      </h1>
      <button
        id="fullscreen-btn"
        class="bg-gray-700 hover:bg-gray-600 p-2 rounded-lg transition text-gray-300"
        onclick="document.documentElement.requestFullscreen()"
      >
        Full Screen
      </button>
      <div class="flex items-center gap-2">
        <span id="ai-status" class="text-blue-400 text-xs font-mono hidden"
          >Processing...</span
        >
        <input
          type="number"
          id="loop-count"
          value="1"
          min="1"
          max="10"
          class="w-12 bg-gray-800 text-center text-sm border border-gray-700 rounded"
        />
        <button
          id="run-btn"
          class="bg-purple-600 hover:bg-purple-500 px-3 py-1 text-sm rounded"
        >
          Run
        </button>
      </div>
    </header>

    <!-- Main -->
    <main class="flex-1 flex overflow-hidden">
      <!-- Left: Visual (bg-gray-800) -->
      <div class="w-1/2 flex flex-col bg-gray-800 relative overflow-hidden">
        <!-- REMOVED p-8 class to eliminate the thick grey border/frame. -->
        <div class="overflow-hidden">
          <div id="wrapper" class="bg-white text-black overflow-hidden">
            <canvas id="the-canvas" class="absolute inset-0"></canvas>
            <div id="overlay-html-layer"></div>
          </div>
        </div>
      </div>

      <!-- Right: Debug -->
      <div class="w-1/2 flex flex-col bg-gray-800">
        <div class="flex border-b border-gray-800 bg-gray-800">
          <button id="tab-html" class="tab active" onclick="setTab('html')">
            HTML
          </button>
          <button id="tab-prompt" class="tab" onclick="setTab('prompt')">
            Prompt Text
          </button>
          <button id="tab-payload" class="tab" onclick="setTab('payload')">
            Full Payload
          </button>
          <button id="tab-response" class="tab" onclick="setTab('response')">
            Response Log
          </button>
        </div>

        <!-- Dual Output Container -->
        <div class="flex-1 w-full relative">
          <textarea
            id="debug-textarea"
            class="editor absolute inset-0 p-4 bg-gray-900 text-green-400 text-xs outline-none border-none resize-none"
          ></textarea>

          <div
            id="debug-log-view"
            class="absolute inset-0 p-4 bg-gray-900 text-white text-xs overflow-auto hidden"
          ></div>
        </div>
      </div>
    </main>

    <script type="module">
      const apiKey = "";
      const SAMPLE_URL = "https://lsparrish.github.io/sciconvert/sample.png";
      const TEST_ID = "div-test-block";
      const AI_SCALE = 2.0;

      // Initial Content
      const INITIAL_HTML = `<div id="${TEST_ID}" style="position: relative; left: 4.92%; top: 2.34%; width: 88.80%; height: 26.53%; background: rgba(255,255,255,0.7); padding: 0px; margin: 0px; "> 
<p>Journal of the British Interplanetary Society, Vol. 36, pp. 115-128, 1983.</p>

<p>ORBITAL RING SYSTEMS AND JACOB'S LADDERS - II</p>

<p>PAUL BIRCH*</p>
<p>45, Brownville Road, Heaton Moor, Stockport, England.</p>

<p>A method of transferring payloads into space without using rockets has been presented in Part I, in which massive
rings encircle the globe in a low orbit supporting stationary 'sky-hooks,' from which cables hang down to any point on
the Earth's surface. Vehicles can climb up these 'ladders' into orbit, or can accelerate along the rings. The structure and
deployment of such Orbital Ring Systems is examined and their varied uses considered; several scenarios are considered
and shown to be economically feasible and beneficial.</p></div>`;

      // State
      const state = {
        history: [],
        aiLog: [], // NEW: Stores detailed logs for response tab
        debug: {
          html: "",
          prompt: "// No prompt yet",
          payload: "// No request payload yet",
        },
        currTab: "html",
        canvas: document.getElementById("the-canvas"),
        ctx: document.getElementById("the-canvas").getContext("2d"),

        promptTemplate: `Analyze visual differences. Target has RED BORDER. Render has RED BORDER.
Goal: Issue commands to align Render to Target.

COMMANDS (Array of objects):
- Actions: "moveUp", "moveDown", "moveLeft", "moveRight", "grow", "shrink", "setFont"
- Coefficient: 0.10 (tiny) to 5.00 (huge). 1.00 ~= 1em.

INPUT:
History Scores: {{history}}
Structure (IDs, Text, Current Styles): 
{{structure}}

INSTRUCTIONS:
Return JSON object { "element-id": [ { "action": "moveUp", "coefficient": 0.50 } ] }
Always use 2 decimal points (hundredths) for precision.
Only include elements needing change. Use the "currentStyles" in the structure to inform your decision.`,
      };

      const els = {
        wrapper: document.getElementById("wrapper"),
        layer: document.getElementById("overlay-html-layer"),
        output: document.getElementById("debug-textarea"), // Textarea for editable content
        logView: document.getElementById("debug-log-view"), // Div for response log
        status: document.getElementById("ai-status"),
        runBtn: document.getElementById("run-btn"),
        loopInput: document.getElementById("loop-count"),
      };

      // --- UI Logic ---
      window.setTab = (t) => {
        state.currTab = t;

        // Hide/Show correct output element
        const isTextTab = t === "html" || t === "prompt" || t === "payload";
        els.output.classList.toggle("hidden", !isTextTab);
        els.logView.classList.toggle("hidden", isTextTab);

        // Update active tab buttons
        document.querySelectorAll(".tab").forEach((el) => {
          el.classList.remove("active");
          if (el.id.includes(t)) {
            el.classList.add("active");
          }
        });

        // Update content
        if (t === "html") {
          els.output.value = els.layer.innerHTML
            .replace(/<\/div>/g, "</div>\n")
            .replace(/<br>/g, "<br>\n");
        } else if (t === "response") {
          // Render the AI Log (HTML content)
          let logContent = state.aiLog
            .map((entry, i) => {
              const status = entry.success ? "SUCCESS" : "ERROR";
              const rawResponse = entry.response
                ? JSON.stringify(entry.response, null, 2)
                : entry.response;
              return `<div style="border-bottom: 1px solid #374151; padding-bottom: 1rem; margin-bottom: 1rem;">
                        <h4 style="font-weight: bold; color: ${entry.success ? "#9be658" : "#ef4444"};">--- Iteration ${entry.iter} (${entry.timestamp}) - ${status} ---</h4>
                        <div style="margin-top: 0.5rem; display: flex; gap: 1rem; align-items: flex-start; justify-content: space-around;">
                            <div style="text-align: center; font-family: monospace;">
                                Target:<br>
                                <img src="data:image/png;base64,${entry.request.images.target}" style="width: 150px; height: auto; border: 2px solid #f97316; margin: 4px;" alt="Target Image Thumbnail" />
                            </div>
                            <div style="text-align: center; font-family: monospace;">
                                Render:<br>
                                <img src="data:image/png;base64,${entry.request.images.render}" style="width: 150px; height: auto; border: 2px solid #3b82f6; margin: 4px;" alt="Render Image Thumbnail" />
                            </div>
                        </div>
                        <pre style="white-space: pre-wrap; margin-top: 0.5rem; background: #111827; padding: 0.5rem; border-radius: 4px; color: #d1d5db; font-size: 0.75rem;">Request Structure: ${JSON.stringify(entry.request.structure, null, 2).substring(0, 300) + "..."}</pre>
                        <pre style="white-space: pre-wrap; background: #111827; padding: 0.5rem; border-radius: 4px; color: #9be658; font-size: 0.75rem;">Raw Response: ${rawResponse}</pre>
                    </div>`;
            })
            .join("");
          els.logView.innerHTML =
            logContent ||
            "<div style='font-family: monospace;'>// No AI responses yet.</div>";
        } else {
          // prompt or payload
          els.output.value = state.debug[t];
        }
      };

      els.output.addEventListener("input", () => {
        if (state.currTab === "html") {
          els.layer.innerHTML = els.output.value;
          renderMathInElement(els.layer, {
            delimiters: [{ left: "$$", right: "$$", display: true }],
          });
        }
      });

      // --- Core Logic ---

      function getStructure(divId) {
        const div = document.getElementById(divId);
        if (!div) return [];
        // Ensure IDs
        Array.from(div.children).forEach((el, i) => {
          if (!el.id) el.id = `blk-${Date.now()}-${i}`;
        });

        return Array.from(div.children)
          .filter((el) => el.innerText.trim().length > 0)
          .map((el) => ({
            id: el.id,
            tag: el.tagName.toLowerCase(),
            text: el.innerText.substring(0, 30),
            currentStyles: {
              top: el.style.top || "0em",
              left: el.style.left || "0em",
              fontSize: el.style.fontSize || "1.0em",
            },
          }));
      }

      function applyCommands(updates) {
        let count = 0;
        for (const [id, cmds] of Object.entries(updates)) {
          const el = document.getElementById(id);
          if (!el || !Array.isArray(cmds)) continue;

          el.style.position = "relative";
          let top = parseFloat(el.style.top) || 0;
          let left = parseFloat(el.style.left) || 0;
          let size = parseFloat(el.style.fontSize) || 1.0;

          cmds.forEach((c) => {
            const v = parseFloat(c.coefficient) || 0;
            if (c.action === "moveUp") top -= v;
            if (c.action === "moveDown") top += v;
            if (c.action === "moveLeft") left -= v;
            if (c.action === "moveRight") left += v;
            if (c.action === "grow") size += v;
            if (c.action === "shrink") size = Math.max(0.1, size - v);
          });

          el.style.top = top.toFixed(2) + "em";
          el.style.left = left.toFixed(2) + "em";
          el.style.fontSize = size.toFixed(2) + "em";
          count++;
        }
        return count;
      }

      async function fetchWithBackoff(parts) {
        for (let attempt = 0; attempt < 5; attempt++) {
          try {
            const resp = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ contents: [{ role: "user", parts }] }),
              },
            );

            if (!resp.ok && resp.status === 429) {
              const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
              await new Promise((res) => setTimeout(res, delay));
              continue;
            }
            if (!resp.ok)
              throw new Error(
                `API error: ${resp.status} - ${await resp.text()}`,
              );

            const json = await resp.json();
            return json.candidates?.[0]?.content?.parts?.[0]?.text;
          } catch (e) {
            if (attempt === 4) throw e;
            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
            await new Promise((res) => setTimeout(res, delay));
          }
        }
        throw new Error("API call failed after multiple retries.");
      }

      // --- Helpers ---

      function extractSnippet(rect, scale = 1) {
        const c = document.createElement("canvas");
        c.width = rect.w * scale;
        c.height = rect.h * scale;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, c.width, c.height);
        ctx.drawImage(
          state.canvas,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
          0,
          0,
          c.width,
          c.height,
        );
        return c;
      }

      function addBorder(canvas) {
        const c = document.createElement("canvas");
        c.width = canvas.width;
        c.height = canvas.height;
        const ctx = c.getContext("2d");
        ctx.drawImage(canvas, 0, 0);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, c.width, c.height);
        return c;
      }

      function getRect(divId) {
        const div = document.getElementById(divId);
        if (!div) return null;
        const cw = state.canvas.width,
          ch = state.canvas.height;
        return {
          x: (parseFloat(div.style.left) / 100) * cw,
          y: (parseFloat(div.style.top) / 100) * ch,
          w: (parseFloat(div.style.width) / 100) * cw,
          h: (parseFloat(div.style.height) / 100) * ch,
        };
      }

      async function getDiff(b64A, b64B) {
        return new Promise((r) => {
          const i1 = new Image(),
            i2 = new Image();
          let c = 0;
          const onload = () => {
            if (++c === 2) diff();
          };
          i1.onload = onload;
          i2.onload = onload;
          i1.src = "data:image/png;base64," + b64A;
          i2.src = "data:image/png;base64," + b64B;
          function diff() {
            const cv = document.createElement("canvas");
            cv.width = i1.width;
            cv.height = i1.height;
            const cx = cv.getContext("2d");
            cx.drawImage(i1, 0, 0);
            const d1 = cx.getImageData(0, 0, cv.width, cv.height).data;
            cx.clearRect(0, 0, cv.width, cv.height);
            cx.drawImage(i2, 0, 0);
            const d2 = cx.getImageData(0, 0, cv.width, cv.height).data;
            let sum = 0;
            for (let k = 0; k < d1.length; k += 4)
              sum +=
                Math.abs(d1[k] - d2[k]) +
                Math.abs(d1[k + 1] - d2[k + 1]) +
                Math.abs(d1[k + 2] - d2[k + 2]);
            r(sum / (i1.width * i1.height * 765));
          }
        });
      }

      // --- Main Loop ---

      async function runIteration(iter) {
        const divEl = document.getElementById(TEST_ID);
        els.status.textContent = `${iter} Capturing...`;
        els.status.style.display = "inline";

        // 1. Capture
        const rect = getRect(TEST_ID);
        const srcCan = extractSnippet(rect, AI_SCALE);
        const rendCan = await html2canvas(divEl, {
          scale: AI_SCALE,
          backgroundColor: "#fff",
        });

        // 2. Diff & History
        const srcB64 = srcCan.toDataURL().split(",")[1];
        const rendB64 = rendCan.toDataURL().split(",")[1];
        const score = await getDiff(srcB64, rendB64);
        state.history.push((score * 100).toFixed(2) + "%");

        // 3. Prompt
        const struct = getStructure(TEST_ID);
        let prompt = state.promptTemplate
          .replace("{{history}}", state.history.join(", "))
          .replace("{{structure}}", JSON.stringify(struct, null, 2));
        state.debug.prompt = prompt;

        // 4. Payload (Bordered images)
        const parts = [{ text: prompt }];
        const borderedCanvases = [addBorder(srcCan), addBorder(rendCan)];
        const imageBase64s = borderedCanvases.map(
          (c) => c.toDataURL().split(",")[1],
        );

        imageBase64s.forEach((b64) => {
          parts.push({ inlineData: { mimeType: "image/png", data: b64 } });
        });

        const payloadObj = {
          iter,
          score: (score * 100).toFixed(2) + "%",
          prompt,
          structure: struct,
          images: {
            target: imageBase64s[0],
            render: imageBase64s[1],
          },
        };
        const displayPayload = {
          ...payloadObj,
          images: {
            target: payloadObj.images.target.substring(0, 30) + "...",
            render: payloadObj.images.render.substring(0, 30) + "...",
          },
        };
        state.debug.payload = JSON.stringify(displayPayload, null, 2);

        if (state.currTab !== "html") window.setTab(state.currTab); // refresh view

        // 5. AI Call
        els.status.textContent = `${iter} Thinking...`;
        let logEntry = {
          iter,
          success: false,
          request: payloadObj,
          response: "Error/No response",
          timestamp: new Date().toLocaleTimeString(),
        };

        try {
          const resultJsonStr = await fetchWithBackoff(parts);

          if (!resultJsonStr) {
            throw new Error("Empty response from AI.");
          }

          // Use regex to robustly extract the JSON object, which is usually enclosed in a code block
          const jsonMatch = resultJsonStr.match(/\{[\s\S]*\}/);
          const updates = JSON.parse(jsonMatch ? jsonMatch[0] : "{}");

          logEntry.response = updates;
          logEntry.success = true;

          const n = applyCommands(updates);
          console.log(
            `Applied ${n} updates. Score: ${(score * 100).toFixed(2)}%`,
          );
        } catch (e) {
          logEntry.response = `Error: ${e.message}`;
          console.error(e);
        } finally {
          state.aiLog.unshift(logEntry);
          if (state.currTab === "response") window.setTab("response");
        }
      }

      els.runBtn.onclick = async () => {
        els.runBtn.disabled = true;
        state.history = [];
        const max = parseInt(els.loopInput.value);
        for (let i = 1; i <= max; i++) await runIteration(`Run ${i}/${max}`);
        els.status.style.display = "none";
        els.runBtn.disabled = false;
        window.setTab("html"); // show result
      };

      els.layer.innerHTML = INITIAL_HTML;
      window.setTab("html");
      renderMathInElement(els.layer, {
        delimiters: [{ left: "$$", right: "$$", display: true }],
      });
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        state.canvas.width = img.width;
        state.canvas.height = img.height;
        state.ctx.drawImage(img, 0, 0, state.canvas.width, state.canvas.height);
        els.wrapper.style.width = state.canvas.width + "px";
        els.wrapper.style.height = state.canvas.height + "px";
      };
      img.onerror = () => {
        console.error("Image failed to load");
      };
      img.src = SAMPLE_URL;
    </script>
  </body>
</html>
