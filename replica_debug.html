<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alternating Alignment Engine (Lean)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      body {
        background-color: #1f2937;
        overflow: hidden;
        font-family: sans-serif;
        height: 100vh;
      }
      .editor {
        font-family: monospace;
      }
      #overlay-html-layer * {
        margin: 0;
        padding: 0;
        left: 0%;
        top: 0%;
        box-sizing: border-box;
        line-height: 1;
      }
      .tab {
        @apply px-3 py-1 text-xs cursor-pointer text-gray-400 hover:text-white border-b-2 border-transparent;
      }
      .tab.active {
        @apply text-green-400 border-green-400 bg-gray-900;
      }
      .image-thumbnail-payload {
        width: 100px;
        height: auto;
        margin-top: 5px;
        border: 1px solid #4b5563;
        border-radius: 4px;
      }
      .log-pre {
        white-space: pre-wrap;
        background: #111827;
        padding: 0.5rem;
        border-radius: 4px;
        color: #d1d5db;
        font-size: 0.7rem;
        overflow-y: auto;
      }
      .log-history-entry {
        border-bottom: 1px solid #374151;
        padding-bottom: 1rem;
        margin-bottom: 1rem;
      }
      /* New styles for disclosure folds */
      .log-details {
        margin-top: 10px;
        border: 1px solid #374151; /* gray-700 */
        border-radius: 6px;
        overflow: hidden;
      }
      .log-summary {
        padding: 6px 10px;
        background-color: #1f2937; /* gray-800 */
        color: #9ca3af; /* gray-400 */
        font-size: 0.75rem;
        cursor: pointer;
        outline: none;
      }
      .log-summary:hover {
        background-color: #111827; /* gray-900 */
      }
      .log-summary::marker, .log-summary::-webkit-details-marker {
          color: #9ca3af;
      }
      .log-details .log-pre {
        background: #111827;
        border-radius: 0;
      }

      .mode-position {
        color: #60a5fa;
      }
      .mode-size {
        color: #fca311;
      }
      /* Ensure canvas elements are layered correctly */
      #view-canvas {
        z-index: 10;
      }
      #overlay-html-layer {
        z-index: 0;
      }
    </style>
  </head>
  <body class="flex flex-col h-screen text-white">
    <header
      class="bg-gray-900 p-2 flex justify-between items-center shadow border-b border-gray-800"
    >
      <h1 class="font-bold text-purple-400 tracking-wider">
        Alternating Alignment Engine (<span id="current-mode-display">---</span
        >)
      </h1>
      <button
        id="fullscreen-btn"
        class="bg-gray-700 hover:bg-gray-600 p-2 rounded-lg transition text-gray-300"
        onclick="document.documentElement.requestFullscreen()"
      >
        Full Screen
      </button>
      <div class="flex items-center gap-2">
        <span id="ai-status" class="text-blue-400 text-xs font-mono hidden"
          >Processing...</span
        >
        <input
          type="number"
          id="loop-count"
          value="4"
          min="2"
          max="10"
          class="w-12 bg-gray-800 text-center text-sm border border-gray-700 rounded"
        />
        <button
          id="run-btn"
          class="bg-purple-600 hover:bg-purple-500 px-3 py-1 text-sm rounded"
        >
          Run
        </button>
      </div>
    </header>

    <main class="flex-1 flex overflow-hidden">
      <div class="w-1/2 flex flex-col bg-gray-800 relative overflow-hidden">
        <div class="overflow-hidden flex-1 relative">
          <div id="wrapper" class="bg-white text-black absolute inset-0">
            <canvas id="view-canvas" class="absolute inset-0"></canvas>
            <div id="overlay-html-layer" class="absolute inset-0"></div>
          </div>
        </div>
      </div>

      <div class="w-1/2 flex flex-col bg-gray-800">
        <div class="flex border-b border-gray-800 bg-gray-800">
          <button id="tab-html" class="tab active" onclick="setTab('html')">
            HTML
          </button>
          <button id="tab-log" class="tab" onclick="setTab('log')">
            Diagnostic Log
          </button>
        </div>

        <div class="flex-1 w-full relative">
          <textarea
            id="debug-textarea"
            class="editor absolute inset-0 p-4 bg-gray-900 text-green-400 text-xs outline-none border-none resize-none"
          ></textarea>

          <div
            id="debug-log-view"
            class="absolute inset-0 p-4 bg-gray-900 text-white text-xs overflow-auto hidden"
          ></div>
        </div>
      </div>
    </main>

    <canvas id="target-canvas-ai" style="display: none"></canvas>
    <canvas id="render-canvas-ai" style="display: none"></canvas>
    <canvas id="overlap-canvas" style="display: none"></canvas>

    <script type="module">
      const apiKey = "";
      const SAMPLE_URL = "https://lsparrish.github.io/sciconvert/sample.png";
      const TEST_ID = "div-test-block";

      const DEFAULT_AI_SCALE = 0.5;
      const FINAL_AI_SCALE = 2.0;

      const PROBABILITY_FIELD = "dampenFutureChanges"; // New field name

      // --- FOCUSED PROMPT TEMPLATES ---

      // Template for POSITION Correction (Odd Runs: 1, 3, 5...)
      const POSITION_TEMPLATE = `# ROLE: FOCUSED POSITION ALIGNMENT
You are a Visual Alignment Engine focused on matching the **X and Y coordinates (position)** of text elements.

# OBJECTIVE
Analyze the visuals (Target/Red Border vs. Current Render/Blue Border). Move the dark Render text to the positions on the Target.

To aid comprehension, render has a faint image of Target, with blue pixels where overlap is detected. 
Maximize blue pixels cooresponding to the black text in the Target by correctly moving the dark text of the Render.
Minimize blue pixels which do not correspond.

{{positionCommands}}

# ANALYSIS STEPS / INTERNAL MONOLOGUE
1. Delta Check: precise difference in X/Y coordinates compared to Target.
2. History Check: Did the previous move overshoot? If yes, reverse movement by a small amount.
3. Closeness: Change amount should be smaller if already close in position, larger if still a long ways.
4. Probability: To dampen future changes, pick a number closer to 0.41-0.59. If the changeAmount you choose is small, bump it up. If large, bump it down.

# OUTPUT RULES
- Return **ONLY** a raw JSON object. No markdown, no commentary.
- Precision: Coefficients must use 2 decimal decimals (e.g., 0.50).
- Efficiency: Only include elements that require position changes.

# INPUT DATA
{{constraint}}
{{structure}}

# RESPONSE FORMAT
{
  "element-id": [
    { "action": "moveUp", "changeAmount": 0.50, "${PROBABILITY_FIELD}": 0.10 } // dampenFutureChanges is (0.00 to 1.00)
  ]
}`;

      // Template for SIZE Correction (Even Runs: 2, 4, 6...)
      const SIZE_TEMPLATE = `# ROLE: FOCUSED SIZE ALIGNMENT
You are a Visual Alignment Engine strictly focused on matching the **size (fontSize)** of text elements.

# OBJECTIVE
Analyze the visuals (Target/Red Border vs. Current Render/Blue Border). Your SOLE goal is to issue JSON commands to match the width and height of the currently rendered text to the target text by adjusting its scale (**fontSize**).

To aid comprehension, render has a faint image of Target, with blue pixels where overlap is detected.
Maximize blue pixels corresponding to the black text in the Target by correctly matching the size of the dark text of the Render.
Minimize blue pixels which do not correspond.

{{sizeCommands}}

# ANALYSIS STEPS / INTERNAL MONOLOGUE
1. Delta Check: precise difference in current font size compared to Target size.
2. History Check: Did the previous size change overshoot? If yes, reverse movement by a small amount.
3. Closeness: Change amount should be smaller if already close in size, larger if still a long ways.
4. Probability: To dampen future changes, pick a number closer to 0.41-0.59. If the changeAmount you choose is small, bump it up. If large, bump it down.

# OUTPUT RULES
- Return **ONLY** a raw JSON object. No markdown, no commentary.
- Precision: Coefficients must use 2 decimal decimals (e.g., 0.50).
- Efficiency: Only include elements that require size changes.

# INPUT DATA
{{constraint}}
{{structure}}

# RESPONSE FORMAT
{
  "element-id": [
    { "action": "grow", "changeAmount": 0.25, "${PROBABILITY_FIELD}": 0.10 }
  ]
}`;

      let currentRunScale = DEFAULT_AI_SCALE;
      let img;

      // Initial Content
      const INITIAL_HTML = `<div id="${TEST_ID}" style="position: absolute; left: 4.92%; top: 2.34%; width: 88.80%; height: 26.53%; background: rgba(255,255,255,0.7); padding: 0px; margin: 0px; "> 
<p>Journal of the British Interplanetary Society, Vol. 36, pp. 115-128, 1983.</p>

<p>ORBITAL RING SYSTEMS AND JACOB'S LADDERS - II</p>

<p>PAUL BIRCH*</p>
<p>45, Brownville Road, Heaton Moor, Stockport, England.</p>

<p>A method of transferring payloads into space without using rockets has been presented in Part I, in which massive
rings encircle the globe in a low orbit supporting stationary 'sky-hooks,' from which cables hang down to any point on
the Earth's surface. Vehicles can climb up these 'ladders' into orbit, or can accelerate along the rings. The structure and
deployment of such Orbital Ring Systems is examined and their varied uses considered; several scenarios are considered
and shown to be economically feasible and beneficial.</p></div>`;

      // State
      const state = {
        // history: { score: string, commands: object, resultImage: base64String, structure: { elements, maxExtent }, probabilityScore: number }
        history: [],
        aiLog: [],
        currTab: "html",
        targetAI: document.getElementById("target-canvas-ai"),
        renderAI: document.getElementById("render-canvas-ai"),
        overlapCanvas: document.getElementById("overlap-canvas"),
        viewCanvas: document.getElementById("view-canvas"),
        viewCtx: null,
        MAX_VERTICAL_EM: 10.0,

        // --- NEW STATE TRACKERS ---
        currentMode: "POSITION", // Starts with POSITION
        iterationCounter: 0, // Counts total iterations executed
        skipNextPosition: false, // Flag to skip the next POSITION run
        skipNextSize: false, // Flag to skip the next SIZE run
        // --------------------------
      };

      const els = {
        wrapper: document.getElementById("wrapper"),
        layer: document.getElementById("overlay-html-layer"),
        output: document.getElementById("debug-textarea"),
        logView: document.getElementById("debug-log-view"),
        status: document.getElementById("ai-status"),
        runBtn: document.getElementById("run-btn"),
        loopInput: document.getElementById("loop-count"),
        modeDisplay: document.getElementById("current-mode-display"),
      };

      // --- UI Logic ---
      window.setTab = (t) => {
        state.currTab = t;

        const isHtmlTab = t === "html";
        els.output.classList.toggle("hidden", !isHtmlTab);
        els.logView.classList.toggle("hidden", isHtmlTab);

        document.querySelectorAll(".tab").forEach((el) => {
          el.classList.remove("active");
          if (el.id.includes(t)) {
            el.classList.add("active");
          }
        });

        if (t === "html") {
          els.output.value = els.layer.innerHTML
            .replace(/<\/div>/g, "</div>\n")
            .replace(/<br>/g, "<br>\n");
        } else if (t === "log") {
          renderDiagnosticLog();
        }
      };

      function renderDiagnosticLog() {
        let logContent = state.aiLog
          .map((entry, i) => {
            const status = entry.success
              ? "SUCCESS"
              : entry.skipped
                ? "SKIPPED"
                : "ERROR";
            const statusColor = entry.success
              ? "#9be658"
              : entry.skipped
                ? "#fcd34d"
                : "#ef4444";

            const rawResponse = entry.response
              ? JSON.stringify(entry.response, null, 2)
              : entry.response;

            const images = entry.request?.images;
            const score = entry.request?.score || "N/A";
            const mode = entry.request?.mode || "N/A";
            const modeClass = mode.toLowerCase();
            const probScore = entry.request?.probabilityScore
              ? ` | Prob. Sum: ${entry.request.probabilityScore.toFixed(2)}`
              : "";

            const targetImgHtml = images?.target
              ? `<img src="data:image/png;base64,${images.target}" class="image-thumbnail-payload border-red-400" alt="Target Image Thumbnail" />`
              : `<div style="width: 100px; height: 60px; background: #374151; display: flex; align-items: center; justify-content: center; color: #fff; font-size: 0.7rem;">[No Target]</div>`;

            const renderImgHtml = images?.render
              ? `<img src="data:image/png;base64,${images.render}" class="image-thumbnail-payload border-blue-400" alt="Render Image Thumbnail" />`
              : `<div style="width: 100px; height: 60px; background: #374151; display: flex; align-items: center; justify-content: center; color: #fff; font-size: 0.7rem;">[No Render]</div>`;

            // --- FULL STRUCTURAL DATA ---
            const structureData = entry.request?.structure
              ? JSON.stringify(entry.request.structure, null, 2)
              : '// N/A';

            // --- FULL PROMPT TEXT ---
            const promptText = entry.request?.promptText || '// N/A';

            const commandDisplay = entry.skipped
              ? `<p class="text-xs text-yellow-400 mt-1 mb-1">Skipped. Probability Sum (${entry.request.probabilityScore.toFixed(2)}) > 1.00.</p>`
              : `<p class="text-xs text-yellow-400 mt-1 mb-1">Raw Commands Executed:</p><pre class="log-pre" style="color: #fca311;">${rawResponse}</pre>`;

            return `<div class="log-history-entry">
                        <h4 style="font-weight: bold; color: ${statusColor};">
                          --- Iteration ${entry.iter} (${entry.timestamp}) - ${status} 
                          <span class="font-mono ${modeClass}">(${mode} MODE)${probScore}</span> ---
                        </h4>
                        <div style="margin-top: 0.5rem; display: flex; gap: 1rem; align-items: flex-start;">
                            <div style="text-align: center; font-family: monospace;">Target:<br>${targetImgHtml}</div>
                            <div style="text-align: center; font-family: monospace;">Render:<br>${renderImgHtml}</div>
                            <div class="flex-1">
                                <p style="color: #60a5fa; margin-top: 0.5rem; font-family: monospace; font-size: 0.8rem;">Pre-Execution Delta Score: ${score}</p>
                                ${commandDisplay}
                            </div>
                        </div>

                        <details class="log-details">
                            <summary class="log-summary">View Structural Data (Input)</summary>
                            <pre class="log-pre" style="color: #60a5fa;">${structureData}</pre>
                        </details>

                        <details class="log-details">
                            <summary class="log-summary">View Full Prompt Text Sent to AI</summary>
                            <pre class="log-pre" style="color: #9be658;">${promptText}</pre>
                        </details>
                    </div>`;
          })
          .join("");
        els.logView.innerHTML =
          logContent ||
          "<div style='font-family: monospace; color: #666;'>// No AI responses yet. Click 'Run' to start.</div>";
      }

      els.output.addEventListener("input", () => {
        if (state.currTab === "html") {
          els.layer.innerHTML = els.output.value;
        }
      });

      // --- Core Logic ---

      function getStructure(divId) {
        const div = document.getElementById(divId);
        if (!div) return { elements: [], maxExtent: "0.00" };

        Array.from(div.children).forEach((el, i) => {
          if (!el.id) el.id = `blk-${Date.now()}-${i}`;
        });

        let maxExtent = 0;

        const elements = Array.from(div.children)
          .filter((el) => el.innerText.trim().length > 0)
          .map((el) => {
            const computedStyle = window.getComputedStyle(el);
            // Default to 1.0em if not explicitly set, matching INITIAL_HTML
            const currentTop = parseFloat(el.style.top) || 0;
            const currentSize = parseFloat(el.style.fontSize) || 1.0;

            // This calculation is correct if top/size are in EM units relative to the container
            const elementBottom = currentTop + currentSize;
            if (elementBottom > maxExtent) {
              maxExtent = elementBottom;
            }

            return {
              id: el.id,
              tag: el.tagName.toLowerCase(),
              text: el.innerText.substring(0, 30),
              currentStyles: {
                top: el.style.top || "0em",
                left: el.style.left || "0em",
                fontSize: el.style.fontSize || "1.0em", // Ensures a value is always reported
                fontFamily: el.style.fontFamily || computedStyle.fontFamily,
                fontWeight: el.style.fontWeight || computedStyle.fontWeight,
              },
            };
          });

        return { elements, maxExtent: maxExtent.toFixed(2) };
      }

      /**
       * Applies commands, strictly filtering them based on the current execution mode,
       * and extracts the total probability score.
       * @param {object} updates - The parsed JSON commands from the AI.
       * @param {string} mode - The current execution mode ("POSITION" or "SIZE").
       * @returns {{appliedCommands: object, probabilityScore: number}}
       */
      function applyCommands(updates, mode) {
        const allowedMoveActions =
          mode === "POSITION"
            ? ["moveUp", "moveDown", "moveLeft", "moveRight", "moveTogether", "moveApart"]
            : ["grow", "shrink"];

        const PROBABILITY_FIELD = "dampenFutureChanges";
        const elementMap = Array.from(document.getElementById(TEST_ID).children)
                             .reduce((map, el) => { map[el.id] = el; return map; }, {});
        const elementIds = Object.keys(elementMap);

        let applied = {};
        let totalProbability = 0;

        for (const [id, cmds] of Object.entries(updates)) {
          const el = elementMap[id];
          if (!el || !Array.isArray(cmds)) continue;

          el.style.position = "relative";
          let top = parseFloat(el.style.top) || 0;
          let left = parseFloat(el.style.left) || 0;
          let size = parseFloat(el.style.fontSize) || 1.0;

          let elementApplied = [];
          let elementHasMoveAction = false;

          cmds.forEach((c) => {
            const v = parseFloat(c.changeAmount) || 0;
            const action = c.action;
            
            // 1. Extract Probability from the command object
            if (c[PROBABILITY_FIELD] !== undefined) {
              const pValue = parseFloat(c[PROBABILITY_FIELD]) || 0;
              totalProbability += Math.min(1.0, Math.max(0.0, pValue));
            }

            // 2. Apply Move/Size/Group Action
            if (allowedMoveActions.includes(action)) {
              if (action === "moveUp") top -= v;
              else if (action === "moveDown") top += v;
              else if (action === "moveLeft") left -= v;
              else if (action === "moveRight") left += v;
              else if (action === "grow") size += v;
              else if (action === "shrink") size = Math.max(0.1, size - v);
              else if (action === "moveTogether" || action === "moveApart") {
                // Apply vertical change to subsequent elements
                const isMoveApart = action === "moveApart";
                const direction = isMoveApart ? 1 : -1;
                const startingIndex = elementIds.indexOf(id);

                if (startingIndex !== -1) {
                    for (let i = startingIndex + 1; i < elementIds.length; i++) {
                        const targetId = elementIds[i];
                        const targetEl = elementMap[targetId];
                        if (targetEl) {
                            let targetTop = parseFloat(targetEl.style.top) || 0;
                            targetTop += v * direction;
                            targetEl.style.top = targetTop.toFixed(2) + "em";
                        }
                    }
                }
              }

              elementApplied.push(c);
              elementHasMoveAction = true;
            }
            // Ignore any action that is not a recognized move/size command
          });

          // Only apply styles if a change (move/size) actually happened to the originating element
          if (elementHasMoveAction) {
            el.style.top = top.toFixed(2) + "em";
            el.style.left = left.toFixed(2) + "em";
            el.style.fontSize = size.toFixed(2) + "em";
          }

          if (elementApplied.length > 0) {
            applied[id] = elementApplied;
          }
        }
        // Since we are now summing all probabilities across all elements, we return that single total sum.
        return { appliedCommands: applied, probabilityScore: totalProbability };
      }

      function createOverlapCanvas(targetCan, htmlCan) {
        const w = targetCan.width;
        const h = targetCan.height;
        const overlapCan = state.overlapCanvas;
        overlapCan.width = w;
        overlapCan.height = h;
        const overlapCtx = overlapCan.getContext("2d");

        overlapCtx.clearRect(0, 0, w, h);

        const targetData = targetCan.getContext("2d").getImageData(0, 0, w, h);
        const htmlData = htmlCan.getContext("2d").getImageData(0, 0, w, h);
        const overlapData = overlapCtx.createImageData(w, h);

        const COLOR_THRESHOLD = 120;
        const ALPHA_THRESHOLD = 100;
        const BLUE = [0, 0, 255, 255]; // Pure blue for overlap

        for (let i = 0; i < targetData.data.length; i += 4) {
          const avgTargetColor =
            (targetData.data[i] +
              targetData.data[i + 1] +
              targetData.data[i + 2]) /
            3;
          // Check if Target has dark text
          const isTargetText = avgTargetColor < COLOR_THRESHOLD;

          // Check if HTML Render has dark text and is visible (alpha > threshold)
          const avgHtmlColor =
            (htmlData.data[i] + htmlData.data[i + 1] + htmlData.data[i + 2]) /
            3;
          const isHtmlText =
            htmlData.data[i + 3] > ALPHA_THRESHOLD &&
            avgHtmlColor < COLOR_THRESHOLD;

          if (isTargetText && isHtmlText) {
            // Both have text: Draw Blue for overlap
            overlapData.data[i] = BLUE[0];
            overlapData.data[i + 1] = BLUE[1];
            overlapData.data[i + 2] = BLUE[2];
            overlapData.data[i + 3] = BLUE[3];
          }
        }

        overlapCtx.putImageData(overlapData, 0, 0);
        return overlapCan;
      }

      function createCombinedRender(targetCan, htmlCan) {
        const rendCan = state.renderAI;
        rendCan.width = targetCan.width;
        rendCan.height = targetCan.height;
        const rendCtx = rendCan.getContext("2d");

        rendCtx.drawImage(targetCan, 0, 0);
        rendCtx.drawImage(htmlCan, 0, 0);
        const overlapCan = createOverlapCanvas(targetCan, htmlCan);
        rendCtx.drawImage(overlapCan, 0, 0);

        return rendCan;
      }

      async function fetchWithBackoff(parts) {
        for (let attempt = 0; attempt < 5; attempt++) {
          try {
            const resp = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ contents: [{ role: "user", parts }] }),
              },
            );

            if (!resp.ok && resp.status === 429) {
              const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
              await new Promise((res) => setTimeout(res, delay));
              continue;
            }
            if (!resp.ok)
              throw new Error(
                `API error: ${resp.status} - ${await resp.text()}`,
              );

            const json = await resp.json();
            return json.candidates?.[0]?.content?.parts?.[0]?.text;
          } catch (e) {
            if (attempt === 4) throw e;
            await new Promise((res) =>
              setTimeout(res, Math.pow(2, attempt) * 1000),
            );
          }
        }
        throw new Error("API call failed after multiple retries.");
      }

      function cropAndScale(rect, scale, source) {
        const c = document.createElement("canvas");
        c.width = rect.w * scale;
        c.height = rect.h * scale;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, c.width, c.height);
        ctx.drawImage(
          source,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
          0,
          0,
          c.width,
          c.height,
        );
        return c;
      }

      function addBorder(canvas, color) {
        const c = document.createElement("canvas");
        c.width = canvas.width;
        c.height = canvas.height;
        const ctx = c.getContext("2d");
        ctx.drawImage(canvas, 0, 0);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, c.width, c.height);
        return c;
      }

      function getRect(divId) {
        const div = document.getElementById(divId);
        if (!div) return null;
        const cw = state.viewCanvas.width,
          ch = state.viewCanvas.height;
        return {
          x: (parseFloat(div.style.left) / 100) * cw,
          y: (parseFloat(div.style.top) / 100) * ch,
          w: (parseFloat(div.style.width) / 100) * cw,
          h: (parseFloat(div.style.height) / 100) * ch,
        };
      }

      function drawCombinedRenderToView() {
        const rect = getRect(TEST_ID);
        if (!rect || !state.viewCtx || !img) return;
        const rendCan = state.renderAI;
        state.viewCtx.drawImage(
          img,
          0,
          0,
          state.viewCanvas.width,
          state.viewCanvas.height,
        );
        state.viewCtx.drawImage(
          rendCan,
          0,
          0,
          rendCan.width,
          rendCan.height,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
        );
      }

      async function getDiff(b64A, b64B) {
        return new Promise((r) => {
          const i1 = new Image(),
            i2 = new Image();
          let c = 0;
          const onload = () => {
            if (++c === 2) diff();
          };
          i1.onload = onload;
          i2.onload = onload;
          i1.src = "data:image/png;base64," + b64A;
          i2.src = "data:image/png;base64," + b64B;
          function diff() {
            const cv = document.createElement("canvas");
            cv.width = i1.width;
            cv.height = i1.height;
            const cx = cv.getContext("2d");
            cx.drawImage(i1, 0, 0);
            const d1 = cx.getImageData(0, 0, cv.width, cv.height).data;
            cx.clearRect(0, 0, cv.width, cv.height);
            cx.drawImage(i2, 0, 0);
            const d2 = cx.getImageData(0, 0, cv.width, cv.height).data;
            let sum = 0;
            for (let k = 0; k < d1.length; k += 4)
              sum +=
                Math.abs(d1[k] - d2[k]) +
                Math.abs(d1[k + 1] - d2[k + 1]) +
                Math.abs(d1[k + 2] - d2[k + 2]);
            r(sum / (i1.width * i1.height * 765));
          }
        });
      }

      function preparePayloadAndPrompt(
        targetCanvas,
        renderCanvas,
        iterLabel,
        currentMode,
        currentTemplate,
      ) {
        const divEl = document.getElementById(TEST_ID);
        if (!divEl) {
          return { parts: [{ text: "// Error: Content not found" }] };
        }

        // 1. Get Current Structure and Max Extent (Pre-Delta)
        const { elements: currentElements, maxExtent } = getStructure(TEST_ID);
        // --- DELTA CALCULATION & COMMAND INJECTION ---
        const previousHistoryForDelta = state.history[1];
        const commandsFromPreviousRun = state.history[0]
          ? state.history[0].commands
          : {};
        let augmentedElements = currentElements;
        const PROBABILITY_FIELD = "dampenFutureChanges";

        if (
          previousHistoryForDelta &&
          previousHistoryForDelta.structure &&
          previousHistoryForDelta.structure.elements
        ) {
          const previousElements = previousHistoryForDelta.structure.elements;

          augmentedElements = currentElements.map((currentEl) => {
            const prevEl = previousElements.find(
              (el) => el.id === currentEl.id,
            );

            const deltaStyles = {};

            if (prevEl) {
              const currentTop = parseFloat(currentEl.currentStyles.top);
              const prevTop = parseFloat(prevEl.currentStyles.top);
              deltaStyles.top = (currentTop - prevTop).toFixed(2) + "em";

              const currentLeft = parseFloat(currentEl.currentStyles.left);
              const prevLeft = parseFloat(prevEl.currentStyles.left);
              deltaStyles.left = (currentLeft - prevLeft).toFixed(2) + "em";

              const currentSize = parseFloat(currentEl.currentStyles.fontSize);
              const prevSize = parseFloat(prevEl.currentStyles.fontSize);
              deltaStyles.fontSize = (currentSize - prevSize).toFixed(2) + "em";
            }

            // We include all commands here for detailed logging later, but we need to
            // strip the probability field from the commands we send back as 'history'
            const commandsAppliedToThisElement =
              commandsFromPreviousRun[currentEl.id] || [];
              
            const sanitizedCommands = commandsAppliedToThisElement.map(cmd => {
                const newCmd = {...cmd};
                delete newCmd[PROBABILITY_FIELD];
                return newCmd;
            });

            return {
              ...currentEl,
              deltaStyles: prevEl
                ? deltaStyles
                : { top: "0.00em", left: "0.00em", fontSize: "0.00em" },
              // IMPORTANT: Use the sanitized commands without probability for structure history sent to the AI
              commandsAppliedInLastStep: sanitizedCommands, 
            };
          });
        }
        // 2. Build Constraint Warning and Dynamic Command Lists
        const maxLimit = state.MAX_VERTICAL_EM.toFixed(2);
        const overLimit = parseFloat(maxExtent) >= parseFloat(maxLimit);
        const remaining = (
          parseFloat(maxLimit) - parseFloat(maxExtent)
        ).toFixed(2);

        // --- Dynamic Command List Generation ---
        let positionCommandsString;
        let sizeCommandsString;
        
        // --- POSITION COMMANDS INCLUDE GROUP ACTIONS ---
        const ALL_POSITION_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO POSITION)
1. Single Move: "moveUp", "moveDown", "moveLeft", "moveRight" (Coefficient: 0.10 to 5.00, or up to 20.00 for vertical distance correction).
2. Group Vertical Adjustment (moves subsequent elements): "moveTogether" (reduces vertical space), "moveApart" (increases vertical space). (Coefficient: 0.10 to 5.00).
   - NOTE: Each command should optionally include a "${PROBABILITY_FIELD}" (0.00 to 1.00) field.
`;
        const RESTRICTED_POSITION_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO POSITION)
1. Single Move: "moveUp", "moveLeft", "moveRight" (Coefficient: 0.10 to 5.00, or up to 20.00 for vertical distance correction).
   // Note: "moveDown" is disabled due to vertical constraint (${maxExtent}em >= ${maxLimit}em).
2. Group Vertical Adjustment (moves subsequent elements): "moveTogether" (reduces vertical space only). (Coefficient: 0.10 to 5.00).
   // Note: "moveApart" is disabled due to vertical constraint.
   - NOTE: Each command should optionally include a "${PROBABILITY_FIELD}" (0.00 to 1.00) field.
`;
        // --- SIZE COMMANDS (UNCHANGED) ---
        const ALL_SIZE_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO SIZE)
1. Size: "grow", "shrink" (Coefficient: 0.10 to 5.00).
   - NOTE: 'grow' and 'shrink' adjust the 'fontSize' attribute.
   - NOTE: Each size command should optionally include a "${PROBABILITY_FIELD}" (0.00 to 1.00) field.
`;
        const RESTRICTED_SIZE_COMMANDS = `
# AVAILABLE COMMANDS (STRICTLY LIMITED TO SIZE)
1. Size: "shrink" (Coefficient: 0.10 to 5.00).
   // Note: "grow" is disabled due to vertical constraint (${maxExtent}em >= ${maxLimit}em).
   - NOTE: 'shrink' adjusts the 'fontSize' attribute.
   - NOTE: Each size command should optionally include a "${PROBABILITY_FIELD}" (0.00 to 1.00) field.
`;

        if (overLimit) {
          positionCommandsString = RESTRICTED_POSITION_COMMANDS;
          sizeCommandsString = RESTRICTED_SIZE_COMMANDS;
        } else {
          positionCommandsString = ALL_POSITION_COMMANDS;
          sizeCommandsString = ALL_SIZE_COMMANDS;
        }
        // --- End Dynamic Command List Generation ---

        // Simplify constraint text
        let constraintText = `\n\n*** VERTICAL CONSTRAINT STATUS ***\n`;
        constraintText += `MAX: ${maxLimit}em. CURRENT: ${maxExtent}em. REMAINING: ${remaining}em.\n`;
        if (overLimit) {
          constraintText += `STATUS: LIMIT REACHED. Toolset restricted to UP/LEFT/RIGHT/SHRINK/MOVETOGETHER.\n`;
        }
        constraintText += `**********************************\n\n`;

        // Replace the placeholders in the chosen template
        let finalPromptText = currentTemplate.replace(
          "{{structure}}",
          JSON.stringify(augmentedElements, null, 2),
        );
        finalPromptText = finalPromptText.replace(
          "{{constraint}}",
          constraintText,
        );

        // Apply dynamic command lists
        finalPromptText = finalPromptText.replace(
          "{{positionCommands}}",
          positionCommandsString,
        );
        finalPromptText = finalPromptText.replace(
          "{{sizeCommands}}",
          sizeCommandsString,
        );

        // --- Prepare Payload Parts (Interleaved) ---
        const parts = [];

        // 3. History (if any)
        const chronologicalHistory = state.history.slice(0, 3).reverse();
        if (chronologicalHistory.length > 0) {
          parts.push({
            text: "### HISTORY OF RECENT ACTIONS (Oldest to Newest):\n",
          });
          chronologicalHistory.forEach((h, i) => {
            const currentRun = parseInt(iterLabel.match(/\d+/)?.[0] || "1", 10);
            const stepNum = currentRun - (state.history.length - i);

            const probSum = h.probabilityScore
              ? ` | Prob. Sum: ${h.probabilityScore.toFixed(2)}`
              : "";

            // --- SANITIZE COMMANDS FOR HISTORY ---
            const sanitizedCommands = {};
            for (const elementId in h.commands) {
                if (Array.isArray(h.commands[elementId])) {
                    sanitizedCommands[elementId] = h.commands[elementId].map(command => {
                        const newCmd = {...command};
                        delete newCmd[PROBABILITY_FIELD];
                        return newCmd;
                    });
                }
            }
            // --- END SANITIZATION ---

            // IMPORTANT: Use the sanitized commands for history sent to the model
            const stepText = `\n--- Step ${Math.max(0, stepNum)}${probSum} ---\nDelta Score (Pre-Command): ${h.score}\nCommands Executed: ${JSON.stringify(sanitizedCommands)}\nRESULTING FRAME (below):`;

            parts.push({ text: stepText });
            parts.push({
              inlineData: { mimeType: "image/png", data: h.resultImage },
            });
          });
          parts.push({ text: "\n----------------\n" });
        } else {
          parts.push({
            text: "(No history available yet. This is the first step.)\n",
          });
        }

        // 4. Current Context
        const borderedTarget = addBorder(targetCanvas, "#f00");
        const borderedRender = addBorder(renderCanvas, "#3b82f6");
        const targetBase64 = borderedTarget.toDataURL().split(",")[1];
        const renderBase64 = borderedRender.toDataURL().split(",")[1];

        // The prompt text goes first
        parts.push({
          text:
            finalPromptText +
            "\n\n--- VISUAL INPUTS ---\n1. TARGET (Red Border):\n",
        });
        parts.push({
          inlineData: { mimeType: "image/png", data: targetBase64 },
        });

        parts.push({ text: "\n2. CURRENT RENDER (Blue Border):\n" });
        parts.push({
          inlineData: { mimeType: "image/png", data: renderBase64 },
        });

        // --- Full Payload Object for Logging ---
        const payloadObj = {
          iter: iterLabel || "Initial",
          mode: currentMode,
          score: "Calculated Pre-Execution",
          constraint: { maxLimit, currentExtent: maxExtent },
          promptText: finalPromptText,
          structure: augmentedElements,
          images: {
            target: targetBase64,
            render: renderBase64,
          },
          history: chronologicalHistory.map((h, i) => {
            const currentRun = parseInt(iterLabel.match(/\d+/)?.[0] || "1", 10);
            const step = currentRun - (state.history.length - i);
            return {
              step: Math.max(0, step),
              score: h.score,
              commands: h.commands,
              probabilityScore: h.probabilityScore || 0,
            };
          }),
        };

        return { parts, payloadObj };
      }

      async function updateAIImagesAndPayload(
        originalImage,
        isInitialRun,
        iterLabel,
        scale,
      ) {
        const divEl = document.getElementById(TEST_ID);
        if (!divEl) return;
        const rect = getRect(TEST_ID);

        if (isInitialRun) {
          const srcCan = cropAndScale(rect, DEFAULT_AI_SCALE, originalImage);
          state.targetAI.width = srcCan.width;
          state.targetAI.height = srcCan.height;
          state.targetAI.getContext("2d").drawImage(srcCan, 0, 0);
        }

        const htmlLayerCan = await html2canvas(divEl, {
          scale: scale,
          backgroundColor: null,
          width: rect.w,
          height: rect.h,
        });

        let scaledTargetCan = state.targetAI;
        if (scale !== DEFAULT_AI_SCALE) {
          scaledTargetCan = cropAndScale(rect, scale, originalImage);
        }

        const renderCan = createCombinedRender(scaledTargetCan, htmlLayerCan);

        // This call is just to prepare the payload object in memory, we don't use its 'parts'
        const { payloadObj } = preparePayloadAndPrompt(
          scaledTargetCan,
          renderCan,
          iterLabel,
          state.currentMode,
          state.currentMode === "POSITION" ? POSITION_TEMPLATE : SIZE_TEMPLATE,
        );

        if (isInitialRun) {
          const resultB64 = renderCan.toDataURL().split(",")[1];
          const { elements: initialElements, maxExtent: initialExtent } =
            getStructure(TEST_ID);

          if (
            state.history.length === 0 ||
            state.history[state.history.length - 1].commands !== null
          ) {
            state.history.unshift({
              score: "0.00%",
              commands: {},
              resultImage: resultB64,
              structure: {
                elements: initialElements,
                maxExtent: initialExtent,
              },
              probabilityScore: 0,
            });
          }
        }
      }

      async function runIteration(i, max) {
        state.iterationCounter++;
        state.currentMode =
          state.iterationCounter % 2 === 1 ? "POSITION" : "SIZE";
        const currentTemplate =
          state.currentMode === "POSITION" ? POSITION_TEMPLATE : SIZE_TEMPLATE;

        // --- PROBABILITY CHECK FOR SKIPPING & DECAY LOGIC ---
        let skip = false;
        let skipFlag = state.currentMode === "POSITION" ? state.skipNextPosition : state.skipNextSize;

        if (skipFlag) {
          skip = true;
          // Reset own skip flag
          if (state.currentMode === "POSITION") {
            state.skipNextPosition = false;
          } else {
            state.skipNextSize = false;
          }

          if (state.history.length > 0) {
            // Decay the probability score of the MOST RECENT run (which belongs to the mode that successfully caused the skip)
            const decayIndex = 0; 
            const originalScore = state.history[decayIndex].probabilityScore;

            if (originalScore > 0) {
              const decayedScore = originalScore / 2;
              state.history[decayIndex].probabilityScore = decayedScore;
              console.log(
                `Skipped ${state.currentMode}. Decayed previous mode's probability from ${originalScore.toFixed(2)} to ${decayedScore.toFixed(2)}.`,
              );
            }
          }
        }

        els.modeDisplay.textContent = skip
          ? `${state.currentMode} (SKIP)`
          : state.currentMode;
        els.modeDisplay.className = skip
          ? "text-yellow-500"
          : `mode-${state.currentMode.toLowerCase()}`;

        const iter = `Run ${i}/${max}`;

        // If we skip, we still need the pre-run log data.
        if (skip) {
          await updateAIImagesAndPayload(img, false, iter, DEFAULT_AI_SCALE);
          const { payloadObj } = preparePayloadAndPrompt(
            state.targetAI,
            state.renderAI,
            iter,
            state.currentMode,
            currentTemplate,
          );

          let logEntry = {
            iter,
            success: false,
            skipped: true,
            request: {
              ...payloadObj,
              probabilityScore: state.history[0]?.probabilityScore || 0,
            },
            response: "Skipped by probability filter",
            timestamp: new Date().toLocaleTimeString(),
          };
          state.aiLog.unshift(logEntry);
          if (state.currTab === "log") renderDiagnosticLog();
          return;
        }

        const divEl = document.getElementById(TEST_ID);
        if (!divEl) return;

        currentRunScale = i === max ? FINAL_AI_SCALE : DEFAULT_AI_SCALE;

        els.status.textContent = `${iter} Capturing for ${state.currentMode}... (Scale: ${currentRunScale})`;
        els.status.style.display = "inline";

        await updateAIImagesAndPayload(img, false, iter, currentRunScale);
        const srcCan = state.targetAI;
        const rendCan = state.renderAI;

        const srcB64 = srcCan.toDataURL().split(",")[1];
        const rendB64 = rendCan.toDataURL().split(",")[1];
        const deltaScore = await getDiff(srcB64, rendB64);
        const scoreString = (deltaScore * 100).toFixed(2) + "%";

        const { parts, payloadObj } = preparePayloadAndPrompt(
          srcCan,
          rendCan,
          iter,
          state.currentMode,
          currentTemplate,
        );
        payloadObj.score = scoreString;

        if (state.currTab === "log") renderDiagnosticLog();

        els.status.textContent = `${iter} Thinking in ${state.currentMode} Mode... (Score: ${scoreString})`;
        let logEntry = {
          iter,
          success: false,
          skipped: false,
          request: payloadObj,
          response: "Error/No response",
          timestamp: new Date().toLocaleTimeString(),
        };

        try {
          const resultJsonStr = await fetchWithBackoff(parts);
          if (!resultJsonStr) throw new Error("Empty response from AI.");

          const jsonMatch = resultJsonStr.match(/\{[\s\S]*\}/);
          const updates = JSON.parse(jsonMatch ? jsonMatch[0] : "{}");

          logEntry.response = updates;
          logEntry.success = true;

          const { appliedCommands, probabilityScore } = applyCommands(
            updates,
            state.currentMode,
          );

          logEntry.request.probabilityScore = probabilityScore;

          // Set skip flag for the *next* time the *current* mode runs, if it was highly confident (probability sum > 1.0).
          if (probabilityScore > 1.0) {
            if (state.currentMode === "POSITION") state.skipNextPosition = true;
            else if (state.currentMode === "SIZE")
              state.skipNextSize = true;
            console.log(
              `Probability score (${probabilityScore.toFixed(2)}) > 1.0. Setting skip flag for next ${state.currentMode} run.`,
            );
          }

          await updateAIImagesAndPayload(
            img,
            false,
            `${iter} (Post-Apply)`,
            DEFAULT_AI_SCALE,
          );
          const resultB64 = state.renderAI.toDataURL().split(",")[1];

          const {
            elements: postCommandElements,
            maxExtent: postCommandExtent,
          } = getStructure(TEST_ID);

          state.history.unshift({
            score: scoreString,
            commands: appliedCommands,
            resultImage: resultB64,
            structure: {
              elements: postCommandElements,
              maxExtent: postCommandExtent,
            },
            probabilityScore: probabilityScore,
          });

          console.log(
            `Applied ${Object.keys(appliedCommands).length} updates in ${state.currentMode} mode. Score: ${scoreString} | Probability Sum: ${probabilityScore.toFixed(2)}`,
          );

          await updateAIImagesAndPayload(
            img,
            false,
            `Pre-Run ${i + 1}/${max}`,
            currentRunScale,
          );
          drawCombinedRenderToView();

          els.output.value = els.layer.innerHTML
            .replace(/<\/div>/g, "</div>\n")
            .replace(/<br>/g, "<br>\n");
          if (state.currTab === "html") window.setTab("html");
        } catch (e) {
          logEntry.response = `Error: ${e.message}`;
          console.error(e);
        } finally {
          state.aiLog.unshift(logEntry);
          if (state.currTab === "log") renderDiagnosticLog();

          await updateAIImagesAndPayload(
            img,
            false,
            `Pre-Run ${i + 1}/${max}`,
            currentRunScale,
          );
          drawCombinedRenderToView();
        }
      }

      els.runBtn.onclick = async () => {
        els.runBtn.disabled = true;
        state.history = [];
        state.aiLog = [];
        state.iterationCounter = 0; // Reset counter
        state.skipNextPosition = false; // Reset skip flags
        state.skipNextSize = false; // Reset skip flags

        els.layer.innerHTML = INITIAL_HTML;
        els.output.value = INITIAL_HTML.replace(/<\/div>/g, "</div>\n").replace(
          /<br>/g,
          "</p>\n<p>",
        );
        await updateAIImagesAndPayload(
          img,
          true,
          "Initial Baseline Reset",
          DEFAULT_AI_SCALE,
        );

        const max = parseInt(els.loopInput.value);
        for (let i = 1; i <= max; i++) await runIteration(i, max);
        els.layer.innerHTML = els.output.value;
        drawCombinedRenderToView();
        els.status.style.display = "none";
        els.runBtn.disabled = false;
        window.setTab("html");
        els.modeDisplay.textContent = "DONE";
        els.modeDisplay.className = "text-green-400";
      };

      // Initialization
      els.output.value = INITIAL_HTML.replace(/<\/div>/g, "</div>\n").replace(
        /<br>/g,
        "</p>\n<p>",
      );
      els.layer.innerHTML = INITIAL_HTML;
      window.setTab("html");
      els.modeDisplay.textContent = "READY";

      img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = async () => {
        state.viewCanvas.width = img.width;
        state.viewCanvas.height = img.height;
        els.wrapper.style.width = state.viewCanvas.width + "px";
        els.wrapper.style.height = state.viewCanvas.height + "px";
        state.viewCtx = state.viewCanvas.getContext("2d");
        state.viewCtx.drawImage(
          img,
          0,
          0,
          state.viewCanvas.width,
          state.viewCanvas.height,
        );
        await updateAIImagesAndPayload(img, true, "Initial", DEFAULT_AI_SCALE);

        drawCombinedRenderToView();
      };
      img.src = SAMPLE_URL;
    </script>
  </body>
</html>
